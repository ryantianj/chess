{"version":3,"file":"static/js/worker.worker.16b8e2bb.worker.js","mappings":"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","sources":["Chess/ai/worker.worker.js"],"sourcesContent":["let totalMoves = 0\nconst test = async (message) => {\n   // https://chess.stackexchange.com/questions/40362/my-transposition-tables-implementation-slows-down-alpha-beta-pruning\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/negamax/tutorials/alpha-beta_quiescence_search/chess.c\n    //https://stackoverflow.com/questions/29990116/alpha-beta-prunning-with-transposition-table-iterative-deepening\n    // https://stackoverflow.com/questions/16500739/chess-high-branching-factor\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/bbc/collecting_pv/bbc.c\n    // https://github.com/kbjorklu/chess/blob/master/src/bitboard.js\n    //https://chess.stackexchange.com/questions/28160/moves-per-depth-in-search-engines\n    // TODO: check if endgame before running search, set score tables before search, done after set board string\n    // End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\n    // TODO: update piece score tables based on position before running search, done after set board string\n    // for knight, -5 per missing pawn of any colour\n    // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\n    // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\n    // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\n    const mem = new Map() // for killer moves\n    const MAX_DEPTH = 10\n    let whiteCanCastle = true\n    let blackCanCastle = true\n    const pv_length = Array.from({length: MAX_DEPTH}, (x) => 0);\n    const pv_table = Array.from({length: MAX_DEPTH}, (x) => Array.from({length: MAX_DEPTH}, (x) => 0))\n    let currentPv = []\n    let startTime;\n    const MAX_TIME = 20000 // 20 seconds\n    const CHECK_THRESHOLD = 100000 // power of 2\n    let nodes = 0\n    let branch = 0\n    const ab =  (boardString, depth, moveString, colour, pv) => {\n        const copyBoard = new Board()\n        copyBoard.setBoardString(boardString)\n        copyBoard.moves = moveString.map(x => Move.parseMove(copyBoard, x))\n        // set pv from previous iteration\n        for (let i = 2; i < pv.length; i++) { // first two moves would have been made\n            pv_table[0][i - 2] = Move.parseMove(copyBoard, pv[i])\n        }\n        const prev = pv_table[0]\n        currentPv = [...prev]\n        const isEndGame = copyBoard.isEndGame()\n        if (isEndGame) {\n            console.log(\"endgame\")\n            copyBoard.setEndGame()\n        }\n        copyBoard.updatePieceValues(totalMoves)\n        for (let i = 1; i < depth; i++) {\n            mem.set(i, [null, null, null]) // max number of killer moves\n        }\n        startTime = performance.now()\n        let result\n        for (let i = 1; i <= depth; i++) { // iterative deepening\n            result = miniMax(copyBoard, i, -Number.MAX_VALUE, Number.MAX_VALUE, colour, colour, mem, 0)\n            const prev = pv_table[0]\n            currentPv = [...prev]\n            console.log(i, \"Score\", result[1], pv_table[0][0].newCell)\n        }\n        // result = miniMax(copyBoard, depth, -Number.MAX_VALUE, Number.MAX_VALUE, colour, colour, mem, 0)\n        const end = performance.now()\n        // console.log(end - start, totalMoves, nodes)\n        const arr = []\n        for (let i = 0; i < depth; i++) {\n            if (pv_table[0][i] === 0) {\n                break\n            }\n            arr.push(pv_table[0][i].getMoveString())\n        }\n        console.log(end - startTime, nodes, branch)\n        // console.log(\"eval\", nodes)\n\n\n        return [pv_table[0][0].getMoveString(), arr] // should be a move\n    }\n\n    const miniMax = (board, depth, alpha, beta, maxPlayer, currentPlayer, mem, ply) => {\n        if (nodes % CHECK_THRESHOLD === 0) {\n            if (performance.now() - startTime > MAX_TIME) {\n                return [pv_table[0][0], -99999]\n            }\n        }\n        const moves = board.getAllMoves(currentPlayer) // TODO: time consuming\n        moveOrderRoot(moves, depth, ply)\n        let bestMove;\n        if (currentPlayer === maxPlayer) {\n            let maxEval = -90000\n            let legal = 0\n            for (let i = 0; i < moves.length; i++) {\n                const move = moves[i]\n                board.movePiece(move.piece, move)\n                if (board.isIllegal(currentPlayer, move)) {\n                    board.undoMove()\n\n                    continue\n                }\n                legal++\n                if (bestMove === undefined) {\n                    bestMove = move\n                }\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem, ply + 1, legal === 1)\n                board.undoMove()\n                if (currentEval > maxEval) {\n                    maxEval = currentEval\n                    bestMove = move\n                    pv_table[ply][ply] = move\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\n                        // copy move from deeper ply into a current ply's line\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\n                    }\n                    // adjust PV length\n                    pv_length[ply] = pv_length[ply + 1];\n                }\n                alpha = Math.max(alpha, currentEval)\n                if (beta <= alpha) {\n                    break\n                }\n            }\n            if (legal === 0) { // TODO: check stalemate\n                if (board.isCheck(currentPlayer)) {\n                    return [null, -90000]\n                }\n                return [null, 0]\n            }\n            return [bestMove, maxEval]\n        } else {\n            let minEval = 90000\n            let legal = 0\n            for (let i = 0; i < moves.length; i++) {\n                const move = moves[i]\n                board.movePiece(move.piece, move)\n                if (board.isIllegal(currentPlayer, move)) {\n                    board.undoMove()\n                    continue\n                }\n                legal++\n                if (bestMove === undefined) {\n                    bestMove = move\n                }\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem, ply + 1, legal === 1)\n                board.undoMove()\n                if (currentEval < minEval) {\n                    minEval = currentEval\n                    bestMove = move\n                    pv_table[ply][ply] = move\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\n                        // copy move from deeper ply into a current ply's line\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\n                    }\n                    // adjust PV length\n                    pv_length[ply] = pv_length[ply + 1];\n                }\n                beta = Math.min(beta, currentEval)\n                if (beta <= alpha) {\n                    break\n                }\n            }\n            if (legal === 0) {\n                if (board.isCheck(currentPlayer)) {\n                    return [null, 90000]\n                }\n                return [null, 0]\n\n            }\n            return [bestMove, minEval]\n        }\n    }\n    const miniMaxCore = (board, depth, alpha, beta, maxPlayer, currentPlayer, prevMoves, mem, ply, isLeftMost) => {\n        if (nodes % CHECK_THRESHOLD === 0) {\n            if (performance.now() - startTime > MAX_TIME) {\n                return -99999\n            }\n        }\n        let branchLocal = 0\n        nodes++\n        const MAX_KILLER = 2\n        pv_length[ply] = ply\n        if (depth === 0) {\n            let result\n            if (maxPlayer === currentPlayer && board.moves.slice(-1)[0].ate !== null) {\n                result = quiesce(alpha, beta, board, currentPlayer, 2, prevMoves)\n            } else {\n                result = board.getScore(maxPlayer, prevMoves)\n            }\n            return result\n        }\n        const moves = board.getAllMoves(currentPlayer) // TODO: time consuming\n        moveOrder(moves, mem, depth, ply, isLeftMost)\n        if (currentPlayer === maxPlayer) {\n            let maxEval = -30000\n            let legal = 0\n            for (let i = 0; i < moves.length; i++) {\n                const move = moves[i]\n                board.movePiece(move.piece, move)\n                if (board.isIllegal(currentPlayer, move)) {\n                    board.undoMove()\n                    continue\n                }\n                legal++\n                branchLocal++\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem, ply + 1, legal === 1)\n                board.undoMove()\n                if (currentEval > maxEval) {\n                    maxEval = currentEval\n                    pv_table[ply][ply] = move\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\n                        // copy move from deeper ply into a current ply's line\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\n                    }\n                    // adjust PV length\n                    pv_length[ply] = pv_length[ply + 1];\n                }\n                if (currentEval > alpha) {\n                    alpha = currentEval\n                }\n                if (beta <= alpha) {\n                    if (move.ate !== null) {\n                        break\n                    }\n                    const arr = mem.get(depth)\n                    if (arr.find(e => e!== null && isEqualMove(e, move))) {\n                        break\n                    }\n                    for (let j = MAX_KILLER - 2; j >= 0; j--) {\n                        arr[j + 1] = arr[j]\n                    }\n                    arr[0] = move\n                    break\n                }\n            }\n            branch = (branch + branchLocal) / 2\n            if (legal === 0) {\n                if (board.isCheck(currentPlayer)) {\n                    return -30000 * depth // faster checkmates\n                }\n                return 0 // stalemate\n            }\n            return maxEval\n        } else {\n            let minEval = 30000\n            let legal = 0\n            for (let i = 0; i < moves.length; i++) {\n                const move = moves[i]\n                board.movePiece(move.piece, move)\n                if (board.isIllegal(currentPlayer, move)) {\n                    board.undoMove()\n                    continue\n                }\n                legal++\n                branchLocal++\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, prevMoves, mem, ply +1, legal === 1)\n                board.undoMove()\n                if (currentEval < minEval) {\n                    minEval = currentEval\n                    pv_table[ply][ply] = move\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\n                        // copy move from deeper ply into a current ply's line\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\n                    }\n                    // adjust PV length\n                    pv_length[ply] = pv_length[ply + 1];\n                }\n\n                if (currentEval < beta) {\n                    beta = currentEval\n                }\n                if (beta <= alpha) {\n                    if (move.ate !== null) {\n                        break\n                    }\n                    const arr = mem.get(depth)\n                    if (arr.find(e => e!== null && isEqualMove(e, move))) {\n                        break\n                    }\n                    for (let j = MAX_KILLER - 2; j >= 0; j--) {\n                        arr[j + 1] = arr[j]\n                    }\n                    arr[0] = move\n                    break\n                }\n            }\n            branch = (branch + branchLocal) / 2\n            if (legal === 0) {\n                if (board.isCheck(currentPlayer)) {\n                    return 30000 * depth\n                }\n                return 0\n\n            }\n            return minEval\n        }\n    }\n\n    const moveOrderRoot = (moves, depth, ply) => {\n        const sortMovesO = (a, b) => {\n            const pvMove = currentPv[ply]\n            if (pvMove !== 0 && isEqualMove(a, pvMove)) {\n                return -1\n            } else if (pvMove !== 0 && isEqualMove(b, pvMove)) {\n                return 1\n            }\n            if (a.ate !== null && b.ate !== null) {\n                const aScore = a.piece.points - a.ate.points\n                const bScore = b.piece.points - b.ate.points\n                return aScore < bScore ? -1: 1\n            } else {\n                if (a.ate !== null) {\n                    return -1\n                } else if (b.ate !== null) {\n                    return 1\n                }\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\n                return aScore < bScore ? 1: -1\n\n            }\n        }\n        moves.sort(sortMovesO)\n    }\n\n    const moveOrder = (moves, mem, depth, ply, isLeftMost) => {\n\n        const sortMovesO = (a, b) => {\n            const pvMove = currentPv[ply]\n            if (isLeftMost && pvMove !== 0) {\n                if (isEqualMove(a, pvMove)) {\n                    return -1\n                } else if (isEqualMove(b, pvMove)) {\n                    return 1\n                }\n            }\n            if (a.ate !== null && b.ate !== null) {\n                const aScore = a.piece.points - a.ate.points\n                const bScore = b.piece.points - b.ate.points\n                return aScore < bScore ? -1: 1\n            } else {\n                if (a.ate !== null) {\n                    return -1\n                } else if (b.ate !== null) {\n                    return 1\n                }\n                const memSlot = mem.get(depth)\n                for (let slot = 0; slot < memSlot.length; slot++) {\n                    const killerMove = memSlot[slot]\n                    if (killerMove !== null && isEqualMove(a, killerMove)) {\n                        return -1\n                    }\n                    if (killerMove !== null && isEqualMove(b, killerMove)) {\n                        return 1\n                    }\n                }\n\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\n                return aScore < bScore ? 1: -1\n\n            }\n        }\n        moves.sort(sortMovesO)\n    }\n\n    const isEqualMove = (a, b) => {\n        if (a.newCell.row === b.newCell.row && a.newCell.col === b.newCell.col && a.oldCell.row === b.oldCell.row && a.oldCell.col === b.oldCell.col && a.piece.constructor === b.piece.constructor) {\n            if (a.ate !== null && b.ate !== null) {\n                return a.ate.constructor === b.ate.constructor\n            }\n            return a.ate === b.ate\n        }\n        return false\n    }\n\n    const sortMoves = (a, b) => {\n        if (a.ate !== null && b.ate !== null) {\n            const aScore = a.piece.points - a.ate.points\n            const bScore = b.piece.points - b.ate.points\n            return aScore < bScore ? -1: 1\n        } else {\n            if (a.ate !== null) {\n                return -1\n            } else if (b.ate !== null) {\n                return 1\n            } else {\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\n                return aScore < bScore ? 1: -1\n            }\n        }\n    }\n\n\n\n\n\n    const quiesce = (alpha, beta, board, colour, depth, prevMoves) => {\n        const evaluation = board.getScore(colour, prevMoves)\n        if (depth === 0) {\n            return evaluation\n        }\n        if (evaluation >= beta) {\n            return beta\n        }\n\n        alpha = Math.max(alpha, evaluation)\n        const moves = board.getAllMoves(colour)\n        moves.sort(sortMoves)\n        for (let i = 0; i < moves.length; i++) {\n            const move = moves[i]\n            if (move.ate !== null) { //  && move.ate.points > move.piece.points\n                board.movePiece(move.piece, move)\n                let score = -quiesce(-beta, -alpha, board, colour * -1, depth - 1, prevMoves)\n                board.undoMove()\n                if (score >= beta) {\n                    return beta\n                }\n                if (score > alpha) {\n                    alpha = score\n                }\n            } else {\n                break\n            }\n        }\n        return alpha\n    }\n    //\n    // const quiesceOdd = (alpha, beta, board, colour, depth) => {\n    //     // const evaluation = evaluate(board, colour)\n    //     let evaluation\n    //     const boardHash = board.getBoardHash() + colour.toString()\n    //     if (mem.has(boardHash)) {\n    //         evaluation = mem.get(boardHash)\n    //     } else {\n    //         evaluation = evaluate(board, colour)\n    //         mem.set(boardHash, evaluation)\n    //     }\n    //\n    //     if (depth === 0) {\n    //         return evaluation\n    //     }\n    //     if (evaluation >= beta) {\n    //         return beta\n    //     }\n    //\n    //     alpha = Math.max(alpha, evaluation)\n    //     const moves = board.getAllMoves(colour)\n    //     moves.sort(sortMovesQuiesce)\n    //     for (const move of moves) {\n    //         if (move.ate !== null) { //  && move.ate.points > move.piece.points\n    //             board.movePiece(move.piece, move)\n    //             let score = -quiesce(-beta, -alpha, board, switchColour(colour), depth - 1)\n    //             board.undoMove()\n    //             if (score >= beta) {\n    //                 return beta\n    //             }\n    //             if (score > alpha) {\n    //                 alpha = score\n    //             }\n    //         }\n    //     }\n    //     return alpha\n    // }\n\n    // const negaMax = (depth, board, colour, maxColour) => {\n    //     if (depth === 0) {\n    //         return evaluate(board, maxColour)\n    //     }\n    //     const testGameOver = board.isGameOver(colour).isGameOver\n    //     if (testGameOver && colour === maxColour) {\n    //         return -Number.MAX_VALUE\n    //     }\n    //     if (testGameOver && colour !== maxColour) {\n    //         return Number.MAX_VALUE\n    //     }\n    //     let max = -Number.MAX_VALUE\n    //     const moves = board.getAllMoves(colour)\n    //     for (const move of moves) {\n    //         board.movePiece(move.piece, move)\n    //         const currentEval = -negaMax(depth - 1, board, switchColour(colour), maxColour)\n    //         if (currentEval > max) {\n    //             max = currentEval\n    //         }\n    //         board.undoMove()\n    //     }\n    //     return max\n    // }\n    // const rootNegaMax = (depth, board, colour, maxColour) => {\n    //     const rootMoves = board.getAllMoves(maxColour)\n    //     let max = -Number.MAX_VALUE\n    //     const randomIndex = Math.floor(Math.random() * (rootMoves.length - 1))\n    //     let bestMove = rootMoves.length > 0 ? rootMoves[randomIndex] : null\n    //     for (const move of rootMoves) {\n    //         board.movePiece(move.piece, move)\n    //         const score = negaMax(depth, board, colour, maxColour)\n    //         if (score > max) {\n    //             max = score\n    //             bestMove = move\n    //         }\n    //         board.undoMove()\n    //     }\n    //     return bestMove\n    //\n    // }\n    class Board {\n        board;\n\n        constructor() {\n            this.board = this.newBoard()\n            this.moves = []\n        }\n\n        newBoard = () => {\n            const startingBoard = [\n                [new Rook(Piece.BLACK, new Cell(0,0)), new Knight(Piece.BLACK, new Cell(0, 1)), new Bishop(Piece.BLACK, new Cell(0, 2)), new Queen(Piece.BLACK, new Cell(0, 3)), new King(Piece.BLACK, new Cell(0, 4)), new Bishop(Piece.BLACK, new Cell(0, 5)), new Knight(Piece.BLACK, new Cell(0, 6)), new Rook(Piece.BLACK, new Cell(0,7))],\n                [new Pawn(Piece.BLACK, new Cell(1, 0)), new Pawn(Piece.BLACK, new Cell(1, 1)), new Pawn(Piece.BLACK, new Cell(1, 2)), new Pawn(Piece.BLACK, new Cell(1, 3)), new Pawn(Piece.BLACK, new Cell(1, 4)), new Pawn(Piece.BLACK, new Cell(1, 5)), new Pawn(Piece.BLACK, new Cell(1, 6)), new Pawn(Piece.BLACK, new Cell(1, 7))],\n                [null, null, null, null, null, null, null, null],\n                [null, null, null, null, null, null, null, null],\n                [null, null, null, null, null, null, null, null],\n                [null, null, null, null, null, null, null, null],\n                [new Pawn(Piece.WHITE, new Cell(6, 0)), new Pawn(Piece.WHITE, new Cell(6, 1)), new Pawn(Piece.WHITE, new Cell(6, 2)), new Pawn(Piece.WHITE, new Cell(6, 3)), new Pawn(Piece.WHITE, new Cell(6, 4)), new Pawn(Piece.WHITE, new Cell(6, 5)), new Pawn(Piece.WHITE, new Cell(6, 6)), new Pawn(Piece.WHITE, new Cell(6, 7))],\n                [new Rook(Piece.WHITE, new Cell(7,0)), new Knight(Piece.WHITE, new Cell(7, 1)), new Bishop(Piece.WHITE, new Cell(7, 2)), new Queen(Piece.WHITE, new Cell(7, 3)), new King(Piece.WHITE, new Cell(7, 4)), new Bishop(Piece.WHITE, new Cell(7, 5)), new Knight(Piece.WHITE, new Cell(7, 6)), new Rook(Piece.WHITE, new Cell(7,7))],\n            ]\n            return startingBoard\n        }\n        // update piece square tables for endgame\n        setEndGame = () => {\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null && piece.whiteScoreEnd !== undefined) {\n                        if (piece.colour === Piece.WHITE) {\n                            piece.whiteScore = piece.whiteScoreEnd\n                        } else {\n                            piece.blackScore = piece.blackScoreEnd\n                        }\n                    }\n                }\n            }\n        }\n        // update values of pieces\n        updatePieceValues = (totalMoves) => {\n            // set if colour can castle here\n            if (this.kingHasMoved(Piece.WHITE) || this.rookHasMoved(Piece.WHITE, King.KING_SIDE) || this.rookHasMoved(Piece.WHITE, King.QUEEN_SIDE)) {\n                whiteCanCastle = false\n            }\n            if (this.kingHasMoved(Piece.BLACK) || this.rookHasMoved(Piece.BLACK, King.KING_SIDE) || this.rookHasMoved(Piece.BLACK, King.QUEEN_SIDE)) {\n                blackCanCastle = false\n            }\n            const MOVE_THRESHOLD = 12\n            // for knight, -5 per missing pawn of any colour done\n            // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\n            // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\n            // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\n\n            let whitePawnCount = 0\n            let blackPawnCount = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        if (piece instanceof Pawn) {\n                            if (piece.colour === Piece.WHITE) {\n                                whitePawnCount++\n                            } else {\n                                blackPawnCount++\n                            }\n                        }\n                    }\n                }\n            }\n            const openFiles = []\n            for (let col = 0; col < 8; col++) {\n                let hasPawn = false\n                for (let row = 0; row < 8; row++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        if (piece instanceof Pawn) {\n                            hasPawn = true\n                            break\n                        }\n                    }\n                }\n                if (!hasPawn) {\n                    openFiles.push(col)\n                }\n            }\n\n            // first ten moves, bad to move queen out, and encourage piece development\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        if (piece instanceof Queen) {\n                            if (totalMoves <= MOVE_THRESHOLD) {\n                                if (piece.colour === Piece.WHITE) {\n                                    piece.whiteScore[7][3]+=50\n                                } else {\n                                    piece.blackScore[0][3]+=50\n                                }\n                            }\n                        }\n                        if (piece instanceof Knight) {\n                            piece.points-= ((16 - whitePawnCount - blackPawnCount) * 3)\n                            if (totalMoves <= MOVE_THRESHOLD) {\n                                if (piece.colour === Piece.WHITE) {\n                                    piece.whiteScore[7][1]-=50\n                                    piece.whiteScore[7][6]-=50\n                                } else {\n                                    piece.blackScore[0][1]-=50\n                                    piece.blackScore[0][6]-=50\n                                }\n                            }\n                        }\n                        if (piece instanceof Bishop) {\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\n                            if (totalMoves <= MOVE_THRESHOLD) {\n                                if (piece.colour === Piece.WHITE) {\n                                    piece.whiteScore[7][2]-=50\n                                    piece.whiteScore[7][5]-=50\n                                } else {\n                                    piece.blackScore[0][2]-=50\n                                    piece.blackScore[0][5]-=50\n                                }\n                            }\n                        }\n                        if (piece instanceof Rook) {\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\n                            for (const openCol of openFiles) {\n                                for (let openRow = 0; openRow<8; openRow++) {\n                                    piece.whiteScore[openRow][openCol]+= 15\n                                    piece.blackScore[openRow][openCol]+= 15\n                                }\n                            }\n                        }\n                        if (piece instanceof Pawn) {\n                            let past = true\n                            if (col + 1 < 8) {\n                                if (piece.colour === Piece.WHITE) {\n                                    for (let i = row  - 1; i >= 0; i--) {\n                                        if (this.getPiece(i, col + 1) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                } else {\n                                    for (let i = row + 1; i < 8; i++) {\n                                        if (this.getPiece(i, col + 1) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                }\n\n                            }\n                            if (col < 8) {\n                                if (piece.colour === Piece.WHITE) {\n                                    for (let i = row  - 1; i >= 0; i--) {\n                                        if (this.getPiece(i, col) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                } else {\n                                    for (let i = row + 1; i < 8; i++) {\n                                        if (this.getPiece(i, col) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                }\n\n                            }\n                            if (col - 1 >= 0) {\n                                if (piece.colour === Piece.WHITE) {\n                                    for (let i = row  - 1; i >= 0; i--) {\n                                        if (this.getPiece(i, col - 1) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                } else {\n                                    for (let i = row + 1; i < 8; i++) {\n                                        if (this.getPiece(i, col - 1) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                }\n                            }\n                            if (past) {\n                                if (piece.colour === Piece.WHITE) {\n                                    piece.points+= (20 * (6 - row))\n                                } else {\n                                    piece.points+= (20 * (row - 1))\n                                }\n\n                            }\n                            let doubled = false\n                            for (let i = 0; i < 8; i++) {\n                                if (piece instanceof Pawn && i !== row) {\n                                    doubled = true\n                                }\n                            }\n                            if (doubled) {\n                                piece.points-=10\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        isEndGame = () => {\n            // End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\n            let countWhitePieces = 0\n            let countBlackPieces = 0\n            let countWhiteQueen = 0\n            let countBlackQueen = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece instanceof Queen) {\n                        if (piece.colour === Piece.WHITE) {\n                            countWhiteQueen++\n                        } else {\n                            countBlackQueen++\n                        }\n                    }\n                    if (piece instanceof Rook || piece instanceof Bishop || piece instanceof Knight) {\n                        if (piece.colour === Piece.WHITE) {\n                            countWhitePieces++\n                        } else {\n                            countBlackPieces++\n                        }\n                    }\n                }\n            }\n            return ((countWhiteQueen <= 1 && countWhitePieces <=1) || (countBlackQueen <= 1  && countBlackPieces <=1))\n                || ((countWhitePieces <=3 && countWhiteQueen <= 0) || (countBlackPieces <=3  && countBlackQueen <= 0))\n        }\n\n        setBoardString = (boardString) => {\n            const newBoard = []\n            for (let row = 0; row < 8; row++) {\n                const newRow = []\n                for (let col = 0; col < 8; col++) {\n                    const pieceString = boardString[row][col]\n                    if (pieceString === null) {\n                        newRow.push(null)\n                    } else {\n                        const pieceColour = pieceString.slice(0, 1)\n                        const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\n                        const piece = pieceString.slice(1, 2)\n                        if (piece === \"b\") {\n                            newRow.push(new Bishop(actualColour, new Cell(row, col)))\n                        } else if (piece === 'k') {\n                            newRow.push(new King(actualColour, new Cell(row, col)))\n                        } else if (piece === 'n') {\n                            newRow.push(new Knight(actualColour, new Cell(row, col)))\n                        } else if (piece === 'p') {\n                            newRow.push(new Pawn(actualColour, new Cell(row, col)))\n                        } else if (piece === 'q') {\n                            newRow.push(new Queen(actualColour, new Cell(row, col)))\n                        } else if (piece === 'r') {\n                            newRow.push(new Rook(actualColour, new Cell(row, col)))\n                        } else {\n                            newRow.push(null)\n                        }\n                    }\n                }\n                newBoard.push(newRow)\n            }\n            this.board = newBoard\n        }\n\n        getBoardHash = () => {\n            let str = \"\"\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col)) {\n                        str += this.getPiece(row, col).getString()\n                    } else {\n                        str += \" \"\n                    }\n                }\n            }\n            return str\n        }\n\n        /**\n         * Returns the board represented by the array\n         */\n        getBoard = () => {\n            return this.board\n        }\n        /**\n         * Returns piece at the coordinates\n         */\n        getPiece = (row, col) => {\n            return this.board[row][col]\n        }\n\n        /**\n         * Returns if the cell is empty\n         */\n        isEmpty = (row, col) => {\n            if (this.isOutSide(row, col)) {\n                return false\n            }\n            return this.board[row][col] === null\n        }\n        isUnderCheck = (colour) => {\n            return false\n        }\n        isOutSide = (row, col) => {\n            return row < 0 || col < 0 || row > 7 || col > 7\n        }\n\n        canEat = (row, col, colour) => {\n            return !this.isOutSide(row, col) && !this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour\n        }\n\n\n        canMove = (row, col) => {\n            return !this.isOutSide(row, col) && this.isEmpty(row, col)\n        }\n\n        canKingMove = (row, col, colour) => {\n            const directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\n            for (const direction of directions) {\n                const newRow = row + direction[0]\n                const newCol = col + direction[1]\n                if (!this.isOutSide(newRow, newCol) && !this.isEmpty(newRow, newCol)\n                    && (this.getPiece(newRow, newCol).name === Piece.KING && this.getPiece(newRow, newCol).colour !== colour)) {\n                    return false\n                }\n            }\n            return true\n        }\n\n        movePiece = (piece, move) => {\n            move.piece.movePiece(move, this)\n            this.moves.push(move)\n        }\n\n        undoMove = () => {\n            if (this.moves.length > 0) {\n                const move = this.moves.pop()\n                const prevRow = move.oldCell.row\n                const prevCol = move.oldCell.col\n                const piece = this.board[move.newCell.row][move.newCell.col]\n                if (piece === null) {\n                    console.log(this.getBoardString(), move)\n                }\n\n                this.board[prevRow][prevCol] = piece\n                piece.cell.row = prevRow\n                piece.cell.col = prevCol\n                if (move.isEnPassant) { // add back pawn\n                    this.board[move.ate.cell.row][move.ate.cell.col] = move.ate\n                    this.board[move.newCell.row][move.newCell.col] = null\n                    return true\n                } else if (move.isPromotion) { // remove piece, add back pawn\n                    this.board[prevRow][prevCol] = new Pawn(piece.colour, piece.cell, piece.moves)\n                } else if (move.castle.isCastle) { // king will be undone, need to undo rook\n                    this.board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = move.castle.rook.piece\n                    move.castle.rook.piece.cell.row = move.castle.rook.oldCell.row\n                    move.castle.rook.piece.cell.col = move.castle.rook.oldCell.col\n                    this.board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = null\n                }\n                this.board[move.newCell.row][move.newCell.col] = move.ate\n                return true\n            }\n            return false\n        }\n\n        kingHasMoved = (colour) => {\n            for (let i = 0; i < this.moves.length; i++) {\n                const move = this.moves[i]\n                if (move.piece.name === Piece.KING && move.piece.colour === colour) {\n                    return true\n                }\n            }\n            return false\n        }\n\n        rookHasMoved = (colour, side) => {\n            const row = colour === Piece.BLACK ? 0 : 7\n            const col = side === King.KING_SIDE ? 7 : 0\n            if (!(this.getPiece(row, col) !== null && this.getPiece(row, col).name === Piece.ROOK)) { // no rook on cell\n                return true\n            }\n            for (const move of this.moves) {\n                if (move.piece.name === Piece.ROOK && move.piece.colour === colour && move.oldCell.row === row && move.oldCell.col === col) {\n                    return true\n                }\n            }\n            return false\n        }\n\n        castlingSquaresIsEmpty = (colour, side) => {\n            const row = colour === Piece.BLACK ? 0 : 7\n            const cols = side === King.KING_SIDE ? [5,6] : [1,2,3]\n            for (const col of cols) {\n                if (!this.isEmpty(row, col)) {\n                    return false\n                }\n            }\n            return true\n        }\n\n        // returns if colour is under check, need check for castling\n        isIllegal = (colour, move) => {\n            // get colour king first\n            let king;\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col)) {\n                        const piece = this.getPiece(row, col)\n                        if (piece.name === Piece.KING) {\n                            if (piece.colour === colour) {\n                                king = piece\n                            }\n                        }\n                    }\n                }\n            }\n            if (move.castle.isCastle) {\n                const moves = this.getAllMoves(colour * -1)\n                const row = move.newCell.row\n                if (move.newCell.col === 6) { // kingside\n                    for (const opp of moves) {\n                        const moveRow = opp.newCell.row\n                        const moveCol = opp.newCell.col\n                        if (moveRow === row && (moveCol === 6 || moveCol === 5 || moveCol === 4)) {\n                            return true\n                        }\n                    }\n                } else {\n                    for (const opp of moves) {\n                        const moveRow = opp.newCell.row\n                        const moveCol = opp.newCell.col\n                        if (moveRow === row && (moveCol === 1 || moveCol === 2 || moveCol === 3 || moveCol === 4)) {\n                            return true\n                        }\n                    }\n                }\n            }\n\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour) {\n                        const piece = this.getPiece(row, col)\n                        if (piece.isCheck(this, king)) {\n                            return true\n                        }\n                    }\n                }\n            }\n            return false\n        }\n        // check if colour is under check\n        isCheck = (colour) => {\n            let king;\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col)) {\n                        const piece = this.getPiece(row, col)\n                        if (piece.name === Piece.KING) {\n                            if (piece.colour === colour) {\n                                king = piece\n                            }\n                        }\n                    }\n                }\n            }\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour) {\n                        const piece = this.getPiece(row, col)\n                        if (piece.isCheck(this, king)) {\n                            return true\n                        }\n                    }\n                }\n            }\n            return false\n        }\n\n        /**\n         * Checks if game is over for colour, means other colour wins\n         * @param colour\n         * @return {*[]}\n         */\n\n        getAllMoves = (colour) => {\n            let squares = []\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour === colour) {\n                        const piece = this.getPiece(row, col)\n                        const moves = piece.getMoves(this)\n                        squares = squares.concat(moves)\n                    }\n                }\n            }\n            return squares\n        }\n        /**\n         * Goes through board for positional eval, like piece development, hardcoded for black\n         */\n        scanSquaresScore = () => {\n            let score = 0\n            let materialScore = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        // material score\n                        if (piece.colour === Piece.WHITE) {\n                            materialScore += piece.points\n                        } else {\n                            materialScore -= piece.points\n                        }\n\n                        // development / positional score\n                        if (piece.colour === Piece.WHITE) {\n                            score += piece.whiteScore[row][col]\n                        } else {\n                            score -= piece.blackScore[row][col]\n                        }\n                    }\n                }\n            }\n\n            return score + materialScore\n        }\n\n        /**\n         * used for minimax heuristics\n         * @param colour colour making the next move\n         * @param prevMoves total moves available\n         * @return {number} score of position\n         */\n        getScore = (colour, prevMoves) => {\n            const positionalScore = this.scanSquaresScore()\n            return (positionalScore + prevMoves.length * 5) * colour * -1\n        }\n\n        getBoardString = () => {\n            const newBoard = []\n            for (let row = 0; row < 8; row++) {\n                const newRow = []\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        newRow.push(piece.getString())\n                    } else {\n                        newRow.push(null)\n                    }\n                }\n                newBoard.push(newRow)\n            }\n            return newBoard\n        }\n\n    }\n    /**\n     * This class represents a coordinate on the chess board\n     */\n    class Cell {\n        constructor(row, col) {\n            this.row = row\n            this.col = col\n        }\n    }\n    class Move {\n        oldCell\n        newCell\n\n        constructor(oldCell, newCell, piece, isEnPassant = false,\n                    castle = {isCastle: false}, ate = null, isPromotion = false) {\n            this.oldCell = oldCell\n            this.newCell = newCell\n            this.piece = piece\n            this.isEnPassant = isEnPassant\n            this.castle = castle\n            this.ate = ate\n            this.isPromotion = isPromotion\n        }\n\n        getMoveString = () => {\n            return {\n                oldCellRow: this.oldCell.row,\n                oldCellCol: this.oldCell.col,\n                newCellRow: this.newCell.row,\n                newCellCol: this.newCell.col,\n                pieceString: this.piece.getString(),\n                isEnPassant: this.isEnPassant,\n                castle: this.castle.isCastle === false ? {isCastle: false} : {isCastle: true,\n                    rook:{\n                    pieceString : this.castle.rook.piece.getString(),\n                    oldCellRow: this.castle.rook.oldCell.row,\n                    oldCellCol: this.castle.rook.oldCell.col,\n                    newCellRow: this.castle.rook.newCell.row,\n                    newCellCol: this.castle.rook.newCell.col,\n                }},\n                ate: this.ate !== null ? this.ate.getString() : null,\n                isPromotion: this.isPromotion\n            }\n        }\n        static parseMove = (board, data) => {\n            const parseMove = new Move(\n                new Cell(data.oldCellRow, data.oldCellCol),\n                new Cell(data.newCellRow, data.newCellCol),\n                Piece.parsePieceString(data.pieceString),\n                data.isEnPassant,\n                {isCastle: false},\n                null,\n                data.isPromotion\n            )\n\n            if (data.castle.isCastle) {\n                const rookObj = data.castle.rook\n                parseMove.castle.isCastle = true\n                parseMove.castle.rook = new Move(new Cell(rookObj.oldCellRow, rookObj.oldCellCol)\n                    , new Cell(rookObj.newCellRow, rookObj.newCellCol), board.getPiece(rookObj.oldCellRow, rookObj.oldCellCol))\n            }\n            return parseMove\n        }\n\n    }\n    class Piece {\n        static WHITE = -1\n        static BLACK = 1\n        static ROOK = \"r\"\n        static BISHOP = \"b\"\n        static KNIGHT = \"n\"\n        static KING = \"k\"\n        static QUEEN = \"q\"\n        static PAWN = \"p\"\n        constructor(colour, cell) {\n            this.colour = colour // white or black\n            this.cell = cell\n        }\n        static parsePieceString = (pieceString) => {\n            const pieceColour = pieceString.slice(0, 1)\n            const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\n            const piece = pieceString.slice(1, 2)\n            if (piece === \"b\") {\n                return new Bishop(actualColour, new Cell(0, 0))\n            } else if (piece === 'k') {\n                return new King(actualColour, new Cell(0, 0))\n            } else if (piece === 'n') {\n                return new Knight(actualColour, new Cell(0, 0))\n            } else if (piece === 'p') {\n                return new Pawn(actualColour, new Cell(0, 0))\n            } else if (piece === 'q') {\n                return new Queen(actualColour, new Cell(0, 0))\n            } else if (piece === 'r') {\n                return new Rook(actualColour, new Cell(0, 0))\n            } else {\n                return null\n            }\n        }\n    }\n\n    class Bishop extends Piece {\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1]]\n        points = 330\n        name = Piece.BISHOP\n        whiteScore = [\n            [-20,-10,-10,-10,-10,-10,-10,-20],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-10,  0,  5, 10, 10,  5,  0,-10],\n            [-10,  5,  5, 10, 10,  5,  5,-10],\n            [-10,  0, 10, 10, 10, 10,  0,-10],\n            [-10, 10, 10, 10, 10, 10, 10,-10],\n            [-10,  5,  0,  0,  0,  0,  5,-10],\n            [-20,-10,-10,-10,-10,-10,-10,-20]\n        ]\n        blackScore = [\n            [-20,-10,-10,-10,-10,-10,-10,-20],\n            [-10,  5,  0,  0,  0,  0,  5,-10],\n            [-10, 10, 10, 10, 10, 10, 10,-10],\n            [-10,  0, 10, 10, 10, 10,  0,-10],\n            [-10,  5,  5, 10, 10,  5,  5,-10],\n            [-10,  0,  5, 10, 10,  5,  0,-10],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-20,-10,-10,-10,-10,-10,-10,-20],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                    moves.push(move)\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        // check if piece is checking the enemy king\n        isCheck = (board, king) => {\n            const row = this.cell.row\n            const col = this.cell.col\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            const rowDiff = Math.abs(row - kingRow)\n            const colDiff = Math.abs(col - kingCol)\n            if (rowDiff !== colDiff) {\n                return false\n            }\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\n                            return true\n                        }\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return false\n\n        }\n\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"b\"\n        }\n    }\n    class King extends Piece {\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\n        static KING_SIDE = -1\n        static QUEEN_SIDE = 1\n        name = Piece.KING\n        points = 10000\n\n        whiteScore = [\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-20,-30,-30,-40,-40,-30,-30,-20],\n            [-10,-20,-20,-20,-20,-20,-20,-10],\n            [20, 20,  0,  0,  0,  0, 20, 20],\n            [20, 30, 10,  0,  0, 10, 30, 20]\n        ]\n\n        blackScore = [\n            [20, 30, 10,  0,  0, 10, 30, 20],\n            [20, 20,  0,  0,  0,  0, 20, 20],\n            [-10,-20,-20,-20,-20,-20,-20,-10],\n            [-20,-30,-30,-40,-40,-30,-30,-20],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n        ]\n        whiteScoreEnd = [\n            [-50,-40,-30,-20,-20,-30,-40,-50],\n            [-30,-20,-10,  0,  0,-10,-20,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-30,  0,  0,  0,  0,-30,-30],\n            [-50,-30,-30,-30,-30,-30,-30,-50]\n        ]\n        blackScoreEnd = [\n            [-50,-30,-30,-30,-30,-30,-30,-50],\n            [-30,-30,  0,  0,  0,  0,-30,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-20,-10,  0,  0,-10,-20,-30],\n            [-50,-40,-30,-20,-20,-30,-40,-50],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                const newRow = row + currentRow\n                const newCol = col + currentCol\n                if (((board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol))) && board.canKingMove(newRow, newCol, this.colour)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                    moves.push(move)\n                }\n            }\n            // king and rook has not moved, illegal check later\n            if (whiteCanCastle && board.castlingSquaresIsEmpty(this.colour, King.KING_SIDE) && !board.rookHasMoved(this.colour, King.KING_SIDE) && !board.kingHasMoved(this.colour)) {\n                const row = this.colour === Piece.BLACK ? 0 : 7\n                const col = 6\n                moves.push(new Move(new Cell(currentRow, currentCol), new Cell(row, col), this, false,\n                    {isCastle: true, rook: new Move(new Cell(row, 7), new Cell(row, 5), board.getPiece(row, 7))}))\n            }\n            if (blackCanCastle && board.castlingSquaresIsEmpty(this.colour, King.QUEEN_SIDE) && !board.rookHasMoved(this.colour, King.QUEEN_SIDE) && !board.kingHasMoved(this.colour)) {\n                const row = this.colour === Piece.BLACK ? 0 : 7\n                const col = 2\n                moves.push(new Move(new Cell(currentRow, currentCol), new Cell(row, col), this, false,\n                    {isCastle: true, rook: new Move(new Cell(row, 0), new Cell(row, 3), board.getPiece(row, 0))}))\n            }\n\n\n            return moves\n        }\n        // check if piece is checking the enemy king\n        isCheck = (board, king) => {\n            return false\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            if (move.castle.isCastle) {\n                board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = move.castle.rook.piece\n                board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = null\n                move.castle.rook.piece.cell.row = move.castle.rook.newCell.row\n                move.castle.rook.piece.cell.col = move.castle.rook.newCell.col\n            }\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"k\"\n        }\n    }\n    class Knight extends Piece {\n        directions = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n\n        points = 320\n        name = Piece.KNIGHT\n\n        whiteScore = [\n            [-50,-40,-30,-30,-30,-30,-40,-50],\n            [-40,-20,  0,  0,  0,  0,-20,-40],\n            [-30,  0, 10, 15, 15, 10,  0,-30],\n            [-30,  5, 15, 20, 20, 15,  5,-30],\n            [-30,  0, 15, 20, 20, 15,  0,-30],\n            [-30,  5, 10, 15, 15, 10,  5,-30],\n            [-40,-20,  0,  5,  5,  0,-20,-40],\n            [-50,-40,-30,-30,-30,-30,-40,-50]\n        ]\n\n        blackScore = [\n            [-50,-40,-30,-30,-30,-30,-40,-50],\n            [-40,-20,  0,  5,  5,  0,-20,-40],\n            [-30,  5, 10, 15, 15, 10,  5,-30],\n            [-30,  0, 15, 20, 20, 15,  0,-30],\n            [-30,  5, 15, 20, 20, 15,  5,-30],\n            [-30,  0, 10, 15, 15, 10,  0,-30],\n            [-40,-20,  0,  0,  0,  0,-20,-40],\n            [-50,-40,-30,-30,-30,-30,-40,-50],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const newRow = row + currentRow\n                const newCol = col + currentCol\n                if (board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                    moves.push(move)\n                }\n            }\n            return moves\n        }\n        // check if piece is checking the enemy king\n        isCheck = (board, king) => {\n            const row = this.cell.row\n            const col = this.cell.col\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            const rowDiff = Math.abs(row - kingRow)\n            const colDiff = Math.abs(col - kingCol)\n            if (rowDiff + colDiff !== 3) {\n                return false\n            }\n            return !(rowDiff === 0 || colDiff === 0);\n\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"n\"\n        }\n    }\n    class Pawn extends Piece {\n        points = 100\n        name = Piece.PAWN\n\n        whiteScore = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5, -5,-10,  0,  0,-10, -5,  5],\n            [5, 10, 10,-20,-20, 10, 10,  5],\n            [0,  0,  0,  0,  0,  0,  0,  0]\n        ]\n        whiteScoreEnd = [\n            [100,  100,  100,  100,  100,  100,  100,  100],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5, -5,-10,  0,  0,-10, -5,  5],\n            [5, 10, 10,-20,-20, 10, 10,  5],\n            [0,  0,  0,  0,  0,  0,  0,  0]\n        ]\n        blackScore = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [5, 10, 10,-40,-40, 10, 10,  5],\n            [5, 10,20,  0,  0,-10, -5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [0,  0,  0,  0,  0,  0,  0,  0],\n        ]\n        blackScoreEnd = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [5, 10, 10,-40,-40, 10, 10,  5],\n            [5, 10,20,  0,  0,-10, -5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [100,  100,  100,  100,  100,  100,  100,  100],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            const moves = []\n            let newRow = this.cell.row + 1 * this.colour\n            let newCol = this.cell.col\n            if (board.canMove(newRow, newCol)) {\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol),\n                    this, undefined, undefined, undefined,\n                    newRow === 0 || newRow === 7)\n                    moves.push(move)\n\n                newRow = this.cell.row + 2 * this.colour\n                if (board.canMove(newRow, newCol) && (newRow === 3 || newRow === 4)) {\n                    if (this.colour === Piece.BLACK && this.cell.row === 1) {\n                        const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n\n                            moves.push(move)\n\n                    } else if (this.colour === Piece.WHITE && this.cell.row === 6) {\n                        const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                            moves.push(move)\n                    }\n\n                }\n            }\n            newRow = this.cell.row + 1 * this.colour\n            newCol = this.cell.col + 1\n            if (board.canEat(newRow, newCol, this.colour)) {\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\n                    newRow === 0 || newRow === 7)\n                    moves.push(move)\n            }\n            // en passant\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\n                const prevMove = board.moves.slice(-1)[0]\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col + 1\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this, true)\n                        moves.push(move)\n                }\n\n            }\n            newRow = this.cell.row + 1 * this.colour\n            newCol = this.cell.col - 1\n            if (board.canEat(newRow, newCol, this.colour)) {\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\n                    newRow === 0 || newRow === 7)\n                    moves.push(move)\n            }\n            // en passant\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\n                const prevMove = board.moves.slice(-1)[0]\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col - 1\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this, true)\n                    moves.push(move)\n                }\n\n            }\n            return moves\n        }\n        isCheck = (board, king) => {\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            const newRow = this.cell.row + 1 * this.colour\n            const newCol = this.cell.col + 1\n            const newColOpp = this.cell.col - 1\n            return newRow === kingRow && (newCol === kingCol || newColOpp === kingCol)\n        }\n\n        /**\n         * Moves the piece\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            // const old = board[move.oldCell.row][move.oldCell.col]\n            // promotion\n            if (move.isEnPassant) {\n                const prevMove = boardObject.moves.slice(-1)[0]\n                const oldPiece = board[prevMove.newCell.row][prevMove.newCell.col]\n                if (oldPiece !== null) {\n                    move.ate = oldPiece\n                }\n                board[prevMove.newCell.row][prevMove.newCell.col] = null\n            }\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n            if (move.isPromotion) {\n                board[newRow][newCol] = new Queen(this.colour, this.cell)\n            }\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"p\"\n        }\n    }\n    class Queen extends Piece {\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1], [0,1], [1,0], [0,-1],[-1,0]]\n        points = 900\n        name = Piece.QUEEN\n\n        whiteScore = [\n            [-20,-10,-10, -5, -5,-10,-10,-20],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-10,  0,  5,  5,  5,  5,  0,-10],\n            [-5,  0,  5,  5,  5,  5,  0, -5],\n            [0,  0,  5,  5,  5,  5,  0, -5],\n            [-10,  5,  5,  5,  5,  5,  0,-10],\n            [-10,  0,  5,  0,  0,  0,  0,-10],\n            [-20,-10,-10, -5, -5,-10,-10,-20]\n        ]\n        blackScore = [\n            [-20,-10,-10, -5, -5,-10,-10,-20],\n            [-10,  0,  5,  0,  0,  0,  0,-10],\n            [-10,  5,  5,  5,  5,  5,  0,-10],\n            [0,  0,  5,  5,  5,  5,  0, -5],\n            [-5,  0,  5,  5,  5,  5,  0, -5],\n            [-10,  0,  5,  5,  5,  5,  0,-10],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-20,-10,-10, -5, -5,-10,-10,-20],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                        moves.push(move)\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        isCheck = (board, king) => {\n            const row = this.cell.row\n            const col = this.cell.col\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            const rowDiff = Math.abs(row - kingRow)\n            const colDiff = Math.abs(col - kingCol)\n            if ((rowDiff !== colDiff) && kingCol !== col && kingRow !== row) {\n                return false\n            }\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\n                            return true\n                        }\n                        break;\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return false\n\n        }\n\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"q\"\n        }\n    }\n    class Rook extends Piece {\n        directions = [[0,1], [1,0], [0,-1],[-1,0]]\n        points = 500\n        name = Piece.ROOK\n        whiteScore = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [5, 10, 10, 10, 10, 10, 10,  5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [0,  0,  0,  5,  5,  0,  0,  0]\n        ]\n        blackScore = [\n            [0,  0,  4,  5,  5,  10,  0,  0],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [5, 10, 10, 10, 10, 10, 10,  5],\n            [0,  0,  0,  0,  0,  0,  0,  0],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                        moves.push(move)\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        isCheck = (board, king) => {\n            const row = this.cell.row\n            const col = this.cell.col\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            if (kingCol !== col && kingRow !== row) {\n                return false\n            }\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\n                            return true\n                        }\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return false\n\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"r\"\n        }\n    }\n\n        // try {\n            const data = message.data\n            const boardString = data[0]\n            const depth = data[1]\n            const moveString = data[2]\n            const colour = data[3]\n            const pv = data[4]\n            totalMoves = moveString.length\n            if (totalMoves === 0) {\n                if (colour === Piece.WHITE) {\n                    // equal chance to play d4, e4\n                    const moves = [\n                        new Move(new Cell(6, 3), new Cell(4,3), new Pawn(Piece.WHITE, new Cell(6, 3))),\n                        new Move(new Cell(6, 4), new Cell(4,4), new Pawn(Piece.WHITE, new Cell(6, 4))),\n                    ]\n                    const randomIndex = Math.round(Math.random() * (moves.length - 1))\n\n                    postMessage(moves[randomIndex].getMoveString())\n                }\n            } else if (totalMoves === 1) {\n                // equal chance to play c5 / e5, in response to e4\n                const getMove = moveString.map(x => Move.parseMove(undefined, x))[0]\n                if (getMove.oldCell.row === 6 && getMove.oldCell.col === 4 && getMove.newCell.row === 4 && getMove.newCell.col === 4) {\n                    const moves = [\n                        new Move(new Cell(1, 2), new Cell(3,2), new Pawn(Piece.BLACK, new Cell(1, 2))),\n                        new Move(new Cell(1, 4), new Cell(3,4), new Pawn(Piece.BLACK, new Cell(1, 4))),\n                    ]\n                    const randomIndex = Math.round(Math.random() * (moves.length - 1))\n\n                    postMessage(moves[randomIndex].getMoveString())\n                } else {\n                    const nextMove = ab(boardString, depth, moveString, colour, pv)\n                    postMessage(nextMove)\n                }\n            } else {\n                const nextMove = ab(boardString, depth, moveString, colour, pv)\n                postMessage(nextMove)\n            }\n        // } catch (e) {\n        //     postMessage({isError: true, message:\"Error: \" + e})\n        // }\n\n}\n// eslint-disable-next-line no-restricted-globals,no-undef\nself.addEventListener(\"message\", test);\n"],"names":["totalMoves","self","addEventListener","async","message","mem","Map","whiteCanCastle","blackCanCastle","pv_length","Array","from","length","x","pv_table","startTime","currentPv","CHECK_THRESHOLD","nodes","branch","ab","boardString","depth","moveString","colour","pv","copyBoard","Board","setBoardString","moves","map","Move","parseMove","i","prev","isEndGame","console","log","setEndGame","updatePieceValues","set","result","performance","now","miniMax","Number","MAX_VALUE","newCell","end","arr","push","getMoveString","board","alpha","beta","maxPlayer","currentPlayer","ply","getAllMoves","bestMove","moveOrderRoot","maxEval","legal","move","movePiece","piece","isIllegal","undoMove","undefined","currentEval","miniMaxCore","next_ply","Math","max","isCheck","minEval","min","prevMoves","isLeftMost","branchLocal","slice","ate","quiesce","getScore","moveOrder","get","find","e","isEqualMove","j","MAX_KILLER","sort","a","b","pvMove","points","Piece","WHITE","whiteScore","row","col","blackScore","memSlot","slot","killerMove","oldCell","constructor","sortMoves","evaluation","score","this","newBoard","Rook","BLACK","Cell","Knight","Bishop","Queen","King","Pawn","getPiece","whiteScoreEnd","blackScoreEnd","kingHasMoved","rookHasMoved","KING_SIDE","QUEEN_SIDE","whitePawnCount","blackPawnCount","openFiles","hasPawn","openCol","openRow","past","doubled","countWhitePieces","countBlackPieces","countWhiteQueen","countBlackQueen","newRow","pieceString","actualColour","getBoardHash","str","isEmpty","getString","getBoard","isOutSide","isUnderCheck","canEat","canMove","canKingMove","directions","direction","newCol","name","KING","pop","prevRow","prevCol","getBoardString","cell","isEnPassant","isPromotion","castle","isCastle","rook","side","ROOK","castlingSquaresIsEmpty","cols","king","opp","moveRow","moveCol","squares","getMoves","concat","scanSquaresScore","materialScore","oldCellRow","oldCellCol","newCellRow","newCellCol","static","data","parsePieceString","rookObj","BISHOP","super","currentRow","currentCol","kingRow","kingCol","abs","boardObject","oldPiece","KNIGHT","rowDiff","colDiff","PAWN","prevMove","newColOpp","QUEEN","randomIndex","round","random","postMessage","getMove","nextMove"],"sourceRoot":""}