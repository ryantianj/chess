self.addEventListener("message",(async e=>{let l=0;const o=(e,l)=>e.getScore(l),t=e=>e===r.BLACK?r.WHITE:r.BLACK,s=(e,n,c,i,r,h,w)=>{if(l+=1,0===n)return[null,o(e,h)];if(e.isGameOver(w).isGameOver&&w===h)return[null,-Number.MAX_VALUE];if(e.isGameOver(w).isGameOver&&w!==h)return[null,Number.MAX_VALUE];const a=e.getAllMoves(w),u=Math.floor(Math.random()*(a.length-1));let C=a.length>0?a[u]:null;if(r){let l=-Number.MAX_VALUE;for(const o of a){e.movePiece(o.piece,o);const r=s(e,n-1,c,i,!1,h,t(w))[1];if(e.undoMove(),r>l&&(l=r,C=o),i<=(c=Math.max(c,r)))break}return[C,l]}{let l=Number.MAX_VALUE;for(const o of a){e.movePiece(o.piece,o);const r=s(e,n-1,c,i,!0,h,t(w))[1];if(e.undoMove(),r<l&&(l=r,C=o),(i=Math.max(i,r))<=c)break}return[C,l]}};class n{board;constructor(){this.board=this.newBoard(),this.moves=[]}newBoard=()=>[[new f(r.BLACK,new c(0,0)),new a(r.BLACK,new c(0,1)),new h(r.BLACK,new c(0,2)),new C(r.BLACK,new c(0,3)),new w(r.BLACK,new c(0,4)),new h(r.BLACK,new c(0,5)),new a(r.BLACK,new c(0,6)),new f(r.BLACK,new c(0,7))],[new u(r.BLACK,new c(1,0)),new u(r.BLACK,new c(1,1)),new u(r.BLACK,new c(1,2)),new u(r.BLACK,new c(1,3)),new u(r.BLACK,new c(1,4)),new u(r.BLACK,new c(1,5)),new u(r.BLACK,new c(1,6)),new u(r.BLACK,new c(1,7))],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[new u(r.WHITE,new c(6,0)),new u(r.WHITE,new c(6,1)),new u(r.WHITE,new c(6,2)),new u(r.WHITE,new c(6,3)),new u(r.WHITE,new c(6,4)),new u(r.WHITE,new c(6,5)),new u(r.WHITE,new c(6,6)),new u(r.WHITE,new c(6,7))],[new f(r.WHITE,new c(7,0)),new a(r.WHITE,new c(7,1)),new h(r.WHITE,new c(7,2)),new C(r.WHITE,new c(7,3)),new w(r.WHITE,new c(7,4)),new h(r.WHITE,new c(7,5)),new a(r.WHITE,new c(7,6)),new f(r.WHITE,new c(7,7))]];setBoardString=e=>{const l=[];for(let o=0;o<8;o++){const t=[];for(let l=0;l<8;l++){const s=e[o][l];if(null===s)t.push(null);else{const e="w"===s.slice(0,1)?r.WHITE:r.BLACK,n=s.slice(1,2);"b"===n?t.push(new h(e,new c(o,l))):"k"===n?t.push(new w(e,new c(o,l))):"n"===n?t.push(new a(e,new c(o,l))):"p"===n?t.push(new u(e,new c(o,l))):"q"===n?t.push(new C(e,new c(o,l))):"r"===n?t.push(new f(e,new c(o,l))):t.push(null)}}l.push(t)}this.board=l};clonePiece=e=>e instanceof u?new u(e.colour,new c(e.cell.row,e.cell.col)):e instanceof h?new h(e.colour,new c(e.cell.row,e.cell.col)):e instanceof w?new w(e.colour,new c(e.cell.row,e.cell.col)):e instanceof a?new a(e.colour,new c(e.cell.row,e.cell.col)):e instanceof C?new C(e.colour,new c(e.cell.row,e.cell.col)):e instanceof f?new f(e.colour,new c(e.cell.row,e.cell.col)):null;getBoard=()=>this.board;getPiece=(e,l)=>this.board[e][l];isEmpty=(e,l)=>!this.isOutSide(e,l)&&null===this.board[e][l];isUnderCheck=e=>!1;isOutSide=(e,l)=>e<0||l<0||e>7||l>7;canEat=(e,l,o)=>!this.isOutSide(e,l)&&!this.isEmpty(e,l)&&this.getPiece(e,l).colour!==o;canEatDefend=(e,l)=>!this.isOutSide(e,l)&&!this.isEmpty(e,l);canMove=(e,l)=>!this.isOutSide(e,l)&&this.isEmpty(e,l);canKingMove=(e,l,o)=>{const t=[[1,1],[-1,-1],[1,-1],[-1,1],[0,1],[1,0],[0,-1],[-1,0]];for(const s of t){const t=e+s[0],n=l+s[1];if(!this.isOutSide(t,n)&&!this.isEmpty(t,n)&&this.getPiece(t,n)instanceof w&&this.getPiece(t,n).colour!==o)return!1}return!0};getAttackingSquares=e=>{const l=[];for(let o=0;o<8;o++)for(let t=0;t<8;t++)if(!this.isEmpty(o,t)){const s=this.getPiece(o,t);if(s.colour!==e&&!(s instanceof w)){const e=s.getAttack(this);l.push.apply(l,e)}}return[l,[]]};movePiece=(e,l)=>{const o=this.board[l.oldCell.row][l.oldCell.col].movePiece(l,this);return this.moves.push(l),o};undoMove=()=>{if(this.moves.length>0){const e=this.moves.pop(),l=e.oldCell.row,o=e.oldCell.col,t=this.board[e.newCell.row][e.newCell.col];return this.board[l][o]=t,t.moves.pop(),t.cell.row=l,t.cell.col=o,e.isEnPassant?(this.board[e.ate.cell.row][e.ate.cell.col]=e.ate,this.board[e.newCell.row][e.newCell.col]=null,!0):(e.isPromotion?this.board[l][o]=new u(t.colour,t.cell,t.moves):e.castle.isCastle&&(this.board[e.castle.rook.oldCell.row][e.castle.rook.oldCell.col]=e.castle.rook.piece,e.castle.rook.piece.cell.row=e.castle.rook.oldCell.row,e.castle.rook.piece.cell.col=e.castle.rook.oldCell.col,this.board[e.castle.rook.newCell.row][e.castle.rook.newCell.col]=null),this.board[e.newCell.row][e.newCell.col]=e.ate,!0)}return!1};kingHasMoved=e=>{for(const l of this.moves)if(l.piece instanceof w&&l.piece.colour===e)return!0;return!1};rookHasMoved=(e,l)=>{const o=e===r.BLACK?0:7,t=l===w.KING_SIDE?7:0;if(!(this.getPiece(o,t)instanceof f))return!0;for(const s of this.moves)if(s.piece instanceof f&&s.piece.colour===e&&s.oldCell.row===o&&s.oldCell.col===t)return!0;return!1};castlingSquaresIsEmpty=(e,l)=>{const o=e===r.BLACK?0:7,t=l===w.KING_SIDE?[5,6]:[1,2,3];for(const s of t)if(!this.isEmpty(o,s))return!1;return!0};castlingSquaresUnderAttack=(e,l,o)=>{const t=e===r.BLACK?0:7,s=l===w.KING_SIDE?[4,5,6]:[1,2,3,4];for(const n of s)for(const e of o)if(e.newCell.row===t&&e.newCell.col===n)return!0;return!1};canCastle=(e,l,o)=>this.castlingSquaresIsEmpty(e,l)&&!this.castlingSquaresUnderAttack(e,l,o)&&!this.rookHasMoved(e,l)&&!this.kingHasMoved(e);promotePiece=e=>{const l=e.cell.row,o=e.cell.col;this.board[l][o]=e};isCheck=(e,l=null)=>{const o=null===l?this.getAttackingSquares(e)[0]:l;for(const t of o){const l=this.getPiece(t.newCell.row,t.newCell.col);if(l instanceof w&&l.colour===e)return!0}return!1};willCheck=(e,l)=>(this.movePiece(e,l),this.isCheck(e.colour)?(this.undoMove(),!0):(this.undoMove(),!1));getAllMoves=e=>{let l=[];for(let o=0;o<8;o++)for(let t=0;t<8;t++)null!==this.board[o][t]&&this.getPiece(o,t).colour===e&&(l=l.concat(this.getPiece(o,t).getMoves(this)));return l};isRepeatPosition=e=>{const l=e;if(this.moves.length>=l){const e=this.moves.slice(-l);let o=e[0],t=e[1];for(let s=2;s<l;s+=4){const l=e[s],n=e[s+1];if(l.newCell.row!==o.oldCell.row||l.newCell.col!==o.oldCell.col||o.piece!==l.piece)return!1;if(n.newCell.row!==t.oldCell.row||n.newCell.col!==t.oldCell.col||t.piece!==n.piece)return!1}return!0}return!1};isGameOver=e=>{const l=this.getAllMoves(e),o=this.isCheck(e),t=e===r.BLACK?"White":"Black";return o&&l.length<=0?{isGameOver:!0,message:t+" wins by checkmate"}:!o&&l.length<=0?{isGameOver:!1,message:"Draw by stalemate"}:this.isRepeatPosition(8)?{isGameOver:!1,message:"Draw by threefold repetition"}:{isGameOver:!1,message:""}};getAllMoves=e=>{let l=[];for(let o=0;o<8;o++)for(let t=0;t<8;t++)if(!this.isEmpty(o,t)&&this.getPiece(o,t).colour===e){const e=this.getPiece(o,t).getMoves(this);l=l.concat(e)}return l};scanSquaresScore=(e,l,o)=>{let t=0;for(let s=0;s<8;s++)for(let o=0;o<8;o++){const n=this.getPiece(s,o);null!==n&&(n instanceof u&&1!==s?t+=3:n instanceof a&&0!==s&&(1!==o||6!==o)?t+=10:n instanceof f&&0!==s&&(0!==o||7!==o)?t+=5:n instanceof h&&0!==s&&(2!==o||5!==o)&&(t+=10),n instanceof w&&4!==o&&(t+=20),n instanceof u&&n.colour===e?this.getPiece(s+1,o)instanceof u&&n.colour===e&&(t-=20):n instanceof u&&n.colour!==e&&this.getPiece(s-1,o)instanceof u&&n.colour!==e&&(t+=20),n instanceof w&&n.colour===e&&this.isCheck(e,l)&&(t-=10))}return t};getScore=e=>{let l=0;const o=e===r.WHITE?r.BLACK:r.WHITE;for(let n=0;n<8;n++)for(let o=0;o<8;o++){const t=this.board[n][o];t instanceof r&&t.colour===e&&(l+=t.points),t instanceof r&&t.colour!==e&&(l-=t.points)}const t=this.getAttackingSquares(o),s=t[0].length;return t[1].length,500*l+s+this.scanSquaresScore(e,t[0],t[1])};getBoardString=()=>{const e=[];for(let l=0;l<8;l++){const o=[];for(let e=0;e<8;e++){const t=this.getPiece(l,e);null!==t?o.push(t.getString()):o.push(null)}e.push(o)}return e}}class c{constructor(e,l){this.row=e,this.col=l}}class i{oldCell;newCell;constructor(e,l,o,t=!1,s={isCastle:!1},n=null,c=!1){this.oldCell=e,this.newCell=l,this.piece=o,this.isEnPassant=t,this.castle=s,this.ate=n,this.isPromotion=c}getMoveString=()=>({oldCellRow:this.oldCell.row,oldCellCol:this.oldCell.col,newCellRow:this.newCell.row,newCellCol:this.newCell.col,pieceString:this.piece.getString(),isEnPassant:this.isEnPassant,castle:!1===this.castle.isCastle?{isCastle:!1}:{isCastle:!0,rook:{pieceString:this.castle.rook.piece.getString(),oldCellRow:this.castle.rook.oldCell.row,oldCellCol:this.castle.rook.oldCell.col,newCellRow:this.castle.rook.newCell.row,newCellCol:this.castle.rook.newCell.col}},ate:null!==this.ate?this.ate.getString():null,isPromotion:this.isPromotion})}class r{static WHITE=-1;static BLACK=1;isAlive=!0;constructor(e,l,o=[]){this.colour=e,this.cell=l,this.moves=o}}class h extends r{directions=[[1,1],[-1,-1],[1,-1],[-1,1]];points=3;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],r=o[1];let h=n+t,w=r+s;for(;e.canMove(h,w)||e.canEat(h,w,this.colour);){const o=new i(this.cell,new c(h,w),this);if(e.willCheck(this,o)||l.push(o),e.canEat(h,w,this.colour))break;h+=n,w+=r}}return l};getAttack=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],r=o[1];let h=n+t,w=r+s;for(;(e.canMove(h,w)||e.canEatDefend(h,w))&&(l.push(new i(this.cell,new c(h,w),this)),!e.canEatDefend(h,w));)h+=n,w+=r}return l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col,n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new c(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===r.WHITE?"w":"b")+"b"}class w extends r{directions=[[1,1],[-1,-1],[1,-1],[-1,1],[0,1],[1,0],[0,-1],[-1,0]];static KING_SIDE="king";static QUEEN_SIDE="queen";points=9999;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[],o=e.getAttackingSquares(this.colour)[0];for(const s of this.directions){const o=s[0],t=s[1],n=o+this.cell.row,r=t+this.cell.col;if((e.canEat(n,r,this.colour)||e.canMove(n,r))&&e.canKingMove(n,r,this.colour)){const o=new i(this.cell,new c(n,r),this);e.willCheck(this,o)||l.push(o)}}const t=l.filter((e=>{for(const l of o)if(e.newCell.row===l.newCell.row&&e.newCell.col===l.newCell.col)return!1;return!0}));if(e.canCastle(this.colour,w.KING_SIDE,o)){const l=this.colour===r.BLACK?0:7,o=6;t.push(new i(this.cell,new c(l,o),this,!1,{isCastle:!0,rook:new i(new c(l,7),new c(l,5),e.getPiece(l,7))}))}if(e.canCastle(this.colour,w.QUEEN_SIDE,o)){const l=this.colour===r.BLACK?0:7,o=2;t.push(new i(this.cell,new c(l,o),this,!1,{isCastle:!0,rook:new i(new c(l,0),new c(l,3),e.getPiece(l,0))}))}return t};getAttack=e=>this.getMoves(e);movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col;e.castle.isCastle&&(o[e.castle.rook.newCell.row][e.castle.rook.newCell.col]=e.castle.rook.piece,o[e.castle.rook.oldCell.row][e.castle.rook.oldCell.col]=null,e.castle.rook.piece.cell.row=e.castle.rook.newCell.row,e.castle.rook.piece.cell.col=e.castle.rook.newCell.col);const n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new c(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===r.WHITE?"w":"b")+"k"}class a extends r{directions=[[1,2],[1,-2],[2,1],[2,-1],[-1,2],[-1,-2],[-2,1],[-2,-1]];points=3;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];for(const o of this.directions){const t=o[0],s=o[1],n=t+this.cell.row,r=s+this.cell.col;if(e.canEat(n,r,this.colour)||e.canMove(n,r)){const o=new i(this.cell,new c(n,r),this);e.willCheck(this,o)||l.push(o)}}return l};getAttack=e=>{const l=[];for(const o of this.directions){const t=o[0],s=o[1],n=t+this.cell.row,r=s+this.cell.col;(e.canEatDefend(n,r)||e.canMove(n,r))&&l.push(new i(this.cell,new c(n,r),this))}return l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col,n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new c(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===r.WHITE?"w":"b")+"n"}class u extends r{points=1;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];let o=this.cell.row+1*this.colour,t=this.cell.col;if(e.canMove(o,t)){const s=new i(this.cell,new c(o,t),this,void 0,void 0,void 0,0===o||7===o);if(e.willCheck(this,s)||l.push(s),o=this.cell.row+2*this.colour,e.canMove(o,t)&&this.moves.length<=0)if(this.colour===r.BLACK&&1===this.cell.row){const s=new i(this.cell,new c(o,t),this);e.willCheck(this,s)||l.push(s)}else if(this.colour===r.WHITE&&6===this.cell.row){const s=new i(this.cell,new c(o,t),this);e.willCheck(this,s)||l.push(s)}}if(o=this.cell.row+1*this.colour,t=this.cell.col+1,e.canEat(o,t,this.colour)){const s=new i(this.cell,new c(o,t),this,void 0,void 0,void 0,0===o||7===o);e.willCheck(this,s)||l.push(s)}if(e.canMove(o,t)&&e.moves.length>0){const s=e.moves.slice(-1)[0];if(s.piece instanceof u&&s.newCell.row===this.cell.row&&s.newCell.col===this.cell.col+1&&2===Math.abs(s.newCell.row-s.oldCell.row)){const s=new i(this.cell,new c(o,t),this,!0);e.willCheck(this,s)||l.push(s)}}if(o=this.cell.row+1*this.colour,t=this.cell.col-1,e.canEat(o,t,this.colour)){const s=new i(this.cell,new c(o,t),this,void 0,void 0,void 0,0===o||7===o);e.willCheck(this,s)||l.push(s)}if(e.canMove(o,t)&&e.moves.length>0){const s=e.moves.slice(-1)[0];if(s.piece instanceof u&&s.newCell.row===this.cell.row&&s.newCell.col===this.cell.col-1&&2===Math.abs(s.newCell.row-s.oldCell.row)){const s=new i(this.cell,new c(o,t),this,!0);e.willCheck(this,s)||l.push(s)}}return l};getAttack=e=>{const l=[];let o=this.cell.row+1*this.colour,t=this.cell.col+1;return(e.canMove(o,t)||e.canEatDefend(o,t))&&l.push(new i(this.cell,new c(o,t),this)),o=this.cell.row+1*this.colour,t=this.cell.col-1,(e.canMove(o,t)||e.canEatDefend(o,t))&&l.push(new i(this.cell,new c(o,t),this)),l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col;if(e.isEnPassant){const t=l.moves.slice(-1)[0],s=o[t.newCell.row][t.newCell.col];null!==s&&(e.ate=s),o[t.newCell.row][t.newCell.col]=null}const n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new c(t,s),e.isPromotion?(o[t][s]=new C(this.colour,this.cell),{promotion:!0,row:t,col:s}):(this.moves.push(e),{row:t,col:s})};getString=()=>(this.colour===r.WHITE?"w":"b")+"p"}class C extends r{directions=[[1,1],[-1,-1],[1,-1],[-1,1],[0,1],[1,0],[0,-1],[-1,0]];points=9;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],r=o[1];let h=n+t,w=r+s;for(;e.canMove(h,w)||e.canEat(h,w,this.colour);){const o=new i(this.cell,new c(h,w),this);if(e.willCheck(this,o)||l.push(o),e.canEat(h,w,this.colour))break;h+=n,w+=r}}return l};getAttack=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],r=o[1];let h=n+t,w=r+s;for(;(e.canMove(h,w)||e.canEatDefend(h,w))&&(l.push(new i(this.cell,new c(h,w),this)),!e.canEatDefend(h,w));)h+=n,w+=r}return l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col,n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new c(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===r.WHITE?"w":"b")+"q"}class f extends r{directions=[[0,1],[1,0],[0,-1],[-1,0]];points=5;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],r=o[1];let h=n+t,w=r+s;for(;e.canMove(h,w)||e.canEat(h,w,this.colour);){const o=new i(this.cell,new c(h,w),this);if(e.willCheck(this,o)||l.push(o),e.canEat(h,w,this.colour))break;h+=n,w+=r}}return l};getAttack=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],r=o[1];let h=n+t,w=r+s;for(;e.canMove(h,w)||e.canEatDefend(h,w);){const o=new i(this.cell,new c(h,w),this);if(l.push(o),e.canEatDefend(h,w))break;h+=n,w+=r}}return l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col,n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new c(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===r.WHITE?"w":"b")+"r"}const d=e.data,g=((e,o)=>{l=0;const t=new n;t.setBoardString(e);const c=performance.now(),i=s(t,o,-Number.MAX_VALUE,Number.MAX_VALUE,!0,r.BLACK,r.BLACK),h=performance.now();return console.log(l,h-c),i[0]})(d[0],d[1]);postMessage(g.getMoveString())}));
//# sourceMappingURL=worker.worker.3d7fed56.worker.js.map