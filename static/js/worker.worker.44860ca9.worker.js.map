{"version":3,"file":"static/js/worker.worker.44860ca9.worker.js","mappings":"YAAA,IAAIA,EAAa,EAg+DjBC,KAAKC,iBAAiB,WAz9DTC,MAAOC,IAiBhB,MAAMC,EAAM,IAAIC,IAEhB,IAAIC,GAAyB,EACzBC,GAA0B,EAC1BC,GAAyB,EACzBC,GAA0B,EAC9B,MAAMC,EAAYC,MAAMC,KAAK,CAACC,OALZ,KAKiCC,GAAM,IACnDC,EAAWJ,MAAMC,KAAK,CAACC,OANX,KAMgCC,GAAMH,MAAMC,KAAK,CAACC,OANlD,KAMuEC,GAAM,MAC/F,IACIE,EADAC,EAAY,GAEhB,MAAMC,EAAW,IACXC,EAAkB,IACxB,IAAIC,EAAQ,EACRC,EAAS,EAGb,IAAIC,GAAY,EAUhB,MAAMC,EAAM,CAACC,EAAaC,EAAOC,EAAYC,EAAQC,KACjD,IAAIC,EACJ,MAAMC,EAAY,IAAIC,EACtBD,EAAUE,eAAeR,GACzBM,EAAUG,MAAQP,EAAWQ,KAAIpB,GAAKqB,EAAKC,UAAUN,EAAWhB,KAEhE,IAAK,IAAIuB,EAAI,EAAGA,EAAIT,EAAGf,OAAQwB,IAC3BtB,EAAS,GAAGsB,EAAI,GAAKF,EAAKC,UAAUN,EAAWF,EAAGS,IAEtD,MAAMC,EAAOvB,EAAS,GACtBE,EAAY,IAAIqB,GAChBhB,EAAYQ,EAAUR,YAClBA,IACAiB,QAAQC,IAAI,WACZV,EAAUW,cAEdX,EAAUY,kBAAkB3C,GAC5B,IAAK,IAAIsC,EAAI,EAAGA,EAAIZ,EAAOY,IACvBjC,EAAIuC,IAAIN,EAAG,CAAC,KAAM,KAAM,OAG5B,IAAIO,EADJ5B,EAAY6B,YAAYC,MAExB,IAAK,IAAIT,EAAI,EAAGA,GAAKZ,EAAOY,IAAK,CAC7BO,EAASG,EAAQjB,EAAWO,GAAIW,OAAOC,UAAWD,OAAOC,UAAWtB,EAAQA,EAAQvB,EAAK,GAEzF,GADmByC,YAAYC,MACd9B,EAAYE,EAAU,CACnC,MAAMoB,EAAOvB,EAAS,GACtBE,EAAY,IAAIqB,EACpB,CACAT,EAAWZ,EAAU,GACrBsB,QAAQC,IAAIH,EAAG,QAASO,EAAO,GAAI3B,EAAU,GAAGiC,QACpD,CAEA,MAAMC,EAAMN,YAAYC,MAElBM,EAAM,GACZ,IAAK,IAAIf,EAAI,EAAGA,EAAIZ,GACK,IAAjBR,EAAUoB,GADSA,IAIvBe,EAAIC,KAAKpC,EAAUoB,GAAGiB,iBACtBf,QAAQC,IAAIvB,EAAUoB,GAAGiB,gBAAiBrC,EAAUoB,GAAGiB,gBAAgBC,KAM3E,OAJAhB,QAAQC,IAAIW,EAAMnC,EAAWI,EAAOC,GAI7B,CAACQ,EAASyB,gBAAiBF,EAAG,EAenCL,EAAU,CAACS,EAAO/B,EAAOgC,EAAOC,EAAMC,EAAWC,EAAexD,EAAKyD,KAEvE,GADAnD,EAAUmD,GAAOA,EACbzC,EAAQD,IAAoB,GACxB0B,YAAYC,MAAQ9B,EAAYE,EAChC,MAAO,CAAC,KAAM,GAGtB,MAAMe,EAAQuB,EAAMM,YAAYF,GAEhC,IAAI/B,EACJ,GAFAkC,EAAc9B,EAAOR,EAAOoC,GAExBD,IAAkBD,EAAW,CAC7B,IAAIK,GAAW,IACXC,EAAQ,EACZ,IAAK,IAAI5B,EAAI,EAAGA,EAAIJ,EAAMpB,OAAQwB,IAAK,CACnC,MAAM6B,EAAOjC,EAAMI,GAEnB,GADAmB,EAAMW,UAAUD,EAAKE,MAAOF,GACxBV,EAAMa,UAAUT,EAAeM,GAAO,CACtCV,EAAMc,WAEN,QACJ,CACAL,SACiBM,IAAb1C,IACAA,EAAWqC,GAEf,MAAMM,EAAcC,EAAYjB,EAAO/B,EAAQ,EAAGgC,EAAOC,EAAMC,GAA4B,EAAjBC,EAAoB3B,EAAO7B,EAAKyD,EAAM,EAAa,IAAVI,GAEnH,GADAT,EAAMc,WACFE,EAAcR,EAAS,CACvBA,EAAUQ,EACV3C,EAAWqC,EACXnD,EAAS8C,GAAKA,GAAOK,EACrB,IAAK,IAAIQ,EAAWb,EAAM,EAAGa,EAAWhE,EAAUmD,EAAM,GAAIa,IAExD3D,EAAS8C,GAAKa,GAAY3D,EAAS8C,EAAM,GAAGa,GAGhDhE,EAAUmD,GAAOnD,EAAUmD,EAAM,EACrC,CAEA,GAAIH,IADJD,EAAQkB,KAAKC,IAAInB,EAAOe,IAEpB,KAER,CACA,OAAc,IAAVP,EACIT,EAAMqB,QAAQjB,GACP,CAAC,MAAO,KAEZ,CAAC,KAAM,GAEX,CAAC/B,EAAUmC,EACtB,GAEJ,IAAIc,GAAa,EAEjB,MAAML,EAAc,CAACjB,EAAO/B,EAAOgC,EAAOC,EAAMC,EAAWC,EAAemB,EAAW3E,EAAKyD,EAAKmB,KAC3F,GAAI5D,EAAQD,IAAoB,GACxB0B,YAAYC,MAAQ9B,EAAYE,EAChC,OAAOsC,EAAMyB,SAAStB,EAAWoB,GAGzC,IAAIG,EAAc,EAIlB,GAHA9D,IAEAV,EAAUmD,GAAOA,EACbpC,GAAS,EAAG,CACZ,IAAImB,EAMJ,OAFIA,EAHAe,IAAcC,GAAkBkB,GAA+C,OAAjCtB,EAAMvB,MAAMkD,OAAO,GAAG,GAAG5B,IAG9DC,EAAMyB,SAAStB,EAAWoB,GAF1BK,EAAQ3B,EAAOC,EAAMF,EAAOI,EAAe,EAAGmB,GAIpDnC,CACX,CACA,GAAInB,GAAS,IAAoBH,IAAcwD,IAAetB,EAAMqB,QAAQjB,GAAgB,CACxFkB,GAAa,EACb,MAAMO,EAAeZ,EAAYjB,EAAO/B,EAAQ,EArJpC,EAqJqDiC,EAAO,EAAGA,EAAMC,GAA4B,EAAjBC,EAAoBmB,EAAW3E,EAAKyD,EAAM,EArJ1H,GAqJ2I,GAEvJ,GADAiB,GAAa,EACTO,GAAe3B,EACf,OAAOA,CAEf,CACA,MAAMzB,EAAQuB,EAAMM,YAAYF,GAEhC,GADA0B,EAAUrD,EAAO7B,EAAKqB,EAAOoC,EAAKmB,GAC9BpB,IAAkBD,EAAW,CAC7B,IAAIK,GAAW,IACXC,EAAQ,EACZ,IAAK,IAAI5B,EAAI,EAAGA,EAAIJ,EAAMpB,OAAQwB,IAAK,CACnC,MAAM6B,EAAOjC,EAAMI,GAEnB,GADAmB,EAAMW,UAAUD,EAAKE,MAAOF,GACxBV,EAAMa,UAAUT,EAAeM,GAAO,CACtCV,EAAMc,WACN,QACJ,CACAL,IACAiB,IACA,MAAMV,EAAcC,EAAYjB,EAAO/B,EAAQ,EAAGgC,EAAOC,EAAMC,GAA4B,EAAjBC,EAAoB3B,EAAO7B,EAAKyD,EAAM,EAAa,IAAVI,GAEnH,GADAT,EAAMc,WACFE,EAAcR,EAAS,CACvBA,EAAUQ,EACVzD,EAAS8C,GAAKA,GAAOK,EACrB,IAAK,IAAIQ,EAAWb,EAAM,EAAGa,EAAWhE,EAAUmD,EAAM,GAAIa,IAExD3D,EAAS8C,GAAKa,GAAY3D,EAAS8C,EAAM,GAAGa,GAGhDhE,EAAUmD,GAAOnD,EAAUmD,EAAM,EACrC,CAIA,GAHIW,EAAcf,IACdA,EAAQe,GAERd,GAAQD,EAAO,CACf,GAAiB,OAAbS,EAAKX,IACL,MAEJ,MAAMH,EAAMhD,EAAImF,IAAI9D,GACpB,GAAI2B,EAAIoC,MAAKC,GAAU,OAALA,GAAaC,EAAYD,EAAGvB,KAC1C,MAEJ,IAAK,IAAIyB,EAAIC,EAAgBD,GAAK,EAAGA,IACjCvC,EAAIuC,EAAI,GAAKvC,EAAIuC,GAErBvC,EAAI,GAAKc,EACT,KACJ,CACJ,CAEA,OADA7C,GAAUA,EAAS6D,GAAe,EACpB,IAAVjB,EACIT,EAAMqB,QAAQjB,IACN,IAAQnC,EAEb,EAEJuC,CACX,CAAO,CACH,IAAI6B,EAAU,IACV5B,EAAQ,EACZ,IAAK,IAAI5B,EAAI,EAAGA,EAAIJ,EAAMpB,OAAQwB,IAAK,CACnC,MAAM6B,EAAOjC,EAAMI,GAEnB,GADAmB,EAAMW,UAAUD,EAAKE,MAAOF,GACxBV,EAAMa,UAAUT,EAAeM,GAAO,CACtCV,EAAMc,WACN,QACJ,CACAL,IACAiB,IACA,MAAMV,EAAcC,EAAYjB,EAAO/B,EAAQ,EAAGgC,EAAOC,EAAMC,GAA4B,EAAjBC,EAAoBmB,EAAW3E,EAAKyD,EAAK,EAAa,IAAVI,GAEtH,GADAT,EAAMc,WACFE,EAAcqB,EAAS,CACvBA,EAAUrB,EACVzD,EAAS8C,GAAKA,GAAOK,EACrB,IAAK,IAAIQ,EAAWb,EAAM,EAAGa,EAAWhE,EAAUmD,EAAM,GAAIa,IAExD3D,EAAS8C,GAAKa,GAAY3D,EAAS8C,EAAM,GAAGa,GAGhDhE,EAAUmD,GAAOnD,EAAUmD,EAAM,EACrC,CAKA,GAHIW,EAAcd,IACdA,EAAOc,GAEPd,GAAQD,EAAO,CACf,GAAiB,OAAbS,EAAKX,IACL,MAEJ,MAAMH,EAAMhD,EAAImF,IAAI9D,GACpB,GAAI2B,EAAIoC,MAAKC,GAAU,OAALA,GAAaC,EAAYD,EAAGvB,KAC1C,MAEJ,IAAK,IAAIyB,EAAIC,EAAgBD,GAAK,EAAGA,IACjCvC,EAAIuC,EAAI,GAAKvC,EAAIuC,GAErBvC,EAAI,GAAKc,EACT,KACJ,CACJ,CAEA,OADA7C,GAAUA,EAAS6D,GAAe,EACpB,IAAVjB,EACIT,EAAMqB,QAAQjB,GACP,IAAQnC,EAEZ,EAGJoE,CACX,GAUE9B,EAAgB,CAAC9B,EAAOR,EAAOoC,KA8BjC5B,EAAM6D,MA7Ba,CAACC,EAAGC,KACnB,MAAMC,EAAShF,EAAU4C,GACzB,GAAe,IAAXoC,GAAgBP,EAAYK,EAAGE,GAC/B,OAAQ,EACL,GAAe,IAAXA,GAAgBP,EAAYM,EAAGC,GACtC,OAAO,EAEX,GAAIF,EAAEG,OAAOC,SACT,OAAQ,EAEZ,GAAIH,EAAEE,OAAOC,SACT,OAAO,EAEX,GAAc,OAAVJ,EAAExC,KAA0B,OAAVyC,EAAEzC,IAAc,CAGlC,OAFewC,EAAE3B,MAAMgC,OAASL,EAAExC,IAAI6C,OACvBJ,EAAE5B,MAAMgC,OAASJ,EAAEzC,IAAI6C,QACZ,EAAG,CACjC,CACI,GAAc,OAAVL,EAAExC,IACF,OAAQ,EACL,GAAc,OAAVyC,EAAEzC,IACT,OAAO,EAIX,OAFewC,EAAE3B,MAAMzC,SAAW0E,EAAMC,MAAQP,EAAE3B,MAAMmC,WAAWR,EAAE7C,QAAQsD,KAAKT,EAAE7C,QAAQuD,KAAOV,EAAE3B,MAAMsC,WAAWX,EAAE7C,QAAQsD,KAAKT,EAAE7C,QAAQuD,OAChIT,EAAE5B,MAAMzC,SAAW0E,EAAMC,MAAQN,EAAE5B,MAAMmC,WAAWP,EAAE9C,QAAQsD,KAAKR,EAAE9C,QAAQuD,KAAOT,EAAE5B,MAAMsC,WAAWV,EAAE9C,QAAQsD,KAAKR,EAAE9C,QAAQuD,MACtH,GAAI,CAEjC,GAEiB,EAYnBnB,EAAY,CAACrD,EAAO7B,EAAKqB,EAAOoC,EAAKmB,KA4CvC/C,EAAM6D,MA1Ca,CAACC,EAAGC,KACnB,MAAMC,EAAShF,EAAU4C,GACzB,GAAImB,GAAyB,IAAXiB,EAAc,CAC5B,GAAIP,EAAYK,EAAGE,GACf,OAAQ,EACL,GAAIP,EAAYM,EAAGC,GACtB,OAAO,CAEf,CACA,GAAIF,EAAEG,OAAOC,SACT,OAAQ,EAEZ,GAAIH,EAAEE,OAAOC,SACT,OAAO,EAEX,GAAc,OAAVJ,EAAExC,KAA0B,OAAVyC,EAAEzC,IAAc,CAGlC,OAFewC,EAAE3B,MAAMgC,OAASL,EAAExC,IAAI6C,OACvBJ,EAAE5B,MAAMgC,OAASJ,EAAEzC,IAAI6C,QACZ,EAAG,CACjC,CAAO,CACH,GAAc,OAAVL,EAAExC,IACF,OAAQ,EACL,GAAc,OAAVyC,EAAEzC,IACT,OAAO,EAEX,MAAMoD,EAAUvG,EAAImF,IAAI9D,GACxB,IAAK,IAAImF,EAAO,EAAGA,EAAOD,EAAQ9F,OAAQ+F,IAAQ,CAC9C,MAAMC,EAAaF,EAAQC,GAC3B,GAAmB,OAAfC,GAAuBnB,EAAYK,EAAGc,GACtC,OAAQ,EAEZ,GAAmB,OAAfA,GAAuBnB,EAAYM,EAAGa,GACtC,OAAO,CAEf,CAIA,OAFed,EAAE3B,MAAMzC,SAAW0E,EAAMC,MAAQP,EAAE3B,MAAMmC,WAAWR,EAAE7C,QAAQsD,KAAKT,EAAE7C,QAAQuD,KAAOV,EAAE3B,MAAMsC,WAAWX,EAAE7C,QAAQsD,KAAKT,EAAE7C,QAAQuD,OAChIT,EAAE5B,MAAMzC,SAAW0E,EAAMC,MAAQN,EAAE5B,MAAMmC,WAAWP,EAAE9C,QAAQsD,KAAKR,EAAE9C,QAAQuD,KAAOT,EAAE5B,MAAMsC,WAAWV,EAAE9C,QAAQsD,KAAKR,EAAE9C,QAAQuD,MACtH,GAAI,CAEjC,IAEiB,EASnBf,EAAc,CAACK,EAAGC,IAChBD,EAAE7C,QAAQsD,MAAQR,EAAE9C,QAAQsD,KAAOT,EAAE7C,QAAQuD,MAAQT,EAAE9C,QAAQuD,KAAOV,EAAEe,QAAQN,MAAQR,EAAEc,QAAQN,KAAOT,EAAEe,QAAQL,MAAQT,EAAEc,QAAQL,KAAOV,EAAE3B,MAAM2C,cAAgBf,EAAE5B,MAAM2C,cAC9J,OAAVhB,EAAExC,KAA0B,OAAVyC,EAAEzC,IACbwC,EAAExC,IAAIwD,cAAgBf,EAAEzC,IAAIwD,YAEhChB,EAAExC,MAAQyC,EAAEzC,KAWrByD,EAAY,CAACjB,EAAGC,KAClB,GAAc,OAAVD,EAAExC,KAA0B,OAAVyC,EAAEzC,IAAc,CAGlC,OAFewC,EAAE3B,MAAMgC,OAASL,EAAExC,IAAI6C,OACvBJ,EAAE5B,MAAMgC,OAASJ,EAAEzC,IAAI6C,QACZ,EAAG,CACjC,CACI,GAAc,OAAVL,EAAExC,IACF,OAAQ,EACL,GAAc,OAAVyC,EAAEzC,IACT,OAAO,EAIP,OAFewC,EAAE3B,MAAMzC,SAAW0E,EAAMC,MAAQP,EAAE3B,MAAMmC,WAAWR,EAAE7C,QAAQsD,KAAKT,EAAE7C,QAAQuD,KAAOV,EAAE3B,MAAMsC,WAAWX,EAAE7C,QAAQsD,KAAKT,EAAE7C,QAAQuD,OAChIT,EAAE5B,MAAMzC,SAAW0E,EAAMC,MAAQN,EAAE5B,MAAMmC,WAAWP,EAAE9C,QAAQsD,KAAKR,EAAE9C,QAAQuD,KAAOT,EAAE5B,MAAMsC,WAAWV,EAAE9C,QAAQsD,KAAKR,EAAE9C,QAAQuD,MACtH,GAAI,CAErC,EAaErB,EAAU,CAAC3B,EAAOC,EAAMF,EAAO7B,EAAQF,EAAOsD,KAChD,MAAMkC,EAAazD,EAAMyB,SAAStD,EAAQoD,GAC1C,GAAc,IAAVtD,EACA,OAAOwF,EAEX,GAAIA,GAAcvD,EACd,OAAOA,EAGXD,EAAQkB,KAAKC,IAAInB,EAAOwD,GACxB,MAAMhF,EAAQuB,EAAMM,YAAYnC,GAChCM,EAAM6D,KAAKkB,GACX,IAAK,IAAI3E,EAAI,EAAGA,EAAIJ,EAAMpB,OAAQwB,IAAK,CACnC,MAAM6B,EAAOjC,EAAMI,GACnB,GAAiB,OAAb6B,EAAKX,IAWL,MAXmB,CACnBC,EAAMW,UAAUD,EAAKE,MAAOF,GAC5B,IAAIgD,GAAS9B,GAAS1B,GAAOD,EAAOD,GAAiB,EAAV7B,EAAaF,EAAQ,EAAGsD,GAEnE,GADAvB,EAAMc,WACF4C,GAASxD,EACT,OAAOA,EAEPwD,EAAQzD,IACRA,EAAQyD,EAEhB,CAGJ,CACA,OAAOzD,GAoFX,MAAM1B,EACFyB,MAEAuD,cACII,KAAK3D,MAAQ2D,KAAKC,WAClBD,KAAKlF,MAAQ,EACjB,CAMAmF,SAAW,IACe,CAClB,CAAC,IAAIC,EAAKhB,EAAMiB,MAAO,IAAIC,EAAK,EAAE,IAAK,IAAIC,EAAOnB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIE,EAAOpB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIG,EAAMrB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAII,EAAKtB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIE,EAAOpB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIC,EAAOnB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIF,EAAKhB,EAAMiB,MAAO,IAAIC,EAAK,EAAE,KAC3T,CAAC,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,KACpT,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC3C,CAAC,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,KACpT,CAAC,IAAIF,EAAKhB,EAAMC,MAAO,IAAIiB,EAAK,EAAE,IAAK,IAAIC,EAAOnB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIE,EAAOpB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIG,EAAMrB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAII,EAAKtB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIE,EAAOpB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIC,EAAOnB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,IAAK,IAAIF,EAAKhB,EAAMC,MAAO,IAAIiB,EAAK,EAAE,MAKnU9E,WAAa,KACT,IAAK,IAAI+D,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMrC,EAAQ+C,KAAKU,SAASrB,EAAKC,GACnB,OAAVrC,QAA0CG,IAAxBH,EAAM0D,gBACpB1D,EAAMzC,SAAW0E,EAAMC,MACvBlC,EAAMmC,WAAanC,EAAM0D,cAEzB1D,EAAMsC,WAAatC,EAAM2D,cAGrC,CACJ,EAGJrF,kBAAqB3C,IAEboH,KAAKa,aAAa3B,EAAMC,SACxBhG,GAAyB,EACzBC,GAA0B,GAE1B4G,KAAKc,aAAa5B,EAAMC,MAAOqB,EAAKO,aACpC5H,GAAyB,GAEzB6G,KAAKc,aAAa5B,EAAMC,MAAOqB,EAAKQ,cACpC5H,GAA0B,GAE1B4G,KAAKa,aAAa3B,EAAMiB,SACxB9G,GAAyB,EACzBC,GAA0B,GAE1B0G,KAAKc,aAAa5B,EAAMiB,MAAOK,EAAKO,aACpC1H,GAAyB,GAEzB2G,KAAKc,aAAa5B,EAAMiB,MAAOK,EAAKQ,cACpC1H,GAA0B,GAQ9B,IAAI2H,EAAiB,EACjBC,EAAiB,EACrB,IAAK,IAAI7B,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMrC,EAAQ+C,KAAKU,SAASrB,EAAKC,GACnB,OAAVrC,GACIA,aAAiBwD,IACbxD,EAAMzC,SAAW0E,EAAMC,MACvB8B,IAEAC,IAIhB,CAEJ,MAAMC,EAAY,GAClB,IAAK,IAAI7B,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,IAAI8B,GAAU,EACd,IAAK,IAAI/B,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMpC,EAAQ+C,KAAKU,SAASrB,EAAKC,GACjC,GAAc,OAAVrC,GACIA,aAAiBwD,EAAM,CACvBW,GAAU,EACV,KACJ,CAER,CACKA,GACDD,EAAUjF,KAAKoD,EAEvB,CAGA,IAAK,IAAID,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMrC,EAAQ+C,KAAKU,SAASrB,EAAKC,GACjC,GAAc,OAAVrC,EAAgB,CAkChB,GAjCIA,aAAiBsD,GACb3H,GA7CG,KA8CCqE,EAAMzC,SAAW0E,EAAMC,MACvBlC,EAAMmC,WAAW,GAAG,IAAI,GAExBnC,EAAMsC,WAAW,GAAG,IAAI,IAIhCtC,aAAiBoD,IACjBpD,EAAMgC,QAAmD,GAAxC,GAAKgC,EAAiBC,GACnCtI,GAvDG,KAwDCqE,EAAMzC,SAAW0E,EAAMC,OACvBlC,EAAMmC,WAAW,GAAG,IAAI,GACxBnC,EAAMmC,WAAW,GAAG,IAAI,KAExBnC,EAAMsC,WAAW,GAAG,IAAI,GACxBtC,EAAMsC,WAAW,GAAG,IAAI,MAIhCtC,aAAiBqD,IACjBrD,EAAMgC,QAAmD,GAAxC,GAAKgC,EAAiBC,GACnCtI,GAnEG,KAoECqE,EAAMzC,SAAW0E,EAAMC,OACvBlC,EAAMmC,WAAW,GAAG,IAAI,GACxBnC,EAAMmC,WAAW,GAAG,IAAI,KAExBnC,EAAMsC,WAAW,GAAG,IAAI,GACxBtC,EAAMsC,WAAW,GAAG,IAAI,MAIhCtC,aAAiBiD,EAAM,CACvBjD,EAAMgC,QAAmD,GAAxC,GAAKgC,EAAiBC,GACvC,IAAK,MAAMG,KAAWF,EAClB,IAAK,IAAIG,EAAU,EAAGA,EAAQ,EAAGA,IAC7BrE,EAAMmC,WAAWkC,GAASD,IAAW,GACrCpE,EAAMsC,WAAW+B,GAASD,IAAW,EAGjD,CACA,GAAIpE,aAAiBwD,EAAM,CACvB,IAAIc,GAAO,EACX,GAAIjC,EAAM,EAAI,EACV,GAAIrC,EAAMzC,SAAW0E,EAAMC,MACvB,IAAK,IAAIjE,EAAImE,EAAO,EAAGnE,GAAK,EAAGA,IACvB8E,KAAKU,SAASxF,EAAGoE,EAAM,aAAcmB,IACrCc,GAAO,QAIf,IAAK,IAAIrG,EAAImE,EAAM,EAAGnE,EAAI,EAAGA,IACrB8E,KAAKU,SAASxF,EAAGoE,EAAM,aAAcmB,IACrCc,GAAO,GAMvB,GAAIjC,EAAM,EACN,GAAIrC,EAAMzC,SAAW0E,EAAMC,MACvB,IAAK,IAAIjE,EAAImE,EAAO,EAAGnE,GAAK,EAAGA,IACvB8E,KAAKU,SAASxF,EAAGoE,aAAgBmB,IACjCc,GAAO,QAIf,IAAK,IAAIrG,EAAImE,EAAM,EAAGnE,EAAI,EAAGA,IACrB8E,KAAKU,SAASxF,EAAGoE,aAAgBmB,IACjCc,GAAO,GAMvB,GAAIjC,EAAM,GAAK,EACX,GAAIrC,EAAMzC,SAAW0E,EAAMC,MACvB,IAAK,IAAIjE,EAAImE,EAAO,EAAGnE,GAAK,EAAGA,IACvB8E,KAAKU,SAASxF,EAAGoE,EAAM,aAAcmB,IACrCc,GAAO,QAIf,IAAK,IAAIrG,EAAImE,EAAM,EAAGnE,EAAI,EAAGA,IACrB8E,KAAKU,SAASxF,EAAGoE,EAAM,aAAcmB,IACrCc,GAAO,GAKnBA,IACItE,EAAMzC,SAAW0E,EAAMC,MACvBlC,EAAMgC,QAAU,IAAM,EAAII,GAE1BpC,EAAMgC,QAAU,IAAMI,EAAM,IAIpC,IAAImC,GAAU,EACd,IAAK,IAAItG,EAAI,EAAGA,EAAI,EAAGA,IACf+B,aAAiBwD,GAAQvF,IAAMmE,IAC/BmC,GAAU,GAGdA,IACAvE,EAAMgC,QAAQ,GAEtB,CACJ,CACJ,CACJ,EAIJ9E,UAAY,KACR,IAAIsH,EAAmB,EACnBC,EAAmB,EACnBC,EAAkB,EAClBC,EAAkB,EACtB,IAAK,IAAIvC,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMrC,EAAQ+C,KAAKU,SAASrB,EAAKC,GAC7BrC,aAAiBsD,IACbtD,EAAMzC,SAAW0E,EAAMC,MACvBwC,IAEAC,MAGJ3E,aAAiBiD,GAAQjD,aAAiBqD,GAAUrD,aAAiBoD,KACjEpD,EAAMzC,SAAW0E,EAAMC,MACvBsC,IAEAC,IAGZ,CAEJ,OAASC,GAAmB,GAAKF,GAAmB,GAAOG,GAAmB,GAAMF,GAAmB,GAC9FD,GAAmB,GAAKE,GAAmB,GAAOD,GAAmB,GAAME,GAAmB,CAAE,EAO7G/G,eAAkBR,IACd,MAAM4F,EAAW,GACjB,IAAK,IAAIZ,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMwC,EAAS,GACf,IAAK,IAAIvC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMwC,EAAczH,EAAYgF,GAAKC,GACrC,GAAoB,OAAhBwC,EACAD,EAAO3F,KAAK,UACT,CACH,MACM6F,EAA+B,MADjBD,EAAY9D,MAAM,EAAG,GACEkB,EAAMC,MAAQD,EAAMiB,MACzDlD,EAAQ6E,EAAY9D,MAAM,EAAG,GACrB,MAAVf,EACA4E,EAAO3F,KAAK,IAAIoE,EAAOyB,EAAc,IAAI3B,EAAKf,EAAKC,KAClC,MAAVrC,EACP4E,EAAO3F,KAAK,IAAIsE,EAAKuB,EAAc,IAAI3B,EAAKf,EAAKC,KAChC,MAAVrC,EACP4E,EAAO3F,KAAK,IAAImE,EAAO0B,EAAc,IAAI3B,EAAKf,EAAKC,KAClC,MAAVrC,EACP4E,EAAO3F,KAAK,IAAIuE,EAAKsB,EAAc,IAAI3B,EAAKf,EAAKC,KAChC,MAAVrC,EACP4E,EAAO3F,KAAK,IAAIqE,EAAMwB,EAAc,IAAI3B,EAAKf,EAAKC,KACjC,MAAVrC,EACP4E,EAAO3F,KAAK,IAAIgE,EAAK6B,EAAc,IAAI3B,EAAKf,EAAKC,KAEjDuC,EAAO3F,KAAK,KAEpB,CACJ,CACA+D,EAAS/D,KAAK2F,EAClB,CACA7B,KAAK3D,MAAQ4D,GAoBjB+B,SAAW,IACAhC,KAAK3D,MAMhBqE,SAAW,CAACrB,EAAKC,IACNU,KAAK3D,MAAMgD,GAAKC,GAM3B2C,QAAU,CAAC5C,EAAKC,KACRU,KAAKkC,UAAU7C,EAAKC,IAGQ,OAAzBU,KAAK3D,MAAMgD,GAAKC,GAM3B4C,UAAY,CAAC7C,EAAKC,IACPD,EAAM,GAAKC,EAAM,GAAKD,EAAM,GAAKC,EAAM,EAMlD6C,OAAS,CAAC9C,EAAKC,EAAK9E,KACRwF,KAAKkC,UAAU7C,EAAKC,KAASU,KAAKiC,QAAQ5C,EAAKC,IAAQU,KAAKU,SAASrB,EAAKC,GAAK9E,SAAWA,EAMtG4H,QAAU,CAAC/C,EAAKC,KACJU,KAAKkC,UAAU7C,EAAKC,IAAQU,KAAKiC,QAAQ5C,EAAKC,GAM1D+C,YAAc,CAAChD,EAAKC,EAAK9E,KACrB,MAAM8H,EAAa,CAAC,CAAC,EAAE,GAAI,EAAE,GAAG,GAAI,CAAC,GAAG,GAAG,EAAE,EAAE,GAAG,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,GAAG,GAAG,EAAE,EAAE,IAC3E,IAAK,MAAMC,KAAaD,EAAY,CAChC,MAAMT,EAASxC,EAAMkD,EAAU,GACzBC,EAASlD,EAAMiD,EAAU,GAC/B,IAAKvC,KAAKkC,UAAUL,EAAQW,KAAYxC,KAAKiC,QAAQJ,EAAQW,IACrDxC,KAAKU,SAASmB,EAAQW,GAAQC,OAASvD,EAAMwD,MAAQ1C,KAAKU,SAASmB,EAAQW,GAAQhI,SAAWA,EAClG,OAAO,CAEf,CACA,OAAO,GAMXwC,UAAY,CAACC,EAAOF,KAChBA,EAAKE,MAAMD,UAAUD,EAAMiD,MAC3BA,KAAKlF,MAAMoB,KAAKa,EAAI,EAOxBI,SAAW,KACP,GAAI6C,KAAKlF,MAAMpB,OAAS,EAAG,CACvB,MAAMqD,EAAOiD,KAAKlF,MAAM6H,MAClBC,EAAU7F,EAAK4C,QAAQN,IACvBwD,EAAU9F,EAAK4C,QAAQL,IACvBrC,EAAQ+C,KAAK3D,MAAMU,EAAKhB,QAAQsD,KAAKtC,EAAKhB,QAAQuD,KAIxD,OAHAU,KAAK3D,MAAMuG,GAASC,GAAW5F,EAC/BA,EAAM6F,KAAKzD,IAAMuD,EACjB3F,EAAM6F,KAAKxD,IAAMuD,EACb9F,EAAKgG,aACL/C,KAAK3D,MAAMU,EAAKX,IAAI0G,KAAKzD,KAAKtC,EAAKX,IAAI0G,KAAKxD,KAAOvC,EAAKX,IACxD4D,KAAK3D,MAAMU,EAAKhB,QAAQsD,KAAKtC,EAAKhB,QAAQuD,KAAO,MAC1C,IACAvC,EAAKiG,YACZhD,KAAK3D,MAAMuG,GAASC,GAAW,IAAIpC,EAAKxD,EAAMzC,OAAQyC,EAAM6F,KAAM7F,EAAMnC,OACjEiC,EAAKgC,OAAOC,WACnBgB,KAAK3D,MAAMU,EAAKgC,OAAOkE,KAAKtD,QAAQN,KAAKtC,EAAKgC,OAAOkE,KAAKtD,QAAQL,KAAOvC,EAAKgC,OAAOkE,KAAKhG,MAC1FF,EAAKgC,OAAOkE,KAAKhG,MAAM6F,KAAKzD,IAAMtC,EAAKgC,OAAOkE,KAAKtD,QAAQN,IAC3DtC,EAAKgC,OAAOkE,KAAKhG,MAAM6F,KAAKxD,IAAMvC,EAAKgC,OAAOkE,KAAKtD,QAAQL,IAC3DU,KAAK3D,MAAMU,EAAKgC,OAAOkE,KAAKlH,QAAQsD,KAAKtC,EAAKgC,OAAOkE,KAAKlH,QAAQuD,KAAO,MAE7EU,KAAK3D,MAAMU,EAAKhB,QAAQsD,KAAKtC,EAAKhB,QAAQuD,KAAOvC,EAAKX,KAC/C,EACX,CACA,OAAO,GAMXyE,aAAgBrG,IACZ,IAAK,IAAIU,EAAI,EAAGA,EAAI8E,KAAKlF,MAAMpB,OAAQwB,IAAK,CACxC,MAAM6B,EAAOiD,KAAKlF,MAAMI,GACxB,GAAI6B,EAAKE,MAAMwF,OAASvD,EAAMwD,MAAQ3F,EAAKE,MAAMzC,SAAWA,EACxD,OAAO,CAEf,CACA,OAAO,GAMXsG,aAAe,CAACtG,EAAQ0I,KACpB,MAAM7D,EAAM7E,IAAW0E,EAAMiB,MAAQ,EAAI,EACnCb,EAAM4D,IAAS1C,EAAKO,UAAY,EAAI,EAC1C,GAAkC,OAA5Bf,KAAKU,SAASrB,EAAKC,IAAiBU,KAAKU,SAASrB,EAAKC,GAAKmD,OAASvD,EAAMiE,KAC7E,OAAO,EAEX,IAAK,MAAMpG,KAAQiD,KAAKlF,MACpB,GAAIiC,EAAKE,MAAMwF,OAASvD,EAAMiE,MAAQpG,EAAKE,MAAMzC,SAAWA,GAAUuC,EAAK4C,QAAQN,MAAQA,GAAOtC,EAAK4C,QAAQL,MAAQA,EACnH,OAAO,EAGf,OAAO,GAMX8D,uBAAyB,CAAC5I,EAAQ0I,KAC9B,MAAM7D,EAAM7E,IAAW0E,EAAMiB,MAAQ,EAAI,EACnCkD,EAAOH,IAAS1C,EAAKO,UAAY,CAAC,EAAE,GAAK,CAAC,EAAE,EAAE,GACpD,IAAK,MAAMzB,KAAO+D,EACd,IAAKrD,KAAKiC,QAAQ5C,EAAKC,GACnB,OAAO,EAGf,OAAO,GAMXpC,UAAY,CAAC1C,EAAQuC,KAEjB,IAAIuG,EACAC,EAAY,EAChB,IAAK,IAAIlE,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAKU,KAAKiC,QAAQ5C,EAAKC,GAAM,CACzB,MAAMrC,EAAQ+C,KAAKU,SAASrB,EAAKC,GAC7BrC,EAAMwF,OAASvD,EAAMwD,OACrBa,IACItG,EAAMzC,SAAWA,IACjB8I,EAAOrG,GAGnB,CAGR,GAAIsG,EAAY,EACZ,OAAO,EAEX,GAAIxG,EAAKgC,OAAOC,SAAU,CACtB,MAAMlE,EAAQkF,KAAKrD,aAAsB,EAAVnC,GACzB6E,EAAMtC,EAAKhB,QAAQsD,IACzB,GAAyB,IAArBtC,EAAKhB,QAAQuD,IACb,IAAK,MAAMkE,KAAO1I,EAAO,CACrB,MAAM2I,EAAUD,EAAIzH,QAAQsD,IACtBqE,EAAUF,EAAIzH,QAAQuD,IAC5B,GAAImE,IAAYpE,IAAoB,IAAZqE,GAA6B,IAAZA,GAA6B,IAAZA,GACtD,OAAO,CAEf,MAEA,IAAK,MAAMF,KAAO1I,EAAO,CACrB,MAAM2I,EAAUD,EAAIzH,QAAQsD,IACtBqE,EAAUF,EAAIzH,QAAQuD,IAC5B,GAAImE,IAAYpE,IAAoB,IAAZqE,GAA6B,IAAZA,GAA6B,IAAZA,GACtD,OAAO,CAEf,CAER,CAEA,IAAK,IAAIrE,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAKU,KAAKiC,QAAQ5C,EAAKC,IAAQU,KAAKU,SAASrB,EAAKC,GAAK9E,SAAWA,EAAQ,CAEtE,GADcwF,KAAKU,SAASrB,EAAKC,GACvB5B,QAAQsC,KAAMsD,GACpB,OAAO,CAEf,CAGR,OAAO,GAGX5F,QAAWlD,IACP,IAAI8I,EACJ,IAAK,IAAIjE,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAKU,KAAKiC,QAAQ5C,EAAKC,GAAM,CACzB,MAAMrC,EAAQ+C,KAAKU,SAASrB,EAAKC,GAC7BrC,EAAMwF,OAASvD,EAAMwD,MACjBzF,EAAMzC,SAAWA,IACjB8I,EAAOrG,EAGnB,CAGR,IAAK,IAAIoC,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAKU,KAAKiC,QAAQ5C,EAAKC,IAAQU,KAAKU,SAASrB,EAAKC,GAAK9E,SAAWA,EAAQ,CAEtE,GADcwF,KAAKU,SAASrB,EAAKC,GACvB5B,QAAQsC,KAAMsD,GACpB,OAAO,CAEf,CAGR,OAAO,GAMX3G,YAAenC,IACX,IAAImJ,EAAU,GACd,IAAK,IAAItE,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAKU,KAAKiC,QAAQ5C,EAAKC,IAAQU,KAAKU,SAASrB,EAAKC,GAAK9E,SAAWA,EAAQ,CACtE,MACMM,EADQkF,KAAKU,SAASrB,EAAKC,GACbsE,SAAS5D,MAC7B2D,EAAUA,EAAQE,OAAO/I,EAC7B,CAGR,OAAO6I,GAKXG,iBAAmB,KACf,IAAI/D,EAAQ,EACRgE,EAAgB,EACpB,IAAK,IAAI1E,EAAM,EAAGA,EAAM,EAAGA,IACvB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMrC,EAAQ+C,KAAKU,SAASrB,EAAKC,GACnB,OAAVrC,IAEIA,EAAMzC,SAAW0E,EAAMC,MACvB4E,GAAiB9G,EAAMgC,OAEvB8E,GAAiB9G,EAAMgC,OAIvBhC,EAAMzC,SAAW0E,EAAMC,MACvBY,GAAS9C,EAAMmC,WAAWC,GAAKC,GAE/BS,GAAS9C,EAAMsC,WAAWF,GAAKC,GAG3C,CAGJ,OAAOS,EAAQgE,GASnBjG,SAAW,CAACtD,EAAQoD,KACQoC,KAAK8D,mBACgB,EAAnBlG,EAAUlE,QAAcc,GAAU,EAMhEwJ,eAAiB,KACb,MAAM/D,EAAW,GACjB,IAAK,IAAIZ,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMwC,EAAS,GACf,IAAK,IAAIvC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAMrC,EAAQ+C,KAAKU,SAASrB,EAAKC,GACnB,OAAVrC,EACA4E,EAAO3F,KAAKe,EAAMgH,aAElBpC,EAAO3F,KAAK,KAEpB,CACA+D,EAAS/D,KAAK2F,EAClB,CACA,OAAO5B,GAOf,MAAMG,EACFR,YAAYP,EAAKC,GACbU,KAAKX,IAAMA,EACXW,KAAKV,IAAMA,CACf,EAMJ,MAAMtE,EACF2E,QACA5D,QAEA6D,YAAYD,EAAS5D,EAASkB,EAAO8F,GAAc,EACvChE,EAAS,CAACC,UAAU,GAAQ5C,EAAM,KAAM4G,GAAc,GAC9DhD,KAAKL,QAAUA,EACfK,KAAKjE,QAAUA,EACfiE,KAAK/C,MAAQA,EACb+C,KAAK+C,YAAcA,EACnB/C,KAAKjB,OAASA,EACdiB,KAAK5D,IAAMA,EACX4D,KAAKgD,YAAcA,CACvB,CAKA7G,cAAgB,KACL,CACH+H,WAAYlE,KAAKL,QAAQN,IACzB8E,WAAYnE,KAAKL,QAAQL,IACzB8E,WAAYpE,KAAKjE,QAAQsD,IACzBgF,WAAYrE,KAAKjE,QAAQuD,IACzBwC,YAAa9B,KAAK/C,MAAMgH,YACxBlB,YAAa/C,KAAK+C,YAClBhE,QAAiC,IAAzBiB,KAAKjB,OAAOC,SAAqB,CAACA,UAAU,GAAS,CAACA,UAAU,EACpEiE,KAAK,CACLnB,YAAc9B,KAAKjB,OAAOkE,KAAKhG,MAAMgH,YACrCC,WAAYlE,KAAKjB,OAAOkE,KAAKtD,QAAQN,IACrC8E,WAAYnE,KAAKjB,OAAOkE,KAAKtD,QAAQL,IACrC8E,WAAYpE,KAAKjB,OAAOkE,KAAKlH,QAAQsD,IACrCgF,WAAYrE,KAAKjB,OAAOkE,KAAKlH,QAAQuD,MAEzClD,IAAkB,OAAb4D,KAAK5D,IAAe4D,KAAK5D,IAAI6H,YAAc,KAChDjB,YAAahD,KAAKgD,cAO1BsB,iBAAmB,CAACjI,EAAOkI,KACvB,MAAMtJ,EAAY,IAAID,EAClB,IAAIoF,EAAKmE,EAAKL,WAAYK,EAAKJ,YAC/B,IAAI/D,EAAKmE,EAAKH,WAAYG,EAAKF,YAC/BnF,EAAMsF,iBAAiBD,EAAKzC,aAC5ByC,EAAKxB,YACL,CAAC/D,UAAU,GACX,KACAuF,EAAKvB,aAGT,GAAIuB,EAAKxF,OAAOC,SAAU,CACtB,MAAMyF,EAAUF,EAAKxF,OAAOkE,KAC5BhI,EAAU8D,OAAOC,UAAW,EAC5B/D,EAAU8D,OAAOkE,KAAO,IAAIjI,EAAK,IAAIoF,EAAKqE,EAAQP,WAAYO,EAAQN,YAChE,IAAI/D,EAAKqE,EAAQL,WAAYK,EAAQJ,YAAahI,EAAMqE,SAAS+D,EAAQP,WAAYO,EAAQN,YACvG,CACA,OAAOlJ,GAQf,MAAMiE,EACFoF,cAAgB,EAChBA,aAAe,EACfA,YAAc,IACdA,cAAgB,IAChBA,cAAgB,IAChBA,YAAc,IACdA,aAAe,IACfA,YAAc,IACd1E,YAAYpF,EAAQsI,GAChB9C,KAAKxF,OAASA,EACdwF,KAAK8C,KAAOA,CAChB,CAKAwB,wBAA2BxC,IACvB,MACMC,EAA+B,MADjBD,EAAY9D,MAAM,EAAG,GACEkB,EAAMC,MAAQD,EAAMiB,MACzDlD,EAAQ6E,EAAY9D,MAAM,EAAG,GACnC,MAAc,MAAVf,EACO,IAAIqD,EAAOyB,EAAc,IAAI3B,EAAK,EAAG,IAC3B,MAAVnD,EACA,IAAIuD,EAAKuB,EAAc,IAAI3B,EAAK,EAAG,IACzB,MAAVnD,EACA,IAAIoD,EAAO0B,EAAc,IAAI3B,EAAK,EAAG,IAC3B,MAAVnD,EACA,IAAIwD,EAAKsB,EAAc,IAAI3B,EAAK,EAAG,IACzB,MAAVnD,EACA,IAAIsD,EAAMwB,EAAc,IAAI3B,EAAK,EAAG,IAC1B,MAAVnD,EACA,IAAIiD,EAAK6B,EAAc,IAAI3B,EAAK,EAAG,IAEnC,IACX,EAIR,MAAME,UAAepB,EACjBoD,WAAa,CAAC,CAAC,EAAE,GAAI,EAAE,GAAG,GAAI,CAAC,GAAG,GAAG,EAAE,EAAE,IACzCrD,OAAS,IACTwD,KAAOvD,EAAMwF,OACbtF,WAAa,CACT,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,GAAK,EAAI,EAAG,GAAI,GAAK,EAAI,GAAG,IAC9B,EAAE,GAAK,EAAI,EAAG,GAAI,GAAK,EAAI,GAAG,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAElCG,WAAa,CACT,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,GAAK,EAAI,EAAG,GAAI,GAAK,EAAI,GAAG,IAC9B,EAAE,GAAK,EAAI,EAAG,GAAI,GAAK,EAAI,GAAG,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAElCK,YAAYpF,EAAQsI,GAChB6B,MAAMnK,EAAQsI,EAClB,CAMAc,SAAYvH,IACR,MAAMvB,EAAQ,GACR8J,EAAa5E,KAAK8C,KAAKzD,IACvBwF,EAAa7E,KAAK8C,KAAKxD,IAC7B,IAAK,MAAMiD,KAAavC,KAAKsC,WAAY,CACrC,MAAMjD,EAAMkD,EAAU,GAChBjD,EAAMiD,EAAU,GACtB,IAAIV,EAASxC,EAAMuF,EACfpC,EAASlD,EAAMuF,EACnB,KAAOxI,EAAM+F,QAAQP,EAAQW,IAAWnG,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,SAAS,CAC/E,MAAMuC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,MAElF,GADAlF,EAAMoB,KAAKa,GACPV,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,QAClC,MAEJqH,GAASxC,EACTmD,GAASlD,CACb,CACJ,CACA,OAAOxE,GAGX4C,QAAU,CAACrB,EAAOiH,KACd,MAAMjE,EAAMW,KAAK8C,KAAKzD,IAChBC,EAAMU,KAAK8C,KAAKxD,IAChBwF,EAAUxB,EAAKR,KAAKzD,IACpB0F,EAAUzB,EAAKR,KAAKxD,IAG1B,GAFgB9B,KAAKwH,IAAI3F,EAAMyF,KACftH,KAAKwH,IAAI1F,EAAMyF,GAE3B,OAAO,EAEX,MAAMH,EAAa5E,KAAK8C,KAAKzD,IACvBwF,EAAa7E,KAAK8C,KAAKxD,IAC7B,IAAK,MAAMiD,KAAavC,KAAKsC,WAAY,CACrC,MAAMjD,EAAMkD,EAAU,GAChBjD,EAAMiD,EAAU,GACtB,IAAIV,EAASxC,EAAMuF,EACfpC,EAASlD,EAAMuF,EACnB,KAAOxI,EAAM+F,QAAQP,EAAQW,IAAWnG,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,SAAS,CAC/E,GAAI6B,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,QAAS,CAC3C,GAAI6B,EAAMqE,SAASmB,EAAQW,GAAQC,OAASvD,EAAMwD,KAC9C,OAAO,EAEX,KACJ,CACAb,GAASxC,EACTmD,GAASlD,CACb,CACJ,CACA,OAAO,GAOXtC,UAAY,CAACD,EAAMkI,KACf,MAAM5I,EAAQ4I,EAAYjD,WACpBH,EAAS9E,EAAKhB,QAAQsD,IACtBmD,EAASzF,EAAKhB,QAAQuD,IACtB4F,EAAW7I,EAAMwF,GAAQW,GACd,OAAb0C,IACAnI,EAAKX,IAAM8I,GAEf7I,EAAMwF,GAAQW,GAAUxC,KACxB3D,EAAMU,EAAK4C,QAAQN,KAAKtC,EAAK4C,QAAQL,KAAO,KAC5CU,KAAK8C,KAAO,IAAI1C,EAAKyB,EAAQW,EAAM,EAGvCyB,UAAY,KACajE,KAAKxF,SAAW0E,EAAMC,MAAQ,IAAM,KACnC,IAG9B,MAAMqB,UAAatB,EACfoD,WAAa,CAAC,CAAC,EAAE,GAAI,EAAE,GAAG,GAAI,CAAC,GAAG,GAAG,EAAE,EAAE,GAAG,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,GAAG,GAAG,EAAE,EAAE,IACrEgC,kBAAoB,EACpBA,kBAAoB,EACpB7B,KAAOvD,EAAMwD,KACbzD,OAAS,IAETG,WAAa,CACT,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,CAAC,GAAI,GAAK,EAAI,EAAI,EAAI,EAAG,GAAI,IAC7B,CAAC,GAAI,GAAI,GAAK,EAAI,EAAG,GAAI,GAAI,KAGjCG,WAAa,CACT,CAAC,GAAI,GAAI,GAAK,EAAI,EAAG,GAAI,GAAI,IAC7B,CAAC,GAAI,GAAK,EAAI,EAAI,EAAI,EAAG,GAAI,IAC7B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAElCoB,cAAgB,CACZ,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,GAAK,EAAI,GAAG,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAK,EAAI,EAAI,EAAI,GAAG,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAElCC,cAAgB,CACZ,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAK,EAAI,EAAI,EAAI,GAAG,IAAI,IAC9B,EAAE,IAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAI,GAAI,GAAI,GAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,GAAK,EAAI,GAAG,IAAI,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAElChB,YAAYpF,EAAQsI,GAChB6B,MAAMnK,EAAQsI,EAClB,CAMAc,SAAYvH,IACR,MAAMvB,EAAQ,GACR8J,EAAa5E,KAAK8C,KAAKzD,IACvBwF,EAAa7E,KAAK8C,KAAKxD,IAC7B,IAAK,MAAMiD,KAAavC,KAAKsC,WAAY,CACrC,MAEMT,EAFMU,EAAU,GAEDqC,EACfpC,EAFMD,EAAU,GAEDsC,EACrB,IAAMxI,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,SAAW6B,EAAM+F,QAAQP,EAAQW,KAAanG,EAAMgG,YAAYR,EAAQW,EAAQxC,KAAKxF,QAAS,CAClI,MAAMuC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,MAClFlF,EAAMoB,KAAKa,EACf,CACJ,CACA,MAAMoI,EAAoBnF,KAAKxF,SAAW0E,EAAMC,MAAQhG,EAAyBE,EAC3E+L,EAAqBpF,KAAKxF,SAAW0E,EAAMC,MAAQ/F,EAA0BE,EAEnF,GAAI6L,GAAqB9I,EAAM+G,uBAAuBpD,KAAKxF,OAAQgG,EAAKO,aAAe1E,EAAMyE,aAAad,KAAKxF,OAAQgG,EAAKO,aAAe1E,EAAMwE,aAAab,KAAKxF,QAAS,CACxK,MAAM6E,EAAMW,KAAKxF,SAAW0E,EAAMiB,MAAQ,EAAI,EACxCb,EAAM,EACZxE,EAAMoB,KAAK,IAAIlB,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKf,EAAKC,GAAMU,MAAM,EAC5E,CAAChB,UAAU,EAAMiE,KAAM,IAAIjI,EAAK,IAAIoF,EAAKf,EAAK,GAAI,IAAIe,EAAKf,EAAK,GAAIhD,EAAMqE,SAASrB,EAAK,MAChG,CACA,GAAI+F,GAAsB/I,EAAM+G,uBAAuBpD,KAAKxF,OAAQgG,EAAKQ,cAAgB3E,EAAMyE,aAAad,KAAKxF,OAAQgG,EAAKQ,cAAgB3E,EAAMwE,aAAab,KAAKxF,QAAS,CAC3K,MAAM6E,EAAMW,KAAKxF,SAAW0E,EAAMiB,MAAQ,EAAI,EACxCb,EAAM,EACZxE,EAAMoB,KAAK,IAAIlB,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKf,EAAKC,GAAMU,MAAM,EAC5E,CAAChB,UAAU,EAAMiE,KAAM,IAAIjI,EAAK,IAAIoF,EAAKf,EAAK,GAAI,IAAIe,EAAKf,EAAK,GAAIhD,EAAMqE,SAASrB,EAAK,MAChG,CAGA,OAAOvE,GAGX4C,QAAU,CAACrB,EAAOiH,KACP,EAKXtG,UAAY,CAACD,EAAMkI,KACf,MAAM5I,EAAQ4I,EAAYjD,WACpBH,EAAS9E,EAAKhB,QAAQsD,IACtBmD,EAASzF,EAAKhB,QAAQuD,IACxBvC,EAAKgC,OAAOC,WACZ3C,EAAMU,EAAKgC,OAAOkE,KAAKlH,QAAQsD,KAAKtC,EAAKgC,OAAOkE,KAAKlH,QAAQuD,KAAOvC,EAAKgC,OAAOkE,KAAKhG,MACrFZ,EAAMU,EAAKgC,OAAOkE,KAAKtD,QAAQN,KAAKtC,EAAKgC,OAAOkE,KAAKtD,QAAQL,KAAO,KACpEvC,EAAKgC,OAAOkE,KAAKhG,MAAM6F,KAAKzD,IAAMtC,EAAKgC,OAAOkE,KAAKlH,QAAQsD,IAC3DtC,EAAKgC,OAAOkE,KAAKhG,MAAM6F,KAAKxD,IAAMvC,EAAKgC,OAAOkE,KAAKlH,QAAQuD,KAE/D,MAAM4F,EAAW7I,EAAMwF,GAAQW,GACd,OAAb0C,IACAnI,EAAKX,IAAM8I,GAEf7I,EAAMwF,GAAQW,GAAUxC,KACxB3D,EAAMU,EAAK4C,QAAQN,KAAKtC,EAAK4C,QAAQL,KAAO,KAC5CU,KAAK8C,KAAO,IAAI1C,EAAKyB,EAAQW,EAAM,EAGvCyB,UAAY,KACajE,KAAKxF,SAAW0E,EAAMC,MAAQ,IAAM,KACnC,IAG9B,MAAMkB,UAAenB,EACjBoD,WAAa,CAAC,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,EAAE,EAAG,GAAI,EAAE,GAAI,GAAI,EAAE,EAAG,GAAI,EAAE,GAAI,IAElFrD,OAAS,IACTwD,KAAOvD,EAAMmG,OAEbjG,WAAa,CACT,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAK,EAAI,EAAI,EAAI,GAAG,IAAI,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,IAAI,GAAK,EAAI,EAAI,EAAI,GAAG,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAGlCG,WAAa,CACT,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC9B,EAAE,IAAI,GAAK,EAAI,EAAI,EAAI,GAAG,IAAI,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,GAAK,EAAG,GAAI,GAAI,GAAI,GAAK,GAAG,IAC9B,EAAE,IAAI,GAAK,EAAI,EAAI,EAAI,GAAG,IAAI,IAC9B,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAElCK,YAAYpF,EAAQsI,GAChB6B,MAAMnK,EAAQsI,EAElB,CAMAc,SAAYvH,IACR,MAAMvB,EAAQ,GACd,IAAK,MAAMyH,KAAavC,KAAKsC,WAAY,CACrC,MAAMjD,EAAMkD,EAAU,GAChBjD,EAAMiD,EAAU,GAChBqC,EAAa5E,KAAK8C,KAAKzD,IACvBwF,EAAa7E,KAAK8C,KAAKxD,IACvBuC,EAASxC,EAAMuF,EACfpC,EAASlD,EAAMuF,EACrB,GAAIxI,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,SAAW6B,EAAM+F,QAAQP,EAAQW,GAAS,CAC5E,MAAMzF,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,MAClFlF,EAAMoB,KAAKa,EACf,CACJ,CACA,OAAOjC,GAGX4C,QAAU,CAACrB,EAAOiH,KACd,MAAMjE,EAAMW,KAAK8C,KAAKzD,IAChBC,EAAMU,KAAK8C,KAAKxD,IAChBwF,EAAUxB,EAAKR,KAAKzD,IACpB0F,EAAUzB,EAAKR,KAAKxD,IACpBgG,EAAU9H,KAAKwH,IAAI3F,EAAMyF,GACzBS,EAAU/H,KAAKwH,IAAI1F,EAAMyF,GAC/B,OAAIO,EAAUC,IAAY,KAGL,IAAZD,GAA6B,IAAZC,EAAc,EAM5CvI,UAAY,CAACD,EAAMkI,KACf,MAAM5I,EAAQ4I,EAAYjD,WACpBH,EAAS9E,EAAKhB,QAAQsD,IACtBmD,EAASzF,EAAKhB,QAAQuD,IACtB4F,EAAW7I,EAAMwF,GAAQW,GACd,OAAb0C,IACAnI,EAAKX,IAAM8I,GAEf7I,EAAMwF,GAAQW,GAAUxC,KACxB3D,EAAMU,EAAK4C,QAAQN,KAAKtC,EAAK4C,QAAQL,KAAO,KAC5CU,KAAK8C,KAAO,IAAI1C,EAAKyB,EAAQW,EAAM,EAGvCyB,UAAY,KACajE,KAAKxF,SAAW0E,EAAMC,MAAQ,IAAM,KACnC,IAG9B,MAAMsB,UAAavB,EACfD,OAAS,IACTwD,KAAOvD,EAAMsG,KAEbpG,WAAa,CACT,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAC7B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7B,CAAC,EAAI,EAAG,GAAI,GAAI,GAAI,GAAK,EAAI,GAC7B,CAAC,EAAI,EAAI,EAAG,GAAI,GAAK,EAAI,EAAI,GAC7B,CAAC,GAAI,GAAG,GAAK,EAAI,GAAG,IAAK,EAAI,GAC7B,CAAC,EAAG,GAAI,IAAI,IAAI,GAAI,GAAI,GAAK,GAC7B,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,IAEjCuB,cAAgB,CACZ,CAAC,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,KAC3C,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7B,CAAC,EAAI,EAAG,GAAI,GAAI,GAAI,GAAK,EAAI,GAC7B,CAAC,EAAI,EAAI,EAAG,GAAI,GAAK,EAAI,EAAI,GAC7B,CAAC,GAAI,GAAG,GAAK,EAAI,GAAG,IAAK,EAAI,GAC7B,CAAC,EAAG,GAAI,IAAI,IAAI,GAAI,GAAI,GAAK,GAC7B,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,IAEjCpB,WAAa,CACT,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAC7B,CAAC,EAAG,GAAI,IAAI,IAAI,GAAI,GAAI,GAAK,GAC7B,CAAC,EAAG,GAAG,GAAK,EAAI,GAAG,IAAK,EAAI,GAC5B,CAAC,EAAI,EAAI,EAAG,GAAI,GAAK,EAAI,EAAI,GAC7B,CAAC,EAAI,EAAG,GAAI,GAAI,GAAI,GAAK,EAAI,GAC7B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7B,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,IAEjCqB,cAAgB,CACZ,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAC7B,CAAC,EAAG,GAAI,IAAI,IAAI,GAAI,GAAI,GAAK,GAC7B,CAAC,EAAG,GAAG,GAAK,EAAI,GAAG,IAAK,EAAI,GAC5B,CAAC,EAAI,EAAI,EAAG,GAAI,GAAK,EAAI,EAAI,GAC7B,CAAC,EAAI,EAAG,GAAI,GAAI,GAAI,GAAK,EAAI,GAC7B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7B,CAAC,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,MAE/ChB,YAAYpF,EAAQsI,GAChB6B,MAAMnK,EAAQsI,EAElB,CAMAc,SAAYvH,IACR,MAAMuI,EAAa5E,KAAK8C,KAAKzD,IACvBwF,EAAa7E,KAAK8C,KAAKxD,IACvBxE,EAAQ,GACd,IAAI+G,EAAS7B,KAAK8C,KAAKzD,IAAM,EAAIW,KAAKxF,OAClCgI,EAASxC,KAAK8C,KAAKxD,IACvB,GAAIjD,EAAM+F,QAAQP,EAAQW,GAAS,CAC/B,MAAMzF,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GACrExC,UAAM5C,OAAWA,OAAWA,EACjB,IAAXyE,GAA2B,IAAXA,GAIpB,GAHI/G,EAAMoB,KAAKa,GAEf8E,EAAS7B,KAAK8C,KAAKzD,IAAM,EAAIW,KAAKxF,OAC9B6B,EAAM+F,QAAQP,EAAQW,KAAuB,IAAXX,GAA2B,IAAXA,GAClD,GAAI7B,KAAKxF,SAAW0E,EAAMiB,OAA2B,IAAlBH,KAAK8C,KAAKzD,IAAW,CACpD,MAAMtC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,MAE9ElF,EAAMoB,KAAKa,EAEnB,MAAO,GAAIiD,KAAKxF,SAAW0E,EAAMC,OAA2B,IAAlBa,KAAK8C,KAAKzD,IAAW,CAC3D,MAAMtC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,MAC9ElF,EAAMoB,KAAKa,EACnB,CAGR,CAGA,GAFA8E,EAAS7B,KAAK8C,KAAKzD,IAAM,EAAIW,KAAKxF,OAClCgI,EAASxC,KAAK8C,KAAKxD,IAAM,EACrBjD,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,QAAS,CAC3C,MAAMuC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,UAAO5C,OAAWA,EAAWf,EAAMqE,SAASmB,EAAQW,GACvH,IAAXX,GAA2B,IAAXA,GAChB/G,EAAMoB,KAAKa,EACnB,CAEA,GAAIV,EAAM+F,QAAQP,EAAQW,IAAWnG,EAAMvB,MAAMpB,OAAS,EAAG,CACzD,MAAM+L,EAAWpJ,EAAMvB,MAAMkD,OAAO,GAAG,GACvC,GAAIyH,EAASxI,MAAMwF,OAASvD,EAAMsG,MAAQC,EAAS1J,QAAQsD,MAAQW,KAAK8C,KAAKzD,KAAOoG,EAAS1J,QAAQuD,MAAQU,KAAK8C,KAAKxD,IAAM,GAC5D,IAA1D9B,KAAKwH,IAAIS,EAAS1J,QAAQsD,IAAMoG,EAAS9F,QAAQN,KAAY,CAChE,MAAMtC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,MAAM,GACpFlF,EAAMoB,KAAKa,EACnB,CAEJ,CAGA,GAFA8E,EAAS7B,KAAK8C,KAAKzD,IAAM,EAAIW,KAAKxF,OAClCgI,EAASxC,KAAK8C,KAAKxD,IAAM,EACrBjD,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,QAAS,CAC3C,MAAMuC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,UAAO5C,OAAWA,EAAWf,EAAMqE,SAASmB,EAAQW,GACvH,IAAXX,GAA2B,IAAXA,GAChB/G,EAAMoB,KAAKa,EACnB,CAEA,GAAIV,EAAM+F,QAAQP,EAAQW,IAAWnG,EAAMvB,MAAMpB,OAAS,EAAG,CACzD,MAAM+L,EAAWpJ,EAAMvB,MAAMkD,OAAO,GAAG,GACvC,GAAIyH,EAASxI,MAAMwF,OAASvD,EAAMsG,MAAQC,EAAS1J,QAAQsD,MAAQW,KAAK8C,KAAKzD,KAAOoG,EAAS1J,QAAQuD,MAAQU,KAAK8C,KAAKxD,IAAM,GAC5D,IAA1D9B,KAAKwH,IAAIS,EAAS1J,QAAQsD,IAAMoG,EAAS9F,QAAQN,KAAY,CAChE,MAAMtC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,MAAM,GACxFlF,EAAMoB,KAAKa,EACf,CAEJ,CACA,OAAOjC,GAEX4C,QAAU,CAACrB,EAAOiH,KACd,MAAMwB,EAAUxB,EAAKR,KAAKzD,IACpB0F,EAAUzB,EAAKR,KAAKxD,IACpBuC,EAAS7B,KAAK8C,KAAKzD,IAAM,EAAIW,KAAKxF,OAClCgI,EAASxC,KAAK8C,KAAKxD,IAAM,EACzBoG,EAAY1F,KAAK8C,KAAKxD,IAAM,EAClC,OAAOuC,IAAWiD,IAAYtC,IAAWuC,GAAWW,IAAcX,EAAO,EAM7E/H,UAAY,CAACD,EAAMkI,KACf,MAAM5I,EAAQ4I,EAAYjD,WACpBH,EAAS9E,EAAKhB,QAAQsD,IACtBmD,EAASzF,EAAKhB,QAAQuD,IAG5B,GAAIvC,EAAKgG,YAAa,CAClB,MAAM0C,EAAWR,EAAYnK,MAAMkD,OAAO,GAAG,GACvCkH,EAAW7I,EAAMoJ,EAAS1J,QAAQsD,KAAKoG,EAAS1J,QAAQuD,KAC7C,OAAb4F,IACAnI,EAAKX,IAAM8I,GAEf7I,EAAMoJ,EAAS1J,QAAQsD,KAAKoG,EAAS1J,QAAQuD,KAAO,IACxD,CACA,MAAM4F,EAAW7I,EAAMwF,GAAQW,GACd,OAAb0C,IACAnI,EAAKX,IAAM8I,GAEf7I,EAAMwF,GAAQW,GAAUxC,KACxB3D,EAAMU,EAAK4C,QAAQN,KAAKtC,EAAK4C,QAAQL,KAAO,KAC5CU,KAAK8C,KAAO,IAAI1C,EAAKyB,EAAQW,GACzBzF,EAAKiG,cACL3G,EAAMwF,GAAQW,GAAU,IAAIjC,EAAMP,KAAKxF,OAAQwF,KAAK8C,MACxD,EAGJmB,UAAY,KACajE,KAAKxF,SAAW0E,EAAMC,MAAQ,IAAM,KACnC,IAG9B,MAAMoB,UAAcrB,EAChBoD,WAAa,CAAC,CAAC,EAAE,GAAI,EAAE,GAAG,GAAI,CAAC,GAAG,GAAG,EAAE,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,GAAG,GAAG,EAAE,EAAE,IACtErD,OAAS,IACTwD,KAAOvD,EAAMyG,MAEbvG,WAAa,CACT,EAAE,IAAI,IAAI,IAAK,GAAI,GAAG,IAAI,IAAI,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC7B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,IAAI,IAAI,IAAK,GAAI,GAAG,IAAI,IAAI,KAElCG,WAAa,CACT,EAAE,IAAI,IAAI,IAAK,GAAI,GAAG,IAAI,IAAI,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC7B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,GAAK,EAAI,EAAI,EAAI,EAAI,EAAI,GAAG,IAC9B,EAAE,IAAI,IAAI,IAAK,GAAI,GAAG,IAAI,IAAI,KAElCK,YAAYpF,EAAQsI,GAChB6B,MAAMnK,EAAQsI,EAElB,CAMAc,SAAYvH,IACR,MAAMvB,EAAQ,GACd,IAAK,MAAMyH,KAAavC,KAAKsC,WAAY,CACrC,MAAMsC,EAAa5E,KAAK8C,KAAKzD,IACvBwF,EAAa7E,KAAK8C,KAAKxD,IACvBD,EAAMkD,EAAU,GAChBjD,EAAMiD,EAAU,GACtB,IAAIV,EAASxC,EAAMuF,EACfpC,EAASlD,EAAMuF,EACnB,KAAOxI,EAAM+F,QAAQP,EAAQW,IAAWnG,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,SAAS,CAC/E,MAAMuC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,MAElF,GADIlF,EAAMoB,KAAKa,GACXV,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,QAClC,MAEJqH,GAASxC,EACTmD,GAASlD,CACb,CACJ,CACA,OAAOxE,GAEX4C,QAAU,CAACrB,EAAOiH,KACd,MAAMjE,EAAMW,KAAK8C,KAAKzD,IAChBC,EAAMU,KAAK8C,KAAKxD,IAChBwF,EAAUxB,EAAKR,KAAKzD,IACpB0F,EAAUzB,EAAKR,KAAKxD,IAG1B,GAFgB9B,KAAKwH,IAAI3F,EAAMyF,KACftH,KAAKwH,IAAI1F,EAAMyF,IACFA,IAAYzF,GAAOwF,IAAYzF,EACxD,OAAO,EAEX,MAAMuF,EAAa5E,KAAK8C,KAAKzD,IACvBwF,EAAa7E,KAAK8C,KAAKxD,IAC7B,IAAK,MAAMiD,KAAavC,KAAKsC,WAAY,CACrC,MAAMjD,EAAMkD,EAAU,GAChBjD,EAAMiD,EAAU,GACtB,IAAIV,EAASxC,EAAMuF,EACfpC,EAASlD,EAAMuF,EACnB,KAAOxI,EAAM+F,QAAQP,EAAQW,IAAWnG,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,SAAS,CAC/E,GAAI6B,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,QAAS,CAC3C,GAAI6B,EAAMqE,SAASmB,EAAQW,GAAQC,OAASvD,EAAMwD,KAC9C,OAAO,EAEX,KACJ,CACAb,GAASxC,EACTmD,GAASlD,CACb,CACJ,CACA,OAAO,GAOXtC,UAAY,CAACD,EAAMkI,KACf,MAAM5I,EAAQ4I,EAAYjD,WACpBH,EAAS9E,EAAKhB,QAAQsD,IACtBmD,EAASzF,EAAKhB,QAAQuD,IACtB4F,EAAW7I,EAAMwF,GAAQW,GACd,OAAb0C,IACAnI,EAAKX,IAAM8I,GAEf7I,EAAMwF,GAAQW,GAAUxC,KACxB3D,EAAMU,EAAK4C,QAAQN,KAAKtC,EAAK4C,QAAQL,KAAO,KAC5CU,KAAK8C,KAAO,IAAI1C,EAAKyB,EAAQW,EAAM,EAGvCyB,UAAY,KACajE,KAAKxF,SAAW0E,EAAMC,MAAQ,IAAM,KACnC,IAG9B,MAAMe,UAAahB,EACfoD,WAAa,CAAC,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,GAAG,GAAG,EAAE,EAAE,IACvCrD,OAAS,IACTwD,KAAOvD,EAAMiE,KACb/D,WAAa,CACT,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAC7B,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAK,GAC7B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,IAEjCG,WAAa,CACT,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,GAAK,EAAI,GAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,EAAE,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,GAAI,GAC9B,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAK,GAC7B,CAAC,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,IAEjCK,YAAYpF,EAAQsI,GAChB6B,MAAMnK,EAAQsI,EAElB,CAMAc,SAAYvH,IACR,MAAMvB,EAAQ,GACd,IAAK,MAAMyH,KAAavC,KAAKsC,WAAY,CACrC,MAAMsC,EAAa5E,KAAK8C,KAAKzD,IACvBwF,EAAa7E,KAAK8C,KAAKxD,IACvBD,EAAMkD,EAAU,GAChBjD,EAAMiD,EAAU,GACtB,IAAIV,EAASxC,EAAMuF,EACfpC,EAASlD,EAAMuF,EACnB,KAAOxI,EAAM+F,QAAQP,EAAQW,IAAWnG,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,SAAS,CAC/E,MAAMuC,EAAO,IAAI/B,EAAK,IAAIoF,EAAKwE,EAAYC,GAAa,IAAIzE,EAAKyB,EAAQW,GAASxC,MAElF,GADIlF,EAAMoB,KAAKa,GACXV,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,QAClC,MAEJqH,GAASxC,EACTmD,GAASlD,CACb,CACJ,CACA,OAAOxE,GAEX4C,QAAU,CAACrB,EAAOiH,KACd,MAAMjE,EAAMW,KAAK8C,KAAKzD,IAChBC,EAAMU,KAAK8C,KAAKxD,IAChBwF,EAAUxB,EAAKR,KAAKzD,IAE1B,GADgBiE,EAAKR,KAAKxD,MACVA,GAAOwF,IAAYzF,EAC/B,OAAO,EAEX,IAAK,MAAMkD,KAAavC,KAAKsC,WAAY,CACrC,MAAMsC,EAAa5E,KAAK8C,KAAKzD,IACvBwF,EAAa7E,KAAK8C,KAAKxD,IACvBD,EAAMkD,EAAU,GAChBjD,EAAMiD,EAAU,GACtB,IAAIV,EAASxC,EAAMuF,EACfpC,EAASlD,EAAMuF,EACnB,KAAOxI,EAAM+F,QAAQP,EAAQW,IAAWnG,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,SAAS,CAC/E,GAAI6B,EAAM8F,OAAON,EAAQW,EAAQxC,KAAKxF,QAAS,CAC3C,GAAI6B,EAAMqE,SAASmB,EAAQW,GAAQC,OAASvD,EAAMwD,KAC9C,OAAO,EAEX,KACJ,CACAb,GAASxC,EACTmD,GAASlD,CACb,CACJ,CACA,OAAO,GAMXtC,UAAY,CAACD,EAAMkI,KACf,MAAM5I,EAAQ4I,EAAYjD,WACpBH,EAAS9E,EAAKhB,QAAQsD,IACtBmD,EAASzF,EAAKhB,QAAQuD,IACtB4F,EAAW7I,EAAMwF,GAAQW,GACd,OAAb0C,IACAnI,EAAKX,IAAM8I,GAGf7I,EAAMwF,GAAQW,GAAUxC,KACxB3D,EAAMU,EAAK4C,QAAQN,KAAKtC,EAAK4C,QAAQL,KAAO,KAC5CU,KAAK8C,KAAO,IAAI1C,EAAKyB,EAAQW,EAAM,EAGvCyB,UAAY,KACajE,KAAKxF,SAAW0E,EAAMC,MAAQ,IAAM,KACnC,IAI1B,IACI,MAAMoF,EAAOvL,EAAQuL,KACflK,EAAckK,EAAK,GACnBjK,EAAQiK,EAAK,GACbhK,EAAagK,EAAK,GAClB/J,EAAS+J,EAAK,GACd9J,EAAK8J,EAAK,GAEhB,GADA3L,EAAa2B,EAAWb,OACL,IAAfd,GACA,GAAI4B,IAAW0E,EAAMC,MAAO,CAExB,MAAMrE,EAAQ,CACV,IAAIE,EAAK,IAAIoF,EAAK,EAAG,GAAI,IAAIA,EAAK,EAAE,GAAI,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,KAC1E,IAAIpF,EAAK,IAAIoF,EAAK,EAAG,GAAI,IAAIA,EAAK,EAAE,GAAI,IAAIK,EAAKvB,EAAMC,MAAO,IAAIiB,EAAK,EAAG,MAExEwF,EAAcpI,KAAKqI,MAAMrI,KAAKsI,UAAYhL,EAAMpB,OAAS,IAE/DqM,YAAY,CAACjL,EAAM8K,GAAazJ,gBAAiB1B,GACrD,OACG,GAAmB,IAAf7B,EAAkB,CAEzB,MAAMoN,EAAUzL,EAAWQ,KAAIpB,GAAKqB,EAAKC,eAAUmC,EAAWzD,KAAI,GAClE,GAA4B,IAAxBqM,EAAQrG,QAAQN,KAAqC,IAAxB2G,EAAQrG,QAAQL,KAAqC,IAAxB0G,EAAQjK,QAAQsD,KAAqC,IAAxB2G,EAAQjK,QAAQuD,IAAW,CAClH,MAAMxE,EAAQ,CACV,IAAIE,EAAK,IAAIoF,EAAK,EAAG,GAAI,IAAIA,EAAK,EAAE,GAAI,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,KAC1E,IAAIpF,EAAK,IAAIoF,EAAK,EAAG,GAAI,IAAIA,EAAK,EAAE,GAAI,IAAIK,EAAKvB,EAAMiB,MAAO,IAAIC,EAAK,EAAG,MAExEwF,EAAcpI,KAAKqI,MAAMrI,KAAKsI,UAAYhL,EAAMpB,OAAS,IAE/DqM,YAAY,CAACjL,EAAM8K,GAAazJ,gBAAiB1B,GACrD,KAAO,CACH,MAAMwL,EAAW7L,EAAGC,EAAaC,EAAOC,EAAYC,EAAQC,GAC5DsL,YAAYE,EAChB,CACJ,KAAO,CACH,MAAMA,EAAW7L,EAAGC,EAAaC,EAAOC,EAAYC,EAAQC,GAC5DsL,YAAYE,EAChB,CACJ,CAAE,MAAO3H,GACLyH,YAAY,CAAC,CAACG,SAAS,EAAMlN,QAAQ,UAAYsF,IACrD,I","sources":["Chess/ai/worker.worker.js"],"sourcesContent":["let totalMoves = 0\n/**\n * This function encapsulates the entire AI logic\n * Note: Entire board logic is different from the UI board logic for performance reasons\n * @param message data from frontend, which includes: board string representation, depth of search, moves so far, AI colour, principal variation\n * @return {Promise<void>} best move deemed by the AI\n */\nconst test = async (message) => {\n   // https://chess.stackexchange.com/questions/40362/my-transposition-tables-implementation-slows-down-alpha-beta-pruning\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/negamax/tutorials/alpha-beta_quiescence_search/chess.c\n    //https://stackoverflow.com/questions/29990116/alpha-beta-prunning-with-transposition-table-iterative-deepening\n    // https://stackoverflow.com/questions/16500739/chess-high-branching-factor\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/bbc/collecting_pv/bbc.c\n    // https://github.com/kbjorklu/chess/blob/master/src/bitboard.js\n    //https://chess.stackexchange.com/questions/28160/moves-per-depth-in-search-engines\n    // Null move: https://web.archive.org/web/20071031095933/http://www.brucemo.com/compchess/programming/nullmove.htm\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/bbc/null_move_pruning/bbc.c\n    // TODO: check if endgame before running search, set score tables before search, done after set board string\n    // End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\n    // TODO: update piece score tables based on position before running search, done after set board string\n    // for knight, -5 per missing pawn of any colour\n    // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\n    // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\n    // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\n    const mem = new Map() // for killer moves\n    const MAX_DEPTH = 10\n    let whiteCanCastleKingSide = true\n    let whiteCanCastleQueenSide = true\n    let blackCanCastleKingSide = true\n    let blackCanCastleQueenSide = true\n    const pv_length = Array.from({length: MAX_DEPTH}, (x) => 0);\n    const pv_table = Array.from({length: MAX_DEPTH}, (x) => Array.from({length: MAX_DEPTH}, (x) => 0))\n    let currentPv = []\n    let startTime;\n    const MAX_TIME = 20000 // 20 seconds\n    const CHECK_THRESHOLD = 100000 // power of 2\n    let nodes = 0\n    let branch = 0\n    const NULL_MOVE_R = 2\n    const MAX_KILLER = 2\n    let isEndGame = false\n    /**\n     * Alpha beta minmax search driver function\n     * @param boardString board representation in string format\n     * @param depth AI depth\n     * @param moveString moves so far, represented by an array of strings\n     * @param colour AI colour, black or white\n     * @param pv principal variation moves, represented by an array of strings, used for move ordering\n     * @return {[*,*[]]} the best move in string representation, and principal variation\n     */\n    const ab =  (boardString, depth, moveString, colour, pv) => {\n        let bestMove;\n        const copyBoard = new Board()\n        copyBoard.setBoardString(boardString)\n        copyBoard.moves = moveString.map(x => Move.parseMove(copyBoard, x))\n        // set pv from previous iteration\n        for (let i = 2; i < pv.length; i++) { // first two moves would have been made\n            pv_table[0][i - 2] = Move.parseMove(copyBoard, pv[i])\n        }\n        const prev = pv_table[0]\n        currentPv = [...prev]\n        isEndGame = copyBoard.isEndGame()\n        if (isEndGame) {\n            console.log(\"endgame\")\n            copyBoard.setEndGame()\n        }\n        copyBoard.updatePieceValues(totalMoves)\n        for (let i = 1; i < depth; i++) {\n            mem.set(i, [null, null, null]) // max number of killer moves\n        }\n        startTime = performance.now()\n        let result\n        for (let i = 1; i <= depth; i++) { // iterative deepening\n            result = miniMax(copyBoard, i, -Number.MAX_VALUE, Number.MAX_VALUE, colour, colour, mem, 0)\n            const currentEnd = performance.now()\n            if (currentEnd - startTime < MAX_TIME) { // did not run out of time\n                const prev = pv_table[0]\n                currentPv = [...prev]\n            }\n            bestMove = currentPv[0]\n            console.log(i, \"Score\", result[1], currentPv[0].newCell)\n        }\n        // result = miniMax(copyBoard, depth, -Number.MAX_VALUE, Number.MAX_VALUE, colour, colour, mem, 0)\n        const end = performance.now()\n        // console.log(end - start, totalMoves, nodes)\n        const arr = []\n        for (let i = 0; i < depth; i++) {\n            if (currentPv[i] === 0) {\n                break\n            }\n            arr.push(currentPv[i].getMoveString())\n            console.log(currentPv[i].getMoveString(), currentPv[i].getMoveString().ate)\n        }\n        console.log(end - startTime, nodes, branch)\n        // console.log(\"eval\", nodes)\n\n\n        return [bestMove.getMoveString(), arr] // should be a move\n    }\n\n    /**\n     * Driver function for AI logic\n     * @param board board object\n     * @param depth current depth of search\n     * @param alpha for alpha pruning\n     * @param beta for beta pruning\n     * @param maxPlayer colour of maximising player (AI colour)\n     * @param currentPlayer colour of current player (black or white)\n     * @param mem memory, for memoization of data\n     * @param ply half move counter (inverse of depth)\n     * @return {[undefined,number]|[null,number]} returns [move, score of move]\n     */\n    const miniMax = (board, depth, alpha, beta, maxPlayer, currentPlayer, mem, ply) => {\n        pv_length[ply] = ply\n        if (nodes % CHECK_THRESHOLD === 0) {\n            if (performance.now() - startTime > MAX_TIME) {\n                return [null, 0]\n            }\n        }\n        const moves = board.getAllMoves(currentPlayer) // TODO: time consuming\n        moveOrderRoot(moves, depth, ply)\n        let bestMove;\n        if (currentPlayer === maxPlayer) {\n            let maxEval = -90000\n            let legal = 0\n            for (let i = 0; i < moves.length; i++) {\n                const move = moves[i]\n                board.movePiece(move.piece, move)\n                if (board.isIllegal(currentPlayer, move)) {\n                    board.undoMove()\n\n                    continue\n                }\n                legal++\n                if (bestMove === undefined) {\n                    bestMove = move\n                }\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem, ply + 1, legal === 1)\n                board.undoMove()\n                if (currentEval > maxEval) {\n                    maxEval = currentEval\n                    bestMove = move\n                    pv_table[ply][ply] = move\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\n                        // copy move from deeper ply into a current ply's line\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\n                    }\n                    // adjust PV length\n                    pv_length[ply] = pv_length[ply + 1];\n                }\n                alpha = Math.max(alpha, currentEval)\n                if (beta <= alpha) {\n                    break\n                }\n            }\n            if (legal === 0) { // TODO: check stalemate\n                if (board.isCheck(currentPlayer)) {\n                    return [null, -90000]\n                }\n                return [null, 0]\n            }\n            return [bestMove, maxEval]\n        }\n    }\n    let isNullMove = false\n    // This function is the same as the driver function, but does not return the best move\n    const miniMaxCore = (board, depth, alpha, beta, maxPlayer, currentPlayer, prevMoves, mem, ply, isLeftMost) => {\n        if (nodes % CHECK_THRESHOLD === 0) {\n            if (performance.now() - startTime > MAX_TIME) {\n                return board.getScore(maxPlayer, prevMoves)\n            }\n        }\n        let branchLocal = 0\n        nodes++\n\n        pv_length[ply] = ply\n        if (depth <= 0) {\n            let result\n            if (maxPlayer === currentPlayer && !isNullMove && board.moves.slice(-1)[0].ate !== null) { // only for max player\n                result = quiesce(alpha, beta, board, currentPlayer, 2, prevMoves)\n            } else {\n                result = board.getScore(maxPlayer, prevMoves)\n            }\n            return result\n        }\n        if (depth >= 2 + NULL_MOVE_R && !isEndGame && !isNullMove && !board.isCheck(currentPlayer)) {\n            isNullMove = true\n            const nullMoveVal =  miniMaxCore(board, depth - 1 - NULL_MOVE_R, beta - 1, beta, maxPlayer, currentPlayer * -1, prevMoves, mem, ply + 1 + NULL_MOVE_R, false)\n            isNullMove = false\n            if (nullMoveVal >= beta) {\n                return beta\n            }\n        }\n        const moves = board.getAllMoves(currentPlayer) // TODO: time consuming\n        moveOrder(moves, mem, depth, ply, isLeftMost)\n        if (currentPlayer === maxPlayer) {\n            let maxEval = -30000\n            let legal = 0\n            for (let i = 0; i < moves.length; i++) {\n                const move = moves[i]\n                board.movePiece(move.piece, move)\n                if (board.isIllegal(currentPlayer, move)) {\n                    board.undoMove()\n                    continue\n                }\n                legal++\n                branchLocal++\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem, ply + 1, legal === 1)\n                board.undoMove()\n                if (currentEval > maxEval) {\n                    maxEval = currentEval\n                    pv_table[ply][ply] = move\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\n                        // copy move from deeper ply into a current ply's line\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\n                    }\n                    // adjust PV length\n                    pv_length[ply] = pv_length[ply + 1];\n                }\n                if (currentEval > alpha) {\n                    alpha = currentEval\n                }\n                if (beta <= alpha) {\n                    if (move.ate !== null) {\n                        break\n                    }\n                    const arr = mem.get(depth)\n                    if (arr.find(e => e!== null && isEqualMove(e, move))) {\n                        break\n                    }\n                    for (let j = MAX_KILLER - 2; j >= 0; j--) {\n                        arr[j + 1] = arr[j]\n                    }\n                    arr[0] = move\n                    break\n                }\n            }\n            branch = (branch + branchLocal) / 2\n            if (legal === 0) {\n                if (board.isCheck(currentPlayer)) {\n                    return -30000 * depth // faster checkmates\n                }\n                return 0 // stalemate\n            }\n            return maxEval\n        } else {\n            let minEval = 30000\n            let legal = 0\n            for (let i = 0; i < moves.length; i++) {\n                const move = moves[i]\n                board.movePiece(move.piece, move)\n                if (board.isIllegal(currentPlayer, move)) {\n                    board.undoMove()\n                    continue\n                }\n                legal++\n                branchLocal++\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, prevMoves, mem, ply +1, legal === 1)\n                board.undoMove()\n                if (currentEval < minEval) {\n                    minEval = currentEval\n                    pv_table[ply][ply] = move\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\n                        // copy move from deeper ply into a current ply's line\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\n                    }\n                    // adjust PV length\n                    pv_length[ply] = pv_length[ply + 1];\n                }\n\n                if (currentEval < beta) {\n                    beta = currentEval\n                }\n                if (beta <= alpha) {\n                    if (move.ate !== null) {\n                        break\n                    }\n                    const arr = mem.get(depth)\n                    if (arr.find(e => e!== null && isEqualMove(e, move))) {\n                        break\n                    }\n                    for (let j = MAX_KILLER - 2; j >= 0; j--) {\n                        arr[j + 1] = arr[j]\n                    }\n                    arr[0] = move\n                    break\n                }\n            }\n            branch = (branch + branchLocal) / 2\n            if (legal === 0) {\n                if (board.isCheck(currentPlayer)) {\n                    return 30000 * depth\n                }\n                return 0\n\n            }\n            return minEval\n        }\n    }\n\n    /**\n     * Used for sorting the moves in the driver function,\n     * in this order: PV moves, castling moves, winning captures, losing captures, piece square table values\n     * @param moves\n     * @param depth\n     * @param ply\n     */\n    const moveOrderRoot = (moves, depth, ply) => {\n        const sortMovesO = (a, b) => {\n            const pvMove = currentPv[ply]\n            if (pvMove !== 0 && isEqualMove(a, pvMove)) {\n                return -1\n            } else if (pvMove !== 0 && isEqualMove(b, pvMove)) {\n                return 1\n            }\n            if (a.castle.isCastle) {\n                return -1\n            }\n            if (b.castle.isCastle) {\n                return 1\n            }\n            if (a.ate !== null && b.ate !== null) {\n                const aScore = a.piece.points - a.ate.points\n                const bScore = b.piece.points - b.ate.points\n                return aScore < bScore ? -1: 1\n            } else {\n                if (a.ate !== null) {\n                    return -1\n                } else if (b.ate !== null) {\n                    return 1\n                }\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\n                return aScore < bScore ? 1: -1\n\n            }\n        }\n        moves.sort(sortMovesO)\n    }\n\n    /**\n     * Used for sorting the moves, in this order: PV moves, castling moves, winning captures, losing captures, piece square table values\n     * Different from moveOrderRoot as it only sorts PV moves in the leftmost branch\n     * @param moves moves to sort\n     * @param mem memorized killer moves\n     * @param depth depth remaining to search\n     * @param ply half move counter\n     * @param isLeftMost if current branch is left most\n     */\n    const moveOrder = (moves, mem, depth, ply, isLeftMost) => {\n\n        const sortMovesO = (a, b) => {\n            const pvMove = currentPv[ply]\n            if (isLeftMost && pvMove !== 0) {\n                if (isEqualMove(a, pvMove)) {\n                    return -1\n                } else if (isEqualMove(b, pvMove)) {\n                    return 1\n                }\n            }\n            if (a.castle.isCastle) {\n                return -1\n            }\n            if (b.castle.isCastle) {\n                return 1\n            }\n            if (a.ate !== null && b.ate !== null) {\n                const aScore = a.piece.points - a.ate.points\n                const bScore = b.piece.points - b.ate.points\n                return aScore < bScore ? -1: 1\n            } else {\n                if (a.ate !== null) {\n                    return -1\n                } else if (b.ate !== null) {\n                    return 1\n                }\n                const memSlot = mem.get(depth)\n                for (let slot = 0; slot < memSlot.length; slot++) {\n                    const killerMove = memSlot[slot]\n                    if (killerMove !== null && isEqualMove(a, killerMove)) {\n                        return -1\n                    }\n                    if (killerMove !== null && isEqualMove(b, killerMove)) {\n                        return 1\n                    }\n                }\n\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\n                return aScore < bScore ? 1: -1\n\n            }\n        }\n        moves.sort(sortMovesO)\n    }\n\n    /**\n     * Check if two moves are equal\n     * @param a\n     * @param b\n     * @return {boolean}\n     */\n    const isEqualMove = (a, b) => {\n        if (a.newCell.row === b.newCell.row && a.newCell.col === b.newCell.col && a.oldCell.row === b.oldCell.row && a.oldCell.col === b.oldCell.col && a.piece.constructor === b.piece.constructor) {\n            if (a.ate !== null && b.ate !== null) {\n                return a.ate.constructor === b.ate.constructor\n            }\n            return a.ate === b.ate\n        }\n        return false\n    }\n\n    /**\n     * Used for move ordering in quiescence search\n     * @param a move to sort\n     * @param b move to sort\n     * @return {number|number} order to sort moves\n     */\n    const sortMoves = (a, b) => {\n        if (a.ate !== null && b.ate !== null) {\n            const aScore = a.piece.points - a.ate.points\n            const bScore = b.piece.points - b.ate.points\n            return aScore < bScore ? -1: 1\n        } else {\n            if (a.ate !== null) {\n                return -1\n            } else if (b.ate !== null) {\n                return 1\n            } else {\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\n                return aScore < bScore ? 1: -1\n            }\n        }\n    }\n\n    /**\n     * Quiescence search to mitigate horizon effect\n     * @param alpha alpha value\n     * @param beta beta value\n     * @param board board object\n     * @param colour current player\n     * @param depth depth remaining\n     * @param prevMoves moves made in the previous ply\n     * @return {number|*|number} score of position\n     */\n    const quiesce = (alpha, beta, board, colour, depth, prevMoves) => {\n        const evaluation = board.getScore(colour, prevMoves)\n        if (depth === 0) {\n            return evaluation\n        }\n        if (evaluation >= beta) {\n            return beta\n        }\n\n        alpha = Math.max(alpha, evaluation)\n        const moves = board.getAllMoves(colour)\n        moves.sort(sortMoves)\n        for (let i = 0; i < moves.length; i++) {\n            const move = moves[i]\n            if (move.ate !== null) { //  && move.ate.points > move.piece.points\n                board.movePiece(move.piece, move)\n                let score = -quiesce(-beta, -alpha, board, colour * -1, depth - 1, prevMoves)\n                board.undoMove()\n                if (score >= beta) {\n                    return beta\n                }\n                if (score > alpha) {\n                    alpha = score\n                }\n            } else {\n                break\n            }\n        }\n        return alpha\n    }\n    //\n    // const quiesceOdd = (alpha, beta, board, colour, depth) => {\n    //     // const evaluation = evaluate(board, colour)\n    //     let evaluation\n    //     const boardHash = board.getBoardHash() + colour.toString()\n    //     if (mem.has(boardHash)) {\n    //         evaluation = mem.get(boardHash)\n    //     } else {\n    //         evaluation = evaluate(board, colour)\n    //         mem.set(boardHash, evaluation)\n    //     }\n    //\n    //     if (depth === 0) {\n    //         return evaluation\n    //     }\n    //     if (evaluation >= beta) {\n    //         return beta\n    //     }\n    //\n    //     alpha = Math.max(alpha, evaluation)\n    //     const moves = board.getAllMoves(colour)\n    //     moves.sort(sortMovesQuiesce)\n    //     for (const move of moves) {\n    //         if (move.ate !== null) { //  && move.ate.points > move.piece.points\n    //             board.movePiece(move.piece, move)\n    //             let score = -quiesce(-beta, -alpha, board, switchColour(colour), depth - 1)\n    //             board.undoMove()\n    //             if (score >= beta) {\n    //                 return beta\n    //             }\n    //             if (score > alpha) {\n    //                 alpha = score\n    //             }\n    //         }\n    //     }\n    //     return alpha\n    // }\n\n    // const negaMax = (depth, board, colour, maxColour) => {\n    //     if (depth === 0) {\n    //         return evaluate(board, maxColour)\n    //     }\n    //     const testGameOver = board.isGameOver(colour).isGameOver\n    //     if (testGameOver && colour === maxColour) {\n    //         return -Number.MAX_VALUE\n    //     }\n    //     if (testGameOver && colour !== maxColour) {\n    //         return Number.MAX_VALUE\n    //     }\n    //     let max = -Number.MAX_VALUE\n    //     const moves = board.getAllMoves(colour)\n    //     for (const move of moves) {\n    //         board.movePiece(move.piece, move)\n    //         const currentEval = -negaMax(depth - 1, board, switchColour(colour), maxColour)\n    //         if (currentEval > max) {\n    //             max = currentEval\n    //         }\n    //         board.undoMove()\n    //     }\n    //     return max\n    // }\n    // const rootNegaMax = (depth, board, colour, maxColour) => {\n    //     const rootMoves = board.getAllMoves(maxColour)\n    //     let max = -Number.MAX_VALUE\n    //     const randomIndex = Math.floor(Math.random() * (rootMoves.length - 1))\n    //     let bestMove = rootMoves.length > 0 ? rootMoves[randomIndex] : null\n    //     for (const move of rootMoves) {\n    //         board.movePiece(move.piece, move)\n    //         const score = negaMax(depth, board, colour, maxColour)\n    //         if (score > max) {\n    //             max = score\n    //             bestMove = move\n    //         }\n    //         board.undoMove()\n    //     }\n    //     return bestMove\n    //\n    // }\n\n    /**\n     * This class represents the board object, and contains all functions that can be performed on a chess board\n     */\n    class Board {\n        board;\n\n        constructor() {\n            this.board = this.newBoard()\n            this.moves = []\n        }\n\n        /**\n         * Returns a new chess bord with pieces in their starting positions in a conventional chess game\n         * @return {((Rook|Knight|Bishop|Queen|King)[]|Pawn[]|*[])[]}\n         */\n        newBoard = () => {\n            const startingBoard = [\n                [new Rook(Piece.BLACK, new Cell(0,0)), new Knight(Piece.BLACK, new Cell(0, 1)), new Bishop(Piece.BLACK, new Cell(0, 2)), new Queen(Piece.BLACK, new Cell(0, 3)), new King(Piece.BLACK, new Cell(0, 4)), new Bishop(Piece.BLACK, new Cell(0, 5)), new Knight(Piece.BLACK, new Cell(0, 6)), new Rook(Piece.BLACK, new Cell(0,7))],\n                [new Pawn(Piece.BLACK, new Cell(1, 0)), new Pawn(Piece.BLACK, new Cell(1, 1)), new Pawn(Piece.BLACK, new Cell(1, 2)), new Pawn(Piece.BLACK, new Cell(1, 3)), new Pawn(Piece.BLACK, new Cell(1, 4)), new Pawn(Piece.BLACK, new Cell(1, 5)), new Pawn(Piece.BLACK, new Cell(1, 6)), new Pawn(Piece.BLACK, new Cell(1, 7))],\n                [null, null, null, null, null, null, null, null],\n                [null, null, null, null, null, null, null, null],\n                [null, null, null, null, null, null, null, null],\n                [null, null, null, null, null, null, null, null],\n                [new Pawn(Piece.WHITE, new Cell(6, 0)), new Pawn(Piece.WHITE, new Cell(6, 1)), new Pawn(Piece.WHITE, new Cell(6, 2)), new Pawn(Piece.WHITE, new Cell(6, 3)), new Pawn(Piece.WHITE, new Cell(6, 4)), new Pawn(Piece.WHITE, new Cell(6, 5)), new Pawn(Piece.WHITE, new Cell(6, 6)), new Pawn(Piece.WHITE, new Cell(6, 7))],\n                [new Rook(Piece.WHITE, new Cell(7,0)), new Knight(Piece.WHITE, new Cell(7, 1)), new Bishop(Piece.WHITE, new Cell(7, 2)), new Queen(Piece.WHITE, new Cell(7, 3)), new King(Piece.WHITE, new Cell(7, 4)), new Bishop(Piece.WHITE, new Cell(7, 5)), new Knight(Piece.WHITE, new Cell(7, 6)), new Rook(Piece.WHITE, new Cell(7,7))],\n            ]\n            return startingBoard\n        }\n        // update piece square tables for endgame\n        setEndGame = () => {\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null && piece.whiteScoreEnd !== undefined) {\n                        if (piece.colour === Piece.WHITE) {\n                            piece.whiteScore = piece.whiteScoreEnd\n                        } else {\n                            piece.blackScore = piece.blackScoreEnd\n                        }\n                    }\n                }\n            }\n        }\n        // update values of pieces, based on board state, game phase\n        updatePieceValues = (totalMoves) => {\n            // set if colour can castle here\n            if (this.kingHasMoved(Piece.WHITE)) {\n                whiteCanCastleKingSide = false\n                whiteCanCastleQueenSide = false\n            }\n            if (this.rookHasMoved(Piece.WHITE, King.KING_SIDE)) {\n                whiteCanCastleKingSide = false\n            }\n            if (this.rookHasMoved(Piece.WHITE, King.QUEEN_SIDE)) {\n                whiteCanCastleQueenSide = false\n            }\n            if (this.kingHasMoved(Piece.BLACK)) {\n                blackCanCastleKingSide = false\n                blackCanCastleQueenSide = false\n            }\n            if (this.rookHasMoved(Piece.BLACK, King.KING_SIDE)) {\n                blackCanCastleKingSide = false\n            }\n            if (this.rookHasMoved(Piece.BLACK, King.QUEEN_SIDE)) {\n                blackCanCastleQueenSide = false\n            }\n            const MOVE_THRESHOLD = 12\n            // for knight, -5 per missing pawn of any colour done\n            // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\n            // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\n            // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\n\n            let whitePawnCount = 0\n            let blackPawnCount = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        if (piece instanceof Pawn) {\n                            if (piece.colour === Piece.WHITE) {\n                                whitePawnCount++\n                            } else {\n                                blackPawnCount++\n                            }\n                        }\n                    }\n                }\n            }\n            const openFiles = []\n            for (let col = 0; col < 8; col++) {\n                let hasPawn = false\n                for (let row = 0; row < 8; row++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        if (piece instanceof Pawn) {\n                            hasPawn = true\n                            break\n                        }\n                    }\n                }\n                if (!hasPawn) {\n                    openFiles.push(col)\n                }\n            }\n\n            // first ten moves, bad to move queen out, and encourage piece development\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        if (piece instanceof Queen) {\n                            if (totalMoves <= MOVE_THRESHOLD) {\n                                if (piece.colour === Piece.WHITE) {\n                                    piece.whiteScore[7][3]+=50\n                                } else {\n                                    piece.blackScore[0][3]+=50\n                                }\n                            }\n                        }\n                        if (piece instanceof Knight) {\n                            piece.points-= ((16 - whitePawnCount - blackPawnCount) * 3)\n                            if (totalMoves <= MOVE_THRESHOLD) {\n                                if (piece.colour === Piece.WHITE) {\n                                    piece.whiteScore[7][1]-=50\n                                    piece.whiteScore[7][6]-=50\n                                } else {\n                                    piece.blackScore[0][1]-=50\n                                    piece.blackScore[0][6]-=50\n                                }\n                            }\n                        }\n                        if (piece instanceof Bishop) {\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\n                            if (totalMoves <= MOVE_THRESHOLD) {\n                                if (piece.colour === Piece.WHITE) {\n                                    piece.whiteScore[7][2]-=50\n                                    piece.whiteScore[7][5]-=50\n                                } else {\n                                    piece.blackScore[0][2]-=50\n                                    piece.blackScore[0][5]-=50\n                                }\n                            }\n                        }\n                        if (piece instanceof Rook) {\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\n                            for (const openCol of openFiles) {\n                                for (let openRow = 0; openRow<8; openRow++) {\n                                    piece.whiteScore[openRow][openCol]+= 15\n                                    piece.blackScore[openRow][openCol]+= 15\n                                }\n                            }\n                        }\n                        if (piece instanceof Pawn) {\n                            let past = true\n                            if (col + 1 < 8) {\n                                if (piece.colour === Piece.WHITE) {\n                                    for (let i = row  - 1; i >= 0; i--) {\n                                        if (this.getPiece(i, col + 1) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                } else {\n                                    for (let i = row + 1; i < 8; i++) {\n                                        if (this.getPiece(i, col + 1) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                }\n\n                            }\n                            if (col < 8) {\n                                if (piece.colour === Piece.WHITE) {\n                                    for (let i = row  - 1; i >= 0; i--) {\n                                        if (this.getPiece(i, col) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                } else {\n                                    for (let i = row + 1; i < 8; i++) {\n                                        if (this.getPiece(i, col) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                }\n\n                            }\n                            if (col - 1 >= 0) {\n                                if (piece.colour === Piece.WHITE) {\n                                    for (let i = row  - 1; i >= 0; i--) {\n                                        if (this.getPiece(i, col - 1) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                } else {\n                                    for (let i = row + 1; i < 8; i++) {\n                                        if (this.getPiece(i, col - 1) instanceof Pawn) {\n                                            past = false\n                                        }\n                                    }\n                                }\n                            }\n                            if (past) {\n                                if (piece.colour === Piece.WHITE) {\n                                    piece.points+= (20 * (6 - row))\n                                } else {\n                                    piece.points+= (20 * (row - 1))\n                                }\n\n                            }\n                            let doubled = false\n                            for (let i = 0; i < 8; i++) {\n                                if (piece instanceof Pawn && i !== row) {\n                                    doubled = true\n                                }\n                            }\n                            if (doubled) {\n                                piece.points-=10\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Determines if the game is in endgame state. End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\n        isEndGame = () => {\n            let countWhitePieces = 0\n            let countBlackPieces = 0\n            let countWhiteQueen = 0\n            let countBlackQueen = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece instanceof Queen) {\n                        if (piece.colour === Piece.WHITE) {\n                            countWhiteQueen++\n                        } else {\n                            countBlackQueen++\n                        }\n                    }\n                    if (piece instanceof Rook || piece instanceof Bishop || piece instanceof Knight) {\n                        if (piece.colour === Piece.WHITE) {\n                            countWhitePieces++\n                        } else {\n                            countBlackPieces++\n                        }\n                    }\n                }\n            }\n            return ((countWhiteQueen <= 1 && countWhitePieces <=1) || (countBlackQueen <= 1  && countBlackPieces <=1))\n                || ((countWhitePieces <=3 && countWhiteQueen <= 0) || (countBlackPieces <=3  && countBlackQueen <= 0))\n        }\n\n        /**\n         * Converts the string representation of a board to the array of objects representation of the board and sets the board\n         * @param boardString string representation of board\n         */\n        setBoardString = (boardString) => {\n            const newBoard = []\n            for (let row = 0; row < 8; row++) {\n                const newRow = []\n                for (let col = 0; col < 8; col++) {\n                    const pieceString = boardString[row][col]\n                    if (pieceString === null) {\n                        newRow.push(null)\n                    } else {\n                        const pieceColour = pieceString.slice(0, 1)\n                        const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\n                        const piece = pieceString.slice(1, 2)\n                        if (piece === \"b\") {\n                            newRow.push(new Bishop(actualColour, new Cell(row, col)))\n                        } else if (piece === 'k') {\n                            newRow.push(new King(actualColour, new Cell(row, col)))\n                        } else if (piece === 'n') {\n                            newRow.push(new Knight(actualColour, new Cell(row, col)))\n                        } else if (piece === 'p') {\n                            newRow.push(new Pawn(actualColour, new Cell(row, col)))\n                        } else if (piece === 'q') {\n                            newRow.push(new Queen(actualColour, new Cell(row, col)))\n                        } else if (piece === 'r') {\n                            newRow.push(new Rook(actualColour, new Cell(row, col)))\n                        } else {\n                            newRow.push(null)\n                        }\n                    }\n                }\n                newBoard.push(newRow)\n            }\n            this.board = newBoard\n        }\n\n        // getBoardHash = () => {\n        //     let str = \"\"\n        //     for (let row = 0; row < 8; row++) {\n        //         for (let col = 0; col < 8; col++) {\n        //             if (!this.isEmpty(row, col)) {\n        //                 str += this.getPiece(row, col).getString()\n        //             } else {\n        //                 str += \" \"\n        //             }\n        //         }\n        //     }\n        //     return str\n        // }\n\n        /**\n         * Returns the board represented by the array\n         */\n        getBoard = () => {\n            return this.board\n        }\n\n        /**\n         * Returns piece at the coordinates\n         */\n        getPiece = (row, col) => {\n            return this.board[row][col]\n        }\n\n        /**\n         * Returns if the cell is empty\n         */\n        isEmpty = (row, col) => {\n            if (this.isOutSide(row, col)) {\n                return false\n            }\n            return this.board[row][col] === null\n        }\n\n        /**\n         * Checks if coordinate is out of bounds\n         */\n        isOutSide = (row, col) => {\n            return row < 0 || col < 0 || row > 7 || col > 7\n        }\n\n        /**\n         * Checks if piece can be eaten (different color)\n         */\n        canEat = (row, col, colour) => {\n            return !this.isOutSide(row, col) && !this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour\n        }\n\n        /**\n         * Checks if cell is within the chess board, and is empty\n         */\n        canMove = (row, col) => {\n            return !this.isOutSide(row, col) && this.isEmpty(row, col)\n        }\n\n        /**\n         * Checks if King can move to a square, must not have another king at the cell\n         */\n        canKingMove = (row, col, colour) => {\n            const directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\n            for (const direction of directions) {\n                const newRow = row + direction[0]\n                const newCol = col + direction[1]\n                if (!this.isOutSide(newRow, newCol) && !this.isEmpty(newRow, newCol)\n                    && (this.getPiece(newRow, newCol).name === Piece.KING && this.getPiece(newRow, newCol).colour !== colour)) {\n                    return false\n                }\n            }\n            return true\n        }\n\n        /**\n         * Moves a piece\n         */\n        movePiece = (piece, move) => {\n            move.piece.movePiece(move, this)\n            this.moves.push(move)\n        }\n\n        /**\n         * Undo a move\n         * @return {boolean}\n         */\n        undoMove = () => {\n            if (this.moves.length > 0) {\n                const move = this.moves.pop()\n                const prevRow = move.oldCell.row\n                const prevCol = move.oldCell.col\n                const piece = this.board[move.newCell.row][move.newCell.col]\n                this.board[prevRow][prevCol] = piece\n                piece.cell.row = prevRow\n                piece.cell.col = prevCol\n                if (move.isEnPassant) { // add back pawn\n                    this.board[move.ate.cell.row][move.ate.cell.col] = move.ate\n                    this.board[move.newCell.row][move.newCell.col] = null\n                    return true\n                } else if (move.isPromotion) { // remove piece, add back pawn\n                    this.board[prevRow][prevCol] = new Pawn(piece.colour, piece.cell, piece.moves)\n                } else if (move.castle.isCastle) { // king will be undone, need to undo rook\n                    this.board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = move.castle.rook.piece\n                    move.castle.rook.piece.cell.row = move.castle.rook.oldCell.row\n                    move.castle.rook.piece.cell.col = move.castle.rook.oldCell.col\n                    this.board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = null\n                }\n                this.board[move.newCell.row][move.newCell.col] = move.ate\n                return true\n            }\n            return false\n        }\n\n        /**\n         * Check if king has moved, for castling reasons\n         */\n        kingHasMoved = (colour) => {\n            for (let i = 0; i < this.moves.length; i++) {\n                const move = this.moves[i]\n                if (move.piece.name === Piece.KING && move.piece.colour === colour) {\n                    return true\n                }\n            }\n            return false\n        }\n\n        /**\n         * Check if rook has moved, for castling reasons\n         */\n        rookHasMoved = (colour, side) => {\n            const row = colour === Piece.BLACK ? 0 : 7\n            const col = side === King.KING_SIDE ? 7 : 0\n            if (!(this.getPiece(row, col) !== null && this.getPiece(row, col).name === Piece.ROOK)) { // no rook on cell\n                return true\n            }\n            for (const move of this.moves) {\n                if (move.piece.name === Piece.ROOK && move.piece.colour === colour && move.oldCell.row === row && move.oldCell.col === col) {\n                    return true\n                }\n            }\n            return false\n        }\n\n        /**\n         * Check if squares between rook and king are empty for castling purposes\n         */\n        castlingSquaresIsEmpty = (colour, side) => {\n            const row = colour === Piece.BLACK ? 0 : 7\n            const cols = side === King.KING_SIDE ? [5,6] : [1,2,3]\n            for (const col of cols) {\n                if (!this.isEmpty(row, col)) {\n                    return false\n                }\n            }\n            return true\n        }\n\n        /**\n         * Check if a move is illegal: whether a king gets eaten or places a king under check\n         */\n        isIllegal = (colour, move) => {\n            // get colour king first\n            let king;\n            let kingCount = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col)) {\n                        const piece = this.getPiece(row, col)\n                        if (piece.name === Piece.KING) {\n                            kingCount++\n                            if (piece.colour === colour) {\n                                king = piece\n                            }\n                        }\n                    }\n                }\n            }\n            if (kingCount < 2) {\n                return true\n            }\n            if (move.castle.isCastle) {\n                const moves = this.getAllMoves(colour * -1)\n                const row = move.newCell.row\n                if (move.newCell.col === 6) { // kingside\n                    for (const opp of moves) {\n                        const moveRow = opp.newCell.row\n                        const moveCol = opp.newCell.col\n                        if (moveRow === row && (moveCol === 6 || moveCol === 5 || moveCol === 4)) {\n                            return true\n                        }\n                    }\n                } else {\n                    for (const opp of moves) { // queenside\n                        const moveRow = opp.newCell.row\n                        const moveCol = opp.newCell.col\n                        if (moveRow === row && (moveCol === 2 || moveCol === 3 || moveCol === 4)) {\n                            return true\n                        }\n                    }\n                }\n            }\n\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour) {\n                        const piece = this.getPiece(row, col)\n                        if (piece.isCheck(this, king)) {\n                            return true\n                        }\n                    }\n                }\n            }\n            return false\n        }\n        // check if colour is under check\n        isCheck = (colour) => {\n            let king;\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col)) {\n                        const piece = this.getPiece(row, col)\n                        if (piece.name === Piece.KING) {\n                            if (piece.colour === colour) {\n                                king = piece\n                            }\n                        }\n                    }\n                }\n            }\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour) {\n                        const piece = this.getPiece(row, col)\n                        if (piece.isCheck(this, king)) {\n                            return true\n                        }\n                    }\n                }\n            }\n            return false\n        }\n\n        /**\n         * Returns all moves for a colour\n         */\n        getAllMoves = (colour) => {\n            let squares = []\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour === colour) {\n                        const piece = this.getPiece(row, col)\n                        const moves = piece.getMoves(this)\n                        squares = squares.concat(moves)\n                    }\n                }\n            }\n            return squares\n        }\n        /**\n         * Goes through board for positional eval, like piece development, hardcoded for black\n         */\n        scanSquaresScore = () => {\n            let score = 0\n            let materialScore = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        // material score\n                        if (piece.colour === Piece.WHITE) {\n                            materialScore += piece.points\n                        } else {\n                            materialScore -= piece.points\n                        }\n\n                        // development / positional score\n                        if (piece.colour === Piece.WHITE) {\n                            score += piece.whiteScore[row][col]\n                        } else {\n                            score -= piece.blackScore[row][col]\n                        }\n                    }\n                }\n            }\n\n            return score + materialScore\n        }\n\n        /**\n         * used for minimax heuristics\n         * @param colour colour making the next move\n         * @param prevMoves total moves available\n         * @return {number} score of position\n         */\n        getScore = (colour, prevMoves) => {\n            const positionalScore = this.scanSquaresScore()\n            return (positionalScore + prevMoves.length * 3) * colour * -1\n        }\n\n        /**\n         * get string representation of the board\n         */\n        getBoardString = () => {\n            const newBoard = []\n            for (let row = 0; row < 8; row++) {\n                const newRow = []\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        newRow.push(piece.getString())\n                    } else {\n                        newRow.push(null)\n                    }\n                }\n                newBoard.push(newRow)\n            }\n            return newBoard\n        }\n\n    }\n    /**\n     * This class represents a coordinate on the chess board\n     */\n    class Cell {\n        constructor(row, col) {\n            this.row = row\n            this.col = col\n        }\n    }\n\n    /**\n     * This class represents a move made on a chess board\n     */\n    class Move {\n        oldCell\n        newCell\n\n        constructor(oldCell, newCell, piece, isEnPassant = false,\n                    castle = {isCastle: false}, ate = null, isPromotion = false) {\n            this.oldCell = oldCell\n            this.newCell = newCell\n            this.piece = piece\n            this.isEnPassant = isEnPassant\n            this.castle = castle\n            this.ate = ate\n            this.isPromotion = isPromotion\n        }\n\n        /**\n         * Get string representation of a move\n         */\n        getMoveString = () => {\n            return {\n                oldCellRow: this.oldCell.row,\n                oldCellCol: this.oldCell.col,\n                newCellRow: this.newCell.row,\n                newCellCol: this.newCell.col,\n                pieceString: this.piece.getString(),\n                isEnPassant: this.isEnPassant,\n                castle: this.castle.isCastle === false ? {isCastle: false} : {isCastle: true,\n                    rook:{\n                    pieceString : this.castle.rook.piece.getString(),\n                    oldCellRow: this.castle.rook.oldCell.row,\n                    oldCellCol: this.castle.rook.oldCell.col,\n                    newCellRow: this.castle.rook.newCell.row,\n                    newCellCol: this.castle.rook.newCell.col,\n                }},\n                ate: this.ate !== null ? this.ate.getString() : null,\n                isPromotion: this.isPromotion\n            }\n        }\n\n        /**\n         * Converts a string representation of a move to a move object representation\n         */\n        static parseMove = (board, data) => {\n            const parseMove = new Move(\n                new Cell(data.oldCellRow, data.oldCellCol),\n                new Cell(data.newCellRow, data.newCellCol),\n                Piece.parsePieceString(data.pieceString),\n                data.isEnPassant,\n                {isCastle: false},\n                null,\n                data.isPromotion\n            )\n\n            if (data.castle.isCastle) {\n                const rookObj = data.castle.rook\n                parseMove.castle.isCastle = true\n                parseMove.castle.rook = new Move(new Cell(rookObj.oldCellRow, rookObj.oldCellCol)\n                    , new Cell(rookObj.newCellRow, rookObj.newCellCol), board.getPiece(rookObj.oldCellRow, rookObj.oldCellCol))\n            }\n            return parseMove\n        }\n\n    }\n\n    /**\n     * The class represents a chess piece\n     */\n    class Piece {\n        static WHITE = -1\n        static BLACK = 1\n        static ROOK = \"r\"\n        static BISHOP = \"b\"\n        static KNIGHT = \"n\"\n        static KING = \"k\"\n        static QUEEN = \"q\"\n        static PAWN = \"p\"\n        constructor(colour, cell) {\n            this.colour = colour // white or black\n            this.cell = cell\n        }\n\n        /**\n         * converts string representation of piece to board representation\n         */\n        static parsePieceString = (pieceString) => {\n            const pieceColour = pieceString.slice(0, 1)\n            const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\n            const piece = pieceString.slice(1, 2)\n            if (piece === \"b\") {\n                return new Bishop(actualColour, new Cell(0, 0))\n            } else if (piece === 'k') {\n                return new King(actualColour, new Cell(0, 0))\n            } else if (piece === 'n') {\n                return new Knight(actualColour, new Cell(0, 0))\n            } else if (piece === 'p') {\n                return new Pawn(actualColour, new Cell(0, 0))\n            } else if (piece === 'q') {\n                return new Queen(actualColour, new Cell(0, 0))\n            } else if (piece === 'r') {\n                return new Rook(actualColour, new Cell(0, 0))\n            } else {\n                return null\n            }\n        }\n    }\n\n    class Bishop extends Piece {\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1]]\n        points = 330\n        name = Piece.BISHOP\n        whiteScore = [\n            [-20,-10,-10,-10,-10,-10,-10,-20],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-10,  0,  5, 10, 10,  5,  0,-10],\n            [-10,  5,  5, 10, 10,  5,  5,-10],\n            [-10,  0, 10, 10, 10, 10,  0,-10],\n            [-10, 10, 10, 10, 10, 10, 10,-10],\n            [-10,  5,  0,  0,  0,  0,  5,-10],\n            [-20,-10,-10,-10,-10,-10,-10,-20]\n        ]\n        blackScore = [\n            [-20,-10,-10,-10,-10,-10,-10,-20],\n            [-10,  5,  0,  0,  0,  0,  5,-10],\n            [-10, 10, 10, 10, 10, 10, 10,-10],\n            [-10,  0, 10, 10, 10, 10,  0,-10],\n            [-10,  5,  5, 10, 10,  5,  5,-10],\n            [-10,  0,  5, 10, 10,  5,  0,-10],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-20,-10,-10,-10,-10,-10,-10,-20],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                    moves.push(move)\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        // check if piece is checking the enemy king\n        isCheck = (board, king) => {\n            const row = this.cell.row\n            const col = this.cell.col\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            const rowDiff = Math.abs(row - kingRow)\n            const colDiff = Math.abs(col - kingCol)\n            if (rowDiff !== colDiff) {\n                return false\n            }\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\n                            return true\n                        }\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return false\n\n        }\n\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"b\"\n        }\n    }\n    class King extends Piece {\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\n        static KING_SIDE = -1\n        static QUEEN_SIDE = 1\n        name = Piece.KING\n        points = 10000\n\n        whiteScore = [\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-20,-30,-30,-40,-40,-30,-30,-20],\n            [-10,-20,-20,-20,-20,-20,-20,-10],\n            [20, 20,  0,  0,  0,  0, 20, 20],\n            [20, 30, 10,  0,  0, 10, 30, 20]\n        ]\n\n        blackScore = [\n            [20, 30, 10,  0,  0, 10, 30, 20],\n            [20, 20,  0,  0,  0,  0, 20, 20],\n            [-10,-20,-20,-20,-20,-20,-20,-10],\n            [-20,-30,-30,-40,-40,-30,-30,-20],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n        ]\n        whiteScoreEnd = [\n            [-50,-40,-30,-20,-20,-30,-40,-50],\n            [-30,-20,-10,  0,  0,-10,-20,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-30,  0,  0,  0,  0,-30,-30],\n            [-50,-30,-30,-30,-30,-30,-30,-50]\n        ]\n        blackScoreEnd = [\n            [-50,-30,-30,-30,-30,-30,-30,-50],\n            [-30,-30,  0,  0,  0,  0,-30,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-20,-10,  0,  0,-10,-20,-30],\n            [-50,-40,-30,-20,-20,-30,-40,-50],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                const newRow = row + currentRow\n                const newCol = col + currentCol\n                if (((board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol))) && board.canKingMove(newRow, newCol, this.colour)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                    moves.push(move)\n                }\n            }\n            const canCastleKingSide = this.colour === Piece.WHITE ? whiteCanCastleKingSide : blackCanCastleKingSide\n            const canCastleQueenSide = this.colour === Piece.WHITE ? whiteCanCastleQueenSide : blackCanCastleQueenSide\n            // king and rook has not moved, illegal check later\n            if (canCastleKingSide && board.castlingSquaresIsEmpty(this.colour, King.KING_SIDE) && !board.rookHasMoved(this.colour, King.KING_SIDE) && !board.kingHasMoved(this.colour)) {\n                const row = this.colour === Piece.BLACK ? 0 : 7\n                const col = 6\n                moves.push(new Move(new Cell(currentRow, currentCol), new Cell(row, col), this, false,\n                    {isCastle: true, rook: new Move(new Cell(row, 7), new Cell(row, 5), board.getPiece(row, 7))}))\n            }\n            if (canCastleQueenSide && board.castlingSquaresIsEmpty(this.colour, King.QUEEN_SIDE) && !board.rookHasMoved(this.colour, King.QUEEN_SIDE) && !board.kingHasMoved(this.colour)) {\n                const row = this.colour === Piece.BLACK ? 0 : 7\n                const col = 2\n                moves.push(new Move(new Cell(currentRow, currentCol), new Cell(row, col), this, false,\n                    {isCastle: true, rook: new Move(new Cell(row, 0), new Cell(row, 3), board.getPiece(row, 0))}))\n            }\n\n\n            return moves\n        }\n        // check if piece is checking the enemy king\n        isCheck = (board, king) => {\n            return false\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            if (move.castle.isCastle) {\n                board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = move.castle.rook.piece\n                board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = null\n                move.castle.rook.piece.cell.row = move.castle.rook.newCell.row\n                move.castle.rook.piece.cell.col = move.castle.rook.newCell.col\n            }\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"k\"\n        }\n    }\n    class Knight extends Piece {\n        directions = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n\n        points = 320\n        name = Piece.KNIGHT\n\n        whiteScore = [\n            [-50,-40,-30,-30,-30,-30,-40,-50],\n            [-40,-20,  0,  0,  0,  0,-20,-40],\n            [-30,  0, 10, 15, 15, 10,  0,-30],\n            [-30,  5, 15, 20, 20, 15,  5,-30],\n            [-30,  0, 15, 20, 20, 15,  0,-30],\n            [-30,  5, 10, 15, 15, 10,  5,-30],\n            [-40,-20,  0,  5,  5,  0,-20,-40],\n            [-50,-40,-30,-30,-30,-30,-40,-50]\n        ]\n\n        blackScore = [\n            [-50,-40,-30,-30,-30,-30,-40,-50],\n            [-40,-20,  0,  5,  5,  0,-20,-40],\n            [-30,  5, 10, 15, 15, 10,  5,-30],\n            [-30,  0, 15, 20, 20, 15,  0,-30],\n            [-30,  5, 15, 20, 20, 15,  5,-30],\n            [-30,  0, 10, 15, 15, 10,  0,-30],\n            [-40,-20,  0,  0,  0,  0,-20,-40],\n            [-50,-40,-30,-30,-30,-30,-40,-50],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const newRow = row + currentRow\n                const newCol = col + currentCol\n                if (board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                    moves.push(move)\n                }\n            }\n            return moves\n        }\n        // check if piece is checking the enemy king\n        isCheck = (board, king) => {\n            const row = this.cell.row\n            const col = this.cell.col\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            const rowDiff = Math.abs(row - kingRow)\n            const colDiff = Math.abs(col - kingCol)\n            if (rowDiff + colDiff !== 3) {\n                return false\n            }\n            return !(rowDiff === 0 || colDiff === 0);\n\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"n\"\n        }\n    }\n    class Pawn extends Piece {\n        points = 100\n        name = Piece.PAWN\n\n        whiteScore = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5, -5,-10,  0,  0,-10, -5,  5],\n            [5, 10, 10,-20,-20, 10, 10,  5],\n            [0,  0,  0,  0,  0,  0,  0,  0]\n        ]\n        whiteScoreEnd = [\n            [100,  100,  100,  100,  100,  100,  100,  100],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5, -5,-10,  0,  0,-10, -5,  5],\n            [5, 10, 10,-20,-20, 10, 10,  5],\n            [0,  0,  0,  0,  0,  0,  0,  0]\n        ]\n        blackScore = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [5, 10, 10,-40,-40, 10, 10,  5],\n            [5, 10,20,  0,  0,-10, -5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [0,  0,  0,  0,  0,  0,  0,  0],\n        ]\n        blackScoreEnd = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [5, 10, 10,-40,-40, 10, 10,  5],\n            [5, 10,20,  0,  0,-10, -5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [100,  100,  100,  100,  100,  100,  100,  100],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            const moves = []\n            let newRow = this.cell.row + 1 * this.colour\n            let newCol = this.cell.col\n            if (board.canMove(newRow, newCol)) {\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol),\n                    this, undefined, undefined, undefined,\n                    newRow === 0 || newRow === 7)\n                    moves.push(move)\n\n                newRow = this.cell.row + 2 * this.colour\n                if (board.canMove(newRow, newCol) && (newRow === 3 || newRow === 4)) {\n                    if (this.colour === Piece.BLACK && this.cell.row === 1) {\n                        const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n\n                            moves.push(move)\n\n                    } else if (this.colour === Piece.WHITE && this.cell.row === 6) {\n                        const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                            moves.push(move)\n                    }\n\n                }\n            }\n            newRow = this.cell.row + 1 * this.colour\n            newCol = this.cell.col + 1\n            if (board.canEat(newRow, newCol, this.colour)) {\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\n                    newRow === 0 || newRow === 7)\n                    moves.push(move)\n            }\n            // en passant\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\n                const prevMove = board.moves.slice(-1)[0]\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col + 1\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this, true)\n                        moves.push(move)\n                }\n\n            }\n            newRow = this.cell.row + 1 * this.colour\n            newCol = this.cell.col - 1\n            if (board.canEat(newRow, newCol, this.colour)) {\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\n                    newRow === 0 || newRow === 7)\n                    moves.push(move)\n            }\n            // en passant\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\n                const prevMove = board.moves.slice(-1)[0]\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col - 1\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this, true)\n                    moves.push(move)\n                }\n\n            }\n            return moves\n        }\n        isCheck = (board, king) => {\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            const newRow = this.cell.row + 1 * this.colour\n            const newCol = this.cell.col + 1\n            const newColOpp = this.cell.col - 1\n            return newRow === kingRow && (newCol === kingCol || newColOpp === kingCol)\n        }\n\n        /**\n         * Moves the piece\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            // const old = board[move.oldCell.row][move.oldCell.col]\n            // promotion\n            if (move.isEnPassant) {\n                const prevMove = boardObject.moves.slice(-1)[0]\n                const oldPiece = board[prevMove.newCell.row][prevMove.newCell.col]\n                if (oldPiece !== null) {\n                    move.ate = oldPiece\n                }\n                board[prevMove.newCell.row][prevMove.newCell.col] = null\n            }\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n            if (move.isPromotion) {\n                board[newRow][newCol] = new Queen(this.colour, this.cell)\n            }\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"p\"\n        }\n    }\n    class Queen extends Piece {\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1], [0,1], [1,0], [0,-1],[-1,0]]\n        points = 900\n        name = Piece.QUEEN\n\n        whiteScore = [\n            [-20,-10,-10, -5, -5,-10,-10,-20],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-10,  0,  5,  5,  5,  5,  0,-10],\n            [-5,  0,  5,  5,  5,  5,  0, -5],\n            [0,  0,  5,  5,  5,  5,  0, -5],\n            [-10,  5,  5,  5,  5,  5,  0,-10],\n            [-10,  0,  5,  0,  0,  0,  0,-10],\n            [-20,-10,-10, -5, -5,-10,-10,-20]\n        ]\n        blackScore = [\n            [-20,-10,-10, -5, -5,-10,-10,-20],\n            [-10,  0,  5,  0,  0,  0,  0,-10],\n            [-10,  5,  5,  5,  5,  5,  0,-10],\n            [0,  0,  5,  5,  5,  5,  0, -5],\n            [-5,  0,  5,  5,  5,  5,  0, -5],\n            [-10,  0,  5,  5,  5,  5,  0,-10],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-20,-10,-10, -5, -5,-10,-10,-20],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                        moves.push(move)\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        isCheck = (board, king) => {\n            const row = this.cell.row\n            const col = this.cell.col\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            const rowDiff = Math.abs(row - kingRow)\n            const colDiff = Math.abs(col - kingCol)\n            if ((rowDiff !== colDiff) && kingCol !== col && kingRow !== row) {\n                return false\n            }\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\n                            return true\n                        }\n                        break;\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return false\n\n        }\n\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"q\"\n        }\n    }\n    class Rook extends Piece {\n        directions = [[0,1], [1,0], [0,-1],[-1,0]]\n        points = 500\n        name = Piece.ROOK\n        whiteScore = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [5, 10, 10, 10, 10, 10, 10,  5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [0,  0,  0,  5,  5,  0,  0,  0]\n        ]\n        blackScore = [\n            [0,  0,  4,  5,  5,  10,  0,  0],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [5, 10, 10, 10, 10, 10, 10,  5],\n            [0,  0,  0,  0,  0,  0,  0,  0],\n        ]\n        constructor(colour, cell) {\n            super(colour, cell)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\n                        moves.push(move)\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        isCheck = (board, king) => {\n            const row = this.cell.row\n            const col = this.cell.col\n            const kingRow = king.cell.row\n            const kingCol = king.cell.col\n            if (kingCol !== col && kingRow !== row) {\n                return false\n            }\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\n                            return true\n                        }\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return false\n\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"r\"\n        }\n    }\n\n        try {\n            const data = message.data\n            const boardString = data[0]\n            const depth = data[1]\n            const moveString = data[2]\n            const colour = data[3]\n            const pv = data[4]\n            totalMoves = moveString.length\n            if (totalMoves === 0) {\n                if (colour === Piece.WHITE) {\n                    // equal chance to play d4, e4\n                    const moves = [\n                        new Move(new Cell(6, 3), new Cell(4,3), new Pawn(Piece.WHITE, new Cell(6, 3))),\n                        new Move(new Cell(6, 4), new Cell(4,4), new Pawn(Piece.WHITE, new Cell(6, 4))),\n                    ]\n                    const randomIndex = Math.round(Math.random() * (moves.length - 1))\n\n                    postMessage([moves[randomIndex].getMoveString(), pv])\n                }\n            } else if (totalMoves === 1) {\n                // equal chance to play c5 / e5, in response to e4\n                const getMove = moveString.map(x => Move.parseMove(undefined, x))[0]\n                if (getMove.oldCell.row === 6 && getMove.oldCell.col === 4 && getMove.newCell.row === 4 && getMove.newCell.col === 4) {\n                    const moves = [\n                        new Move(new Cell(1, 2), new Cell(3,2), new Pawn(Piece.BLACK, new Cell(1, 2))),\n                        new Move(new Cell(1, 4), new Cell(3,4), new Pawn(Piece.BLACK, new Cell(1, 4))),\n                    ]\n                    const randomIndex = Math.round(Math.random() * (moves.length - 1))\n\n                    postMessage([moves[randomIndex].getMoveString(), pv])\n                } else {\n                    const nextMove = ab(boardString, depth, moveString, colour, pv)\n                    postMessage(nextMove)\n                }\n            } else {\n                const nextMove = ab(boardString, depth, moveString, colour, pv)\n                postMessage(nextMove)\n            }\n        } catch (e) {\n            postMessage([{isError: true, message:\"Error: \" + e}])\n        }\n\n}\n// eslint-disable-next-line no-restricted-globals,no-undef\nself.addEventListener(\"message\", test);\n"],"names":["totalMoves","self","addEventListener","async","message","mem","Map","whiteCanCastleKingSide","whiteCanCastleQueenSide","blackCanCastleKingSide","blackCanCastleQueenSide","pv_length","Array","from","length","x","pv_table","startTime","currentPv","MAX_TIME","CHECK_THRESHOLD","nodes","branch","isEndGame","ab","boardString","depth","moveString","colour","pv","bestMove","copyBoard","Board","setBoardString","moves","map","Move","parseMove","i","prev","console","log","setEndGame","updatePieceValues","set","result","performance","now","miniMax","Number","MAX_VALUE","newCell","end","arr","push","getMoveString","ate","board","alpha","beta","maxPlayer","currentPlayer","ply","getAllMoves","moveOrderRoot","maxEval","legal","move","movePiece","piece","isIllegal","undoMove","undefined","currentEval","miniMaxCore","next_ply","Math","max","isCheck","isNullMove","prevMoves","isLeftMost","getScore","branchLocal","slice","quiesce","nullMoveVal","moveOrder","get","find","e","isEqualMove","j","MAX_KILLER","minEval","sort","a","b","pvMove","castle","isCastle","points","Piece","WHITE","whiteScore","row","col","blackScore","memSlot","slot","killerMove","oldCell","constructor","sortMoves","evaluation","score","this","newBoard","Rook","BLACK","Cell","Knight","Bishop","Queen","King","Pawn","getPiece","whiteScoreEnd","blackScoreEnd","kingHasMoved","rookHasMoved","KING_SIDE","QUEEN_SIDE","whitePawnCount","blackPawnCount","openFiles","hasPawn","openCol","openRow","past","doubled","countWhitePieces","countBlackPieces","countWhiteQueen","countBlackQueen","newRow","pieceString","actualColour","getBoard","isEmpty","isOutSide","canEat","canMove","canKingMove","directions","direction","newCol","name","KING","pop","prevRow","prevCol","cell","isEnPassant","isPromotion","rook","side","ROOK","castlingSquaresIsEmpty","cols","king","kingCount","opp","moveRow","moveCol","squares","getMoves","concat","scanSquaresScore","materialScore","getBoardString","getString","oldCellRow","oldCellCol","newCellRow","newCellCol","static","data","parsePieceString","rookObj","BISHOP","super","currentRow","currentCol","kingRow","kingCol","abs","boardObject","oldPiece","canCastleKingSide","canCastleQueenSide","KNIGHT","rowDiff","colDiff","PAWN","prevMove","newColOpp","QUEEN","randomIndex","round","random","postMessage","getMove","nextMove","isError"],"sourceRoot":""}