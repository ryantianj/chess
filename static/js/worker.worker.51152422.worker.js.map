{"version":3,"file":"static/js/worker.worker.51152422.worker.js","mappings":"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","sources":["Chess/ai/worker.worker.js"],"sourcesContent":["let totalMoves = 0\r\nlet mem = new Map()\r\nconst test = async (message) => {\r\n   // https://chess.stackexchange.com/questions/40362/my-transposition-tables-implementation-slows-down-alpha-beta-pruning\r\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/negamax/tutorials/alpha-beta_quiescence_search/chess.c\r\n    //https://stackoverflow.com/questions/29990116/alpha-beta-prunning-with-transposition-table-iterative-deepening\r\n    // console.log(\"working\")\r\n    let nodes = 0\r\n    if (totalMoves % 2 === 0) {\r\n        mem = new Map()\r\n    }\r\n    // console.log(\"mem\", mem.size)\r\n    totalMoves++\r\n    const ab =  (boardString, depth, moveString) => {\r\n        nodes = 0\r\n        const copyBoard = new Board()\r\n        copyBoard.setBoardString(boardString)\r\n        // const start = performance.now()\r\n        copyBoard.moves = moveString.map(x => Move.parseMove(copyBoard, x))\r\n        const result = miniMax(copyBoard, depth, -Number.MAX_VALUE, Number.MAX_VALUE, true, Piece.BLACK, Piece.BLACK)\r\n        // const result = rootNegaMax(depth, copyBoard, Piece.BLACK, Piece.BLACK)\r\n        // const end = performance.now()\r\n        // console.log(nodes, end - start, totalMoves)\r\n        // console.log(\"Score\", result[1])\r\n        return result[0] // should be a move\r\n    }\r\n\r\n    const evaluate = (board, colour) => { // TODO: improve heursitics, engine elo determined here\r\n        return board.getScore(colour)\r\n    }\r\n\r\n    const switchColour = (colour) => {\r\n        return colour === Piece.BLACK ? Piece.WHITE : Piece.BLACK\r\n    }\r\n\r\n    const sortMoves = (a, b) => {\r\n        if (a.ate !== null && b.ate !== null) {\r\n            const aScore = a.piece.points - a.ate.points\r\n            const bScore = b.piece.points - b.ate.points\r\n            return aScore < bScore ? 1: -1\r\n        } else if (a.ate !== null) {\r\n            return 1\r\n        } else if (b.ate !== null) {\r\n            return -1\r\n        }\r\n        return 0\r\n    }\r\n\r\n    const miniMax = (board, depth, alpha, beta, isMax, maxPlayer, currentPlayer) => {\r\n        // nodes++\r\n        if (depth === 0) {\r\n            // const result = evaluate(board, maxPlayer)\r\n            const result = maxPlayer * quiesce(alpha, beta, board, currentPlayer, 2) // TODO: for even calling depth no need -1, for odd , -1\r\n\r\n            return [null, result]\r\n        }\r\n        const testGameOver = board.isGameOver(currentPlayer)\r\n        if (testGameOver.isGameOver && currentPlayer === maxPlayer) {\r\n            return [null, -Number.MAX_VALUE]\r\n        }\r\n        if (testGameOver.isGameOver && currentPlayer !== maxPlayer) {\r\n            return [null, Number.MAX_VALUE]\r\n        }\r\n        const moves = testGameOver.allMoves\r\n        moves.sort(sortMovesQuiesce)\r\n        const randomIndex = Math.floor(Math.random() * (moves.length - 1))\r\n        let bestMove = moves.length > 0 ? moves[randomIndex] : null\r\n\r\n        if (isMax){\r\n            let maxEval = -Number.MAX_VALUE\r\n            for (const move of moves) {\r\n                board.movePiece(move.piece, move)\r\n                const currentEval = miniMax(board, depth - 1, alpha, beta, false, maxPlayer, switchColour(currentPlayer))[1]\r\n                board.undoMove()\r\n                if (currentEval > maxEval) {\r\n                    maxEval = currentEval\r\n                    bestMove = move\r\n                }\r\n                alpha = Math.max(alpha, currentEval)\r\n                if (beta <= alpha) {\r\n                    break\r\n                }\r\n            }\r\n            return [bestMove, maxEval]\r\n        } else {\r\n            let minEval = Number.MAX_VALUE\r\n            for (const move of moves) {\r\n                board.movePiece(move.piece, move)\r\n                const currentEval = miniMax(board, depth - 1, alpha, beta, true, maxPlayer, switchColour(currentPlayer))[1]\r\n                board.undoMove()\r\n                if (currentEval < minEval) {\r\n                    minEval = currentEval\r\n                    bestMove = move\r\n                }\r\n                beta = Math.min(beta, currentEval)\r\n                if (beta <= alpha) {\r\n                    break\r\n                }\r\n            }\r\n            return [bestMove, minEval]\r\n        }\r\n    }\r\n\r\n    const sortMovesQuiesce = (a, b) => {\r\n        if (a.ate !== null && b.ate !== null) {\r\n            const aScore = a.piece.points - a.ate.points\r\n            const bScore = b.piece.points - b.ate.points\r\n            return aScore < bScore ? 1: -1\r\n        } else if (a.ate !== null) {\r\n            return -1\r\n        } else if (b.ate !== null) {\r\n            return 1\r\n        }\r\n        return 0\r\n    }\r\n\r\n    const quiesce = (alpha, beta, board, colour, depth) => {\r\n        // const evaluation = evaluate(board, colour)\r\n        let evaluation\r\n        const boardHash = board.getBoardHash() + colour.toString()\r\n        if (mem.has(boardHash)) {\r\n            nodes++\r\n            evaluation = mem.get(boardHash)\r\n        } else {\r\n            evaluation = evaluate(board, colour)\r\n            mem.set(boardHash, evaluation)\r\n        }\r\n\r\n        if (depth === 0) {\r\n            return evaluation\r\n        }\r\n        if (evaluation >= beta) {\r\n            return beta\r\n        }\r\n\r\n        alpha = Math.max(alpha, evaluation)\r\n        const moves = board.getAllMoves(colour)\r\n        moves.sort(sortMovesQuiesce)\r\n        for (const move of moves) {\r\n            if (move.ate !== null && move.ate.points > move.piece.points) {\r\n                board.movePiece(move.piece, move)\r\n                let score = -quiesce(-beta, -alpha, board, switchColour(colour), depth - 1)\r\n                board.undoMove()\r\n                if (score >= beta) {\r\n                    return beta\r\n                }\r\n                if (score > alpha) {\r\n                    alpha = score\r\n                }\r\n            }\r\n        }\r\n        return alpha\r\n    }\r\n\r\n    const negaMax = (depth, board, colour, maxColour) => {\r\n        if (depth === 0) {\r\n            return evaluate(board, maxColour)\r\n        }\r\n        const testGameOver = board.isGameOver(colour).isGameOver\r\n        if (testGameOver && colour === maxColour) {\r\n            return -Number.MAX_VALUE\r\n        }\r\n        if (testGameOver && colour !== maxColour) {\r\n            return Number.MAX_VALUE\r\n        }\r\n        let max = -Number.MAX_VALUE\r\n        const moves = board.getAllMoves(colour)\r\n        for (const move of moves) {\r\n            board.movePiece(move.piece, move)\r\n            const currentEval = -negaMax(depth - 1, board, switchColour(colour), maxColour)\r\n            if (currentEval > max) {\r\n                max = currentEval\r\n            }\r\n            board.undoMove()\r\n        }\r\n        return max\r\n    }\r\n    const rootNegaMax = (depth, board, colour, maxColour) => {\r\n        const rootMoves = board.getAllMoves(maxColour)\r\n        let max = -Number.MAX_VALUE\r\n        const randomIndex = Math.floor(Math.random() * (rootMoves.length - 1))\r\n        let bestMove = rootMoves.length > 0 ? rootMoves[randomIndex] : null\r\n        for (const move of rootMoves) {\r\n            board.movePiece(move.piece, move)\r\n            const score = negaMax(depth, board, colour, maxColour)\r\n            if (score > max) {\r\n                max = score\r\n                bestMove = move\r\n            }\r\n            board.undoMove()\r\n        }\r\n        return bestMove\r\n\r\n    }\r\n    class Board {\r\n        board;\r\n\r\n        constructor() {\r\n            this.board = this.newBoard()\r\n            this.moves = []\r\n        }\r\n\r\n        newBoard = () => {\r\n            const startingBoard = [\r\n                [new Rook(Piece.BLACK, new Cell(0,0)), new Knight(Piece.BLACK, new Cell(0, 1)), new Bishop(Piece.BLACK, new Cell(0, 2)), new Queen(Piece.BLACK, new Cell(0, 3)), new King(Piece.BLACK, new Cell(0, 4)), new Bishop(Piece.BLACK, new Cell(0, 5)), new Knight(Piece.BLACK, new Cell(0, 6)), new Rook(Piece.BLACK, new Cell(0,7))],\r\n                [new Pawn(Piece.BLACK, new Cell(1, 0)), new Pawn(Piece.BLACK, new Cell(1, 1)), new Pawn(Piece.BLACK, new Cell(1, 2)), new Pawn(Piece.BLACK, new Cell(1, 3)), new Pawn(Piece.BLACK, new Cell(1, 4)), new Pawn(Piece.BLACK, new Cell(1, 5)), new Pawn(Piece.BLACK, new Cell(1, 6)), new Pawn(Piece.BLACK, new Cell(1, 7))],\r\n                [null, null, null, null, null, null, null, null],\r\n                [null, null, null, null, null, null, null, null],\r\n                [null, null, null, null, null, null, null, null],\r\n                [null, null, null, null, null, null, null, null],\r\n                [new Pawn(Piece.WHITE, new Cell(6, 0)), new Pawn(Piece.WHITE, new Cell(6, 1)), new Pawn(Piece.WHITE, new Cell(6, 2)), new Pawn(Piece.WHITE, new Cell(6, 3)), new Pawn(Piece.WHITE, new Cell(6, 4)), new Pawn(Piece.WHITE, new Cell(6, 5)), new Pawn(Piece.WHITE, new Cell(6, 6)), new Pawn(Piece.WHITE, new Cell(6, 7))],\r\n                [new Rook(Piece.WHITE, new Cell(7,0)), new Knight(Piece.WHITE, new Cell(7, 1)), new Bishop(Piece.WHITE, new Cell(7, 2)), new Queen(Piece.WHITE, new Cell(7, 3)), new King(Piece.WHITE, new Cell(7, 4)), new Bishop(Piece.WHITE, new Cell(7, 5)), new Knight(Piece.WHITE, new Cell(7, 6)), new Rook(Piece.WHITE, new Cell(7,7))],\r\n            ]\r\n            return startingBoard\r\n        }\r\n\r\n        deepCopyBoard = () => {\r\n\r\n        }\r\n\r\n        setBoardString = (boardString) => {\r\n            const newBoard = []\r\n            for (let row = 0; row < 8; row++) {\r\n                const newRow = []\r\n                for (let col = 0; col < 8; col++) {\r\n                    const pieceString = boardString[row][col]\r\n                    if (pieceString === null) {\r\n                        newRow.push(null)\r\n                    } else {\r\n                        const pieceColour = pieceString.slice(0, 1)\r\n                        const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\r\n                        const piece = pieceString.slice(1, 2)\r\n                        if (piece === \"b\") {\r\n                            newRow.push(new Bishop(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'k') {\r\n                            newRow.push(new King(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'n') {\r\n                            newRow.push(new Knight(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'p') {\r\n                            newRow.push(new Pawn(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'q') {\r\n                            newRow.push(new Queen(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'r') {\r\n                            newRow.push(new Rook(actualColour, new Cell(row, col)))\r\n                        } else {\r\n                            newRow.push(null)\r\n                        }\r\n                    }\r\n                }\r\n                newBoard.push(newRow)\r\n            }\r\n            this.board = newBoard\r\n        }\r\n\r\n        getBoardHash = () => {\r\n            let str = \"\"\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col)) {\r\n                        str += this.getPiece(row, col).getString()\r\n                    } else {\r\n                        str += \" \"\r\n                    }\r\n                }\r\n            }\r\n            return str\r\n        }\r\n\r\n        clonePiece = (piece) => {\r\n            if (piece instanceof Pawn) {\r\n                return new Pawn(piece.colour, new Cell(piece.cell.row, piece.cell.col))\r\n            } else if (piece instanceof Bishop) {\r\n                return new Bishop(piece.colour, new Cell(piece.cell.row, piece.cell.col))\r\n            } else if (piece instanceof King) {\r\n                return new King(piece.colour, new Cell(piece.cell.row, piece.cell.col))\r\n            } else if (piece instanceof Knight) {\r\n                return new Knight(piece.colour, new Cell(piece.cell.row, piece.cell.col))\r\n            } else if (piece instanceof Queen) {\r\n                return new Queen(piece.colour, new Cell(piece.cell.row, piece.cell.col))\r\n            } else if (piece instanceof Rook) {\r\n                return new Rook(piece.colour, new Cell(piece.cell.row, piece.cell.col))\r\n            }\r\n            return null\r\n        }\r\n\r\n        /**\r\n         * Returns the board represented by the array\r\n         */\r\n        getBoard = () => {\r\n            return this.board\r\n        }\r\n        /**\r\n         * Returns piece at the coordinates\r\n         */\r\n        getPiece = (row, col) => {\r\n            return this.board[row][col]\r\n        }\r\n\r\n        /**\r\n         * Returns if the cell is empty\r\n         */\r\n        isEmpty = (row, col) => {\r\n            if (this.isOutSide(row, col)) {\r\n                return false\r\n            }\r\n            return this.board[row][col] === null\r\n        }\r\n        isUnderCheck = (colour) => {\r\n            return false\r\n        }\r\n        isOutSide = (row, col) => {\r\n            return row < 0 || col < 0 || row > 7 || col > 7\r\n        }\r\n\r\n        canEat = (row, col, colour) => {\r\n            return !this.isOutSide(row, col) && !this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour\r\n        }\r\n\r\n        canEatDefend = (row, col) => {\r\n            return !this.isOutSide(row, col) && !this.isEmpty(row, col)\r\n        }\r\n\r\n        canMove = (row, col) => {\r\n            return !this.isOutSide(row, col) && this.isEmpty(row, col)\r\n        }\r\n\r\n        canKingMove = (row, col, colour) => {\r\n            const directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\r\n            for (const direction of directions) {\r\n                const newRow = row + direction[0]\r\n                const newCol = col + direction[1]\r\n                if (!this.isOutSide(newRow, newCol) && !this.isEmpty(newRow, newCol)\r\n                    && (this.getPiece(newRow, newCol).name === Piece.KING && this.getPiece(newRow, newCol).colour !== colour)) {\r\n                    return false\r\n                }\r\n            }\r\n            return true\r\n        }\r\n        /**\r\n         * Returns the squares, marked by moves, that are under attack by the opposing colour\r\n         * @param colour\r\n         * @return {*[]}\r\n         */\r\n        getAttackingSquares = (colour) => { // colour is for piece being attacked\r\n            const squares = []\r\n            const defense = []\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col)) {\r\n                        const getPc = this.getPiece(row, col)\r\n                        if (getPc.colour !== colour && !(getPc.name === Piece.KING)) {\r\n                            const moves = getPc.getAttack(this)\r\n                            squares.push.apply(squares, moves) // better performance\r\n                        }\r\n                    // else if (getPc.colour === colour && !(getPc instanceof King)) {\r\n                    //         const moves = getPc.getAttack(this)\r\n                    //         defense.push.apply(defense, moves) // TODO: may remove, performance\r\n                    //     }\r\n                    }\r\n                }\r\n            }\r\n            return [squares, defense]\r\n        }\r\n\r\n        movePiece = (piece, move) => {\r\n            const result =  this.board[move.oldCell.row][move.oldCell.col].movePiece(move, this)\r\n            this.moves.push(move)\r\n            return result\r\n        }\r\n\r\n        undoMove = () => {\r\n            if (this.moves.length > 0) {\r\n                const move = this.moves.pop()\r\n                const prevRow = move.oldCell.row\r\n                const prevCol = move.oldCell.col\r\n                const piece = this.board[move.newCell.row][move.newCell.col]\r\n                this.board[prevRow][prevCol] = piece\r\n                piece.moves.pop()\r\n                piece.cell.row = prevRow\r\n                piece.cell.col = prevCol\r\n                if (move.isEnPassant) { // add back pawn\r\n                    this.board[move.ate.cell.row][move.ate.cell.col] = move.ate\r\n                    this.board[move.newCell.row][move.newCell.col] = null\r\n                    return true\r\n                } else if (move.isPromotion) { // remove piece, add back pawn\r\n                    this.board[prevRow][prevCol] = new Pawn(piece.colour, piece.cell, piece.moves)\r\n                } else if (move.castle.isCastle) { // king will be undone, need to undo rook\r\n                    this.board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = move.castle.rook.piece\r\n                    move.castle.rook.piece.cell.row = move.castle.rook.oldCell.row\r\n                    move.castle.rook.piece.cell.col = move.castle.rook.oldCell.col\r\n                    this.board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = null\r\n                }\r\n                this.board[move.newCell.row][move.newCell.col] = move.ate\r\n                return true\r\n            }\r\n            return false\r\n        }\r\n\r\n        kingHasMoved = (colour) => {\r\n            for (const move of this.moves) {\r\n                if (move.piece.name === Piece.KING && move.piece.colour === colour) {\r\n                    return true\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        rookHasMoved = (colour, side) => {\r\n            const row = colour === Piece.BLACK ? 0 : 7\r\n            const col = side === King.KING_SIDE ? 7 : 0\r\n            if (!(this.getPiece(row, col) !== null && this.getPiece(row, col).name === Piece.ROOK)) { // no rook on cell\r\n                return true\r\n            }\r\n            for (const move of this.moves) {\r\n                if (move.piece.name === Piece.ROOK && move.piece.colour === colour && move.oldCell.row === row && move.oldCell.col === col) {\r\n                    return true\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        castlingSquaresIsEmpty = (colour, side) => {\r\n            const row = colour === Piece.BLACK ? 0 : 7\r\n            const cols = side === King.KING_SIDE ? [5,6] : [1,2,3]\r\n            for (const col of cols) {\r\n                if (!this.isEmpty(row, col)) {\r\n                    return false\r\n                }\r\n            }\r\n            return true\r\n        }\r\n        castlingSquaresUnderAttack = (colour, side, attacked) => { // includes the king himself\r\n            const row = colour === Piece.BLACK ? 0 : 7\r\n            const cols = side === King.KING_SIDE ? [4,5,6] : [1,2,3,4]\r\n            for (const col of cols) {\r\n                for (const move of attacked) {\r\n                    if (move.newCell.row === row && move.newCell.col === col) {\r\n                        return true\r\n                    }\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        canCastle = (colour, side, attacked) => {\r\n            return this.castlingSquaresIsEmpty(colour, side) && !this.castlingSquaresUnderAttack(colour, side, attacked)\r\n                && !this.rookHasMoved(colour, side) && !this.kingHasMoved(colour)\r\n        }\r\n\r\n        promotePiece = (piece) => {\r\n            const row = piece.cell.row\r\n            const col = piece.cell.col\r\n            this.board[row][col] = piece\r\n        }\r\n\r\n        // returns if colour is under check\r\n        isCheck = (colour, attackArray = null) => {\r\n            const attacked = attackArray === null ? this.getAttackingSquares(colour)[0] : attackArray\r\n            for (const move of attacked) {\r\n                const piece = this.getPiece(move.newCell.row, move.newCell.col)\r\n                if (piece !== null && piece.name === Piece.KING\r\n                    && piece.colour === colour) {\r\n                    return true\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        /**\r\n         * This functions determines if a move will result in your own King being under check (illegal move)\r\n         * @param piece\r\n         * @param move\r\n         */\r\n        willCheck = (piece, move) => {\r\n            this.movePiece(piece, move)\r\n            if (this.isCheck(piece.colour)) {\r\n                this.undoMove()\r\n                return true\r\n            }\r\n            this.undoMove()\r\n            return false\r\n        }\r\n        getAllMoves = (colour) => {\r\n            let moves = []\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.board[row][col]\r\n                    if (piece !== null && this.getPiece(row, col).colour === colour) {\r\n                        moves = moves.concat(this.getPiece(row, col).getMoves(this))\r\n                    }\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n\r\n        /**\r\n         * Defined by: same position occurs thrice for threefold repetition\r\n         * @param times\r\n         * @return {boolean}\r\n         */\r\n        isRepeatPosition = (numMoves) => {\r\n            const lengthCheck = numMoves\r\n            if (this.moves.length >= lengthCheck) {\r\n                const getLastNMoves = this.moves.slice(-lengthCheck)\r\n                let firstMove = getLastNMoves[0]\r\n                let secondMove = getLastNMoves[1]\r\n                for (let i = 2; i < lengthCheck; i+=4) {\r\n                    const current = getLastNMoves[i]\r\n                    const currentTwo = getLastNMoves[i+1]\r\n                    if (!(current.newCell.row === firstMove.oldCell.row && current.newCell.col === firstMove.oldCell.col && firstMove.piece === current.piece)) {\r\n                        return false\r\n                    }\r\n                    if (!(currentTwo.newCell.row === secondMove.oldCell.row && currentTwo.newCell.col === secondMove.oldCell.col && secondMove.piece === currentTwo.piece)) {\r\n                        return false\r\n                    }\r\n                }\r\n                return true\r\n            }\r\n            return false\r\n        }\r\n\r\n        /**\r\n         * Checks if game is over for colour, means other colour wins\r\n         * @param colour\r\n         * @return {{isGameOver: boolean, message: string}}\r\n         */\r\n        isGameOver = (colour) => {\r\n            const allMoves = this.getAllMoves(colour)\r\n            const player = colour === Piece.BLACK ? \"White\" : \"Black\"\r\n            if (allMoves.length <= 0) {\r\n                return {isGameOver: true, message: player + \" wins by checkmate\", allMoves: allMoves}\r\n            }\r\n            return {isGameOver: false, message: \"\", allMoves: allMoves}\r\n        }\r\n\r\n        getAllMoves = (colour) => {\r\n            let squares = []\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour === colour) {\r\n                        const piece = this.getPiece(row, col)\r\n                        const moves = piece.getMoves(this)\r\n                        squares = squares.concat(moves)\r\n                    }\r\n                }\r\n            }\r\n            return squares\r\n        }\r\n        /**\r\n         * Goes through board for positional eval, like piece development, hardcoded for black\r\n         */\r\n        scanSquaresScore = (colour) => {\r\n            let score = 0\r\n            let materialScore = 0\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            materialScore += piece.points\r\n                        } else {\r\n                            materialScore -= piece.points\r\n                        }\r\n                        // const moves = piece.getMoves(this)\r\n                        // //board control\r\n                        // score += moves.length\r\n                        // // piece mobility\r\n                        // if (piece instanceof Bishop) {\r\n                        //     score += (moves.length * 3)\r\n                        // } else if (piece instanceof Knight) {\r\n                        //     score += (moves.length * 3)\r\n                        // } else if (piece instanceof Queen) {\r\n                        //     score += (moves.length * 6)\r\n                        // } else if (piece instanceof Rook) {\r\n                        //     score += (moves.length * 5)\r\n                        // }\r\n\r\n                        // development / positional score\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            score += piece.whiteScore[row][col]\r\n                        } else {\r\n                            score -= piece.blackScore[row][col]\r\n                        }\r\n\r\n                        // double pawns bad for ai, but good if he doubles opponent's pawn\r\n                        if (piece.name === Piece.PAWN && piece.colour === Piece.WHITE) {\r\n                            if (!this.isEmpty(row + 1, col) && this.getPiece(row + 1, col).name === Piece.PAWN && piece.colour === Piece.WHITE) {\r\n                                score -= 20\r\n                            }\r\n                        } else if (piece.name === Piece.PAWN && piece.colour !== Piece.WHITE) {\r\n                            if (!this.isEmpty(row - 1, col) && this.getPiece(row - 1, col).name === Piece.PAWN && piece.colour !== Piece.WHITE) {\r\n                                score += 20\r\n                            }\r\n                        }\r\n                        // under check == bad, check opponent == good\r\n                        // if (piece.name === Piece.KING && piece.colour === colour) {\r\n                        //     if (this.isCheck(colour, attacked)) {\r\n                        //         score -= 10\r\n                        //     }\r\n                        // }\r\n                        // else if (piece instanceof King && piece.colour === opponentColour) {\r\n                        //     if (this.isCheck(opponentColour, attacked)) {\r\n                        //         score += 10\r\n                        //     }\r\n                        // }\r\n                    }\r\n                }\r\n            }\r\n            const total = score + materialScore\r\n            // if (this.board[3][4] instanceof Pawn && this.board[3][4].colour === Piece.WHITE\r\n            // && this.board) {\r\n            //     console.log(this.board)\r\n            // }\r\n            return total\r\n        }\r\n\r\n        /**\r\n         * used for minimax heuristics\r\n         * @param colour colour making the next move\r\n         * @return {number} score of position\r\n         */\r\n        getScore = (colour) => {\r\n            const opponentColour = colour === Piece.WHITE ? Piece.BLACK : Piece.WHITE\r\n            // let materialScore = 0 // material control\r\n            // for (let row = 0; row < 8; row ++) {\r\n            //     for (let col = 0; col < 8; col ++) {\r\n            //         const piece = this.board[row][col]\r\n            //         if (piece instanceof Piece && piece.colour === colour) {\r\n            //             materialScore += piece.points\r\n            //         }\r\n            //         if (piece instanceof Piece && piece.colour !== colour) {\r\n            //             materialScore -= piece.points\r\n            //         }\r\n            //     }\r\n            // }\r\n            // const attackedSquares = this.getAttackingSquares(opponentColour) // heavy operation\r\n            // const attackScore = attackedSquares[0].length // board control\r\n            // const defenseScore = attackedSquares[1].length // defense\r\n            const positionalScore = this.scanSquaresScore(colour)\r\n            return (positionalScore) * colour * -1\r\n        }\r\n\r\n        getBoardString = () => {\r\n            const newBoard = []\r\n            for (let row = 0; row < 8; row++) {\r\n                const newRow = []\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        newRow.push(piece.getString())\r\n                    } else {\r\n                        newRow.push(null)\r\n                    }\r\n                }\r\n                newBoard.push(newRow)\r\n            }\r\n            return newBoard\r\n        }\r\n\r\n    }\r\n    /**\r\n     * This class represents a coordinate on the chess board\r\n     */\r\n    class Cell {\r\n        constructor(row, col) {\r\n            this.row = row\r\n            this.col = col\r\n        }\r\n    }\r\n    class Game {\r\n        // game has a board, game has players, game has turns, game has time\r\n        turnColour = Piece.WHITE\r\n        constructor() {\r\n            this.board = new Board()\r\n            this.players = [new Player(Piece.WHITE), new Player(Piece.BLACK)]\r\n        }\r\n\r\n        movePiece = (piece, move) => {\r\n            const result =  this.board.movePiece(piece, move)\r\n            this.turnColour = this.turnColour === Piece.WHITE ? Piece.BLACK : Piece.WHITE\r\n            return result\r\n        }\r\n        /**\r\n         * Get pieces eaten by colour\r\n         * @param colour\r\n         * @return {*[]}\r\n         */\r\n        getEatenPieces = (colour) => {\r\n            const moves = this.board.moves\r\n            return moves.filter(move => {\r\n                return move.ate !== null && move.ate.colour !== colour\r\n            }).map(x => x.ate)\r\n        }\r\n\r\n        undoMove = () => {\r\n            const isUndo = this.board.undoMove()\r\n            if (isUndo) {\r\n                this.turnColour = this.turnColour === Piece.WHITE ? Piece.BLACK : Piece.WHITE\r\n            }\r\n        }\r\n\r\n    }\r\n    class Move {\r\n        oldCell\r\n        newCell\r\n\r\n        constructor(oldCell, newCell, piece, isEnPassant = false,\r\n                    castle = {isCastle: false}, ate = null, isPromotion = false) {\r\n            this.oldCell = oldCell\r\n            this.newCell = newCell\r\n            this.piece = piece\r\n            this.isEnPassant = isEnPassant\r\n            this.castle = castle\r\n            this.ate = ate\r\n            this.isPromotion = isPromotion\r\n        }\r\n\r\n        getMoveString = () => {\r\n            return {\r\n                oldCellRow: this.oldCell.row,\r\n                oldCellCol: this.oldCell.col,\r\n                newCellRow: this.newCell.row,\r\n                newCellCol: this.newCell.col,\r\n                pieceString: this.piece.getString(),\r\n                isEnPassant: this.isEnPassant,\r\n                castle: this.castle.isCastle === false ? {isCastle: false} : {isCastle: true,\r\n                    rook:{\r\n                    pieceString : this.castle.rook.piece.getString(),\r\n                    oldCellRow: this.castle.rook.oldCell.row,\r\n                    oldCellCol: this.castle.rook.oldCell.col,\r\n                    newCellRow: this.castle.rook.newCell.row,\r\n                    newCellCol: this.castle.rook.newCell.col,\r\n                }},\r\n                ate: this.ate !== null ? this.ate.getString() : null,\r\n                isPromotion: this.isPromotion\r\n            }\r\n        }\r\n        static parseMove = (board, data) => {\r\n            const parseMove = new Move(\r\n                new Cell(data.oldCellRow, data.oldCellCol),\r\n                new Cell(data.newCellRow, data.newCellCol),\r\n                Piece.parsePieceString(data.pieceString),\r\n                data.isEnPassant,\r\n                {isCastle: false}, // TODO : handle\r\n                null,\r\n                data.isPromotion\r\n            )\r\n\r\n            if (data.castle.isCastle) {\r\n                const rookObj = data.castle.rook\r\n                parseMove.castle.isCastle = true\r\n                parseMove.castle.rook = new Move(new Cell(rookObj.oldCellRow, rookObj.oldCellCol)\r\n                    , new Cell(rookObj.newCellRow, rookObj.newCellCol), board.getPiece(rookObj.oldCellRow, rookObj.oldCellCol))\r\n            }\r\n            return parseMove\r\n        }\r\n\r\n    }\r\n    class Piece {\r\n        static WHITE = -1\r\n        static BLACK = 1\r\n        static ROOK = \"r\"\r\n        static BISHOP = \"b\"\r\n        static KNIGHT = \"n\"\r\n        static KING = \"k\"\r\n        static QUEEN = \"q\"\r\n        static PAWN = \"p\"\r\n        isAlive = true\r\n        constructor(colour, cell, moves= []) {\r\n            this.colour = colour // white or black\r\n            this.cell = cell\r\n            this.moves = moves // moves made by the piece so far, [[startRow, startCol, endRow, endCol]], most recent at the back (can pop())\r\n        }\r\n        static parsePieceString = (pieceString) => {\r\n            const pieceColour = pieceString.slice(0, 1)\r\n            const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\r\n            const piece = pieceString.slice(1, 2)\r\n            if (piece === \"b\") {\r\n                return new Bishop(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'k') {\r\n                return new King(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'n') {\r\n                return new Knight(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'p') {\r\n                return new Pawn(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'q') {\r\n                return new Queen(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'r') {\r\n                return new Rook(actualColour, new Cell(0, 0))\r\n            } else {\r\n                return null\r\n            }\r\n        }\r\n    }\r\n    class Player {\r\n        // player has colour\r\n        constructor(colour) {\r\n            this.colour = colour\r\n        }\r\n    }\r\n    class Bishop extends Piece {\r\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1]]\r\n        points = 330\r\n        name = Piece.BISHOP\r\n        whiteScore = [\r\n            [-20,-10,-10,-10,-10,-10,-10,-20],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-10,  0,  5, 10, 10,  5,  0,-10],\r\n            [-10,  5,  5, 10, 10,  5,  5,-10],\r\n            [-10,  0, 10, 10, 10, 10,  0,-10],\r\n            [-10, 10, 10, 10, 10, 10, 10,-10],\r\n            [-10,  5,  0,  0,  0,  0,  5,-10],\r\n            [-20,-10,-10,-10,-10,-10,-10,-20]\r\n        ]\r\n        blackScore = [\r\n            [-20,-10,-10,-10,-10,-10,-10,-20],\r\n            [-10,  5,  0,  0,  0,  0,  5,-10],\r\n            [-10, 10, 10, 10, 10, 10, 10,-10],\r\n            [-10,  0, 10, 10, 10, 10,  0,-10],\r\n            [-10,  5,  5, 10, 10,  5,  5,-10],\r\n            [-10,  0,  5, 10, 10,  5,  0,-10],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-20,-10,-10,-10,-10,-10,-10,-20],\r\n        ]\r\n        constructor(colour, cell, moves) {\r\n            super(colour, cell, moves)\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\r\n                    if (!board.willCheck(this, move)) {\r\n                        moves.push(move)\r\n                    }\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        getAttack = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\r\n                    moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\r\n                    if (board.canEatDefend(newRow, newCol)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n            this.moves.push(move)\r\n\r\n            return {row: newRow, col: newCol}\r\n\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"b\"\r\n        }\r\n    }\r\n    class King extends Piece {\r\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\r\n        static KING_SIDE = 'king'\r\n        static QUEEN_SIDE = 'queen'\r\n        name = Piece.KING\r\n        points = 20000\r\n\r\n        whiteScore = [\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-20,-30,-30,-40,-40,-30,-30,-20],\r\n            [-10,-20,-20,-20,-20,-20,-20,-10],\r\n            [20, 20,  0,  0,  0,  0, 20, 20],\r\n            [20, 30, 10,  0,  0, 10, 30, 20]\r\n        ]\r\n\r\n        blackScore = [\r\n            [20, 30, 10,  0,  0, 10, 30, 20],\r\n            [20, 20,  0,  0,  0,  0, 20, 20],\r\n            [-10,-20,-20,-20,-20,-20,-20,-10],\r\n            [-20,-30,-30,-40,-40,-30,-30,-20],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n        ]\r\n        constructor(colour, cell, moves) {\r\n            super(colour, cell, moves)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            const attacked = board.getAttackingSquares(this.colour)[0]\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const newRow = row + currentRow\r\n                const newCol = col + currentCol\r\n                if (((board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol))) && board.canKingMove(newRow, newCol, this.colour)) {\r\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\r\n                    if (!board.willCheck(this, move)) {\r\n                        moves.push(move)\r\n                    }\r\n                }\r\n            }\r\n\r\n            const filterAttacked = moves.filter(move => { // king cannot move to squares under attack by enemy / pieces that are defended\r\n                for (const attack of attacked) {\r\n                    if (move.newCell.row === attack.newCell.row && move.newCell.col === attack.newCell.col) {\r\n                        return false\r\n                    }\r\n                }\r\n                return true\r\n            })\r\n            // castling move: if king has not moved + rook on respective square has not moved done\r\n            // + squares in between and king not attacked  + squares in between are empty\r\n            if (board.canCastle(this.colour, King.KING_SIDE, attacked)) {\r\n                const row = this.colour === Piece.BLACK ? 0 : 7\r\n                const col = 6\r\n                filterAttacked.push(new Move(this.cell, new Cell(row, col), this, false,\r\n                    {isCastle: true, rook: new Move(new Cell(row, 7), new Cell(row, 5), board.getPiece(row, 7))}))\r\n            }\r\n            if (board.canCastle(this.colour, King.QUEEN_SIDE, attacked)) {\r\n                const row = this.colour === Piece.BLACK ? 0 : 7\r\n                const col = 2\r\n                filterAttacked.push(new Move(this.cell, new Cell(row, col), this, false,\r\n                    {isCastle: true, rook: new Move(new Cell(row, 0), new Cell(row, 3), board.getPiece(row, 0))}))\r\n            }\r\n            return filterAttacked\r\n        }\r\n        getAttack = (board) => {\r\n            return this.getMoves(board)\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            if (move.castle.isCastle) {\r\n                board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = move.castle.rook.piece\r\n                board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = null\r\n                move.castle.rook.piece.cell.row = move.castle.rook.newCell.row\r\n                move.castle.rook.piece.cell.col = move.castle.rook.newCell.col\r\n            }\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n            this.moves.push(move)\r\n\r\n            return {row: newRow, col: newCol}\r\n\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"k\"\r\n        }\r\n    }\r\n    class Knight extends Piece {\r\n        directions = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\r\n\r\n        points = 320\r\n        name = Piece.KNIGHT\r\n\r\n        whiteScore = [\r\n            [-50,-40,-30,-30,-30,-30,-40,-50],\r\n            [-40,-20,  0,  0,  0,  0,-20,-40],\r\n            [-30,  0, 10, 15, 15, 10,  0,-30],\r\n            [-30,  5, 15, 20, 20, 15,  5,-30],\r\n            [-30,  0, 15, 20, 20, 15,  0,-30],\r\n            [-30,  5, 10, 15, 15, 10,  5,-30],\r\n            [-40,-20,  0,  5,  5,  0,-20,-40],\r\n            [-50,-40,-30,-30,-30,-30,-40,-50]\r\n        ]\r\n\r\n        blackScore = [\r\n            [-50,-40,-30,-30,-30,-30,-40,-50],\r\n            [-40,-20,  0,  5,  5,  0,-20,-40],\r\n            [-30,  5, 10, 15, 15, 10,  5,-30],\r\n            [-30,  0, 15, 20, 20, 15,  0,-30],\r\n            [-30,  5, 15, 20, 20, 15,  5,-30],\r\n            [-30,  0, 10, 15, 15, 10,  0,-30],\r\n            [-40,-20,  0,  0,  0,  0,-20,-40],\r\n            [-50,-40,-30,-30,-30,-30,-40,-50],\r\n        ]\r\n        constructor(colour, cell, moves) {\r\n            super(colour, cell, moves)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const newRow = row + currentRow\r\n                const newCol = col + currentCol\r\n                if (board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol)) {\r\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\r\n                    if (!board.willCheck(this, move)) {\r\n                        moves.push(move)\r\n                    }\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        getAttack = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const newRow = row + currentRow\r\n                const newCol = col + currentCol\r\n                if (board.canEatDefend(newRow, newCol) || board.canMove(newRow, newCol)) {\r\n                    moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n            this.moves.push(move)\r\n\r\n            return {row: newRow, col: newCol}\r\n\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"n\"\r\n        }\r\n    }\r\n    class Pawn extends Piece {\r\n        points = 100\r\n        name = Piece.PAWN\r\n\r\n        whiteScore = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5, -5,-10,  0,  0,-10, -5,  5],\r\n            [5, 10, 10,-20,-20, 10, 10,  5],\r\n            [0,  0,  0,  0,  0,  0,  0,  0]\r\n        ]\r\n        blackScore = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [5, 10, 10,-40,-40, 10, 10,  5],\r\n            [5, 10,20,  0,  0,-10, -5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n        ]\r\n        constructor(colour, cell, moves) {\r\n            super(colour, cell, moves)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            let newRow = this.cell.row + 1 * this.colour\r\n            let newCol = this.cell.col\r\n            if (board.canMove(newRow, newCol)) {\r\n                const move = new Move(this.cell, new Cell(newRow, newCol),\r\n                    this, undefined, undefined, undefined,\r\n                    newRow === 0 || newRow === 7)\r\n                if (!board.willCheck(this, move)) {\r\n                    moves.push(move)\r\n                }\r\n                newRow = this.cell.row + 2 * this.colour\r\n                if (board.canMove(newRow, newCol) && this.moves.length <= 0) {\r\n                    if (this.colour === Piece.BLACK && this.cell.row === 1) {\r\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\r\n                        if (!board.willCheck(this, move)) {\r\n                            moves.push(move)\r\n                        }\r\n                    } else if (this.colour === Piece.WHITE && this.cell.row === 6) {\r\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\r\n                        if (!board.willCheck(this, move)) {\r\n                            moves.push(move)\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n            newRow = this.cell.row + 1 * this.colour\r\n            newCol = this.cell.col + 1\r\n            if (board.canEat(newRow, newCol, this.colour)) {\r\n                const move = new Move(this.cell, new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\r\n                    newRow === 0 || newRow === 7)\r\n                if (!board.willCheck(this, move)) {\r\n                    moves.push(move)\r\n                }\r\n            }\r\n            // en passant\r\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\r\n                const prevMove = board.moves.slice(-1)[0]\r\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col + 1\r\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\r\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this, true)\r\n                    if (!board.willCheck(this, move)) {\r\n                        moves.push(move)\r\n                    }\r\n                }\r\n\r\n            }\r\n            newRow = this.cell.row + 1 * this.colour\r\n            newCol = this.cell.col - 1\r\n            if (board.canEat(newRow, newCol, this.colour)) {\r\n                const move = new Move(this.cell, new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\r\n                    newRow === 0 || newRow === 7)\r\n                if (!board.willCheck(this, move)) {\r\n                    moves.push(move)\r\n                }\r\n            }\r\n            // en passant\r\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\r\n                const prevMove = board.moves.slice(-1)[0]\r\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col - 1\r\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\r\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this, true)\r\n                    if (!board.willCheck(this, move)) {\r\n                        moves.push(move)\r\n                    }\r\n                }\r\n\r\n            }\r\n            return moves\r\n        }\r\n        getAttack = (board) => {\r\n            const moves = []\r\n            let newRow = this.cell.row + 1 * this.colour\r\n            let newCol = this.cell.col + 1\r\n            if (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\r\n                moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\r\n            }\r\n            newRow = this.cell.row + 1 * this.colour\r\n            newCol = this.cell.col - 1\r\n            if (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\r\n                moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\r\n            }\r\n            return moves\r\n        }\r\n        /**\r\n         * Moves the piece\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            // const old = board[move.oldCell.row][move.oldCell.col]\r\n            // promotion\r\n            if (move.isEnPassant) {\r\n                const prevMove = boardObject.moves.slice(-1)[0]\r\n                const oldPiece = board[prevMove.newCell.row][prevMove.newCell.col]\r\n                if (oldPiece !== null) {\r\n                    move.ate = oldPiece\r\n                }\r\n                board[prevMove.newCell.row][prevMove.newCell.col] = null\r\n            }\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n            if (move.isPromotion) {\r\n                board[newRow][newCol] = new Queen(this.colour, this.cell)\r\n                return {promotion: true, row: newRow, col: newCol}\r\n            }\r\n\r\n\r\n            this.moves.push(move)\r\n            return {row: newRow, col: newCol}\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"p\"\r\n        }\r\n    }\r\n    class Queen extends Piece {\r\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1], [0,1], [1,0], [0,-1],[-1,0]]\r\n        points = 900\r\n        name = Piece.QUEEN\r\n\r\n        whiteScore = [\r\n            [-20,-10,-10, -5, -5,-10,-10,-20],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-10,  0,  5,  5,  5,  5,  0,-10],\r\n            [-5,  0,  5,  5,  5,  5,  0, -5],\r\n            [0,  0,  5,  5,  5,  5,  0, -5],\r\n            [-10,  5,  5,  5,  5,  5,  0,-10],\r\n            [-10,  0,  5,  0,  0,  0,  0,-10],\r\n            [-20,-10,-10, -5, -5,-10,-10,-20]\r\n        ]\r\n        blackScore = [\r\n            [-20,-10,-10, -5, -5,-10,-10,-20],\r\n            [-10,  0,  5,  0,  0,  0,  0,-10],\r\n            [-10,  5,  5,  5,  5,  5,  0,-10],\r\n            [0,  0,  5,  5,  5,  5,  0, -5],\r\n            [-5,  0,  5,  5,  5,  5,  0, -5],\r\n            [-10,  0,  5,  5,  5,  5,  0,-10],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-20,-10,-10, -5, -5,-10,-10,-20],\r\n        ]\r\n        constructor(colour, cell, moves) {\r\n            super(colour, cell, moves)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\r\n                    if (!board.willCheck(this, move)) {\r\n                        moves.push(move)\r\n                    }\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        getAttack = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\r\n                    moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\r\n                    if (board.canEatDefend(newRow, newCol)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n            this.moves.push(move)\r\n\r\n            return {row: newRow, col: newCol}\r\n\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"q\"\r\n        }\r\n    }\r\n    class Rook extends Piece {\r\n        directions = [[0,1], [1,0], [0,-1],[-1,0]]\r\n        points = 500\r\n        name = Piece.ROOK\r\n        whiteScore = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [5, 10, 10, 10, 10, 10, 10,  5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [0,  0,  0,  5,  5,  0,  0,  0]\r\n        ]\r\n        blackScore = [\r\n            [0,  0,  4,  5,  5,  10,  0,  0],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [5, 10, 10, 10, 10, 10, 10,  5],\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n        ]\r\n        constructor(colour, cell, moves) {\r\n            super(colour, cell, moves)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\r\n                    if (!board.willCheck(this, move)) {\r\n                        moves.push(move)\r\n                    }\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        getAttack = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\r\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\r\n                    moves.push(move)\r\n                    if (board.canEatDefend(newRow, newCol)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n            this.moves.push(move)\r\n\r\n            return {row: newRow, col: newCol}\r\n\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"r\"\r\n        }\r\n    }\r\n\r\n        try {\r\n            const data = message.data\r\n            const nextMove = ab(data[0], data[1], data[2])\r\n\r\n            postMessage(nextMove.getMoveString())\r\n        } catch (e) {\r\n            postMessage({isError: true, message:\"Error: \" + e})\r\n        }\r\n\r\n\r\n\r\n\r\n}\r\n// eslint-disable-next-line no-restricted-globals,no-undef\r\nself.addEventListener(\"message\", test);\r\n"],"names":["totalMoves","mem","Map","self","addEventListener","async","message","nodes","evaluate","board","colour","getScore","switchColour","Piece","BLACK","WHITE","miniMax","depth","alpha","beta","isMax","maxPlayer","currentPlayer","quiesce","testGameOver","isGameOver","Number","MAX_VALUE","moves","allMoves","sort","sortMovesQuiesce","randomIndex","Math","floor","random","length","bestMove","maxEval","move","movePiece","piece","currentEval","undoMove","max","minEval","min","a","b","ate","points","evaluation","boardHash","getBoardHash","toString","has","get","set","getAllMoves","score","Board","constructor","this","newBoard","Rook","Cell","Knight","Bishop","Queen","King","Pawn","deepCopyBoard","setBoardString","boardString","row","newRow","col","pieceString","push","actualColour","slice","str","isEmpty","getPiece","getString","clonePiece","cell","getBoard","isOutSide","isUnderCheck","canEat","canEatDefend","canMove","canKingMove","directions","direction","newCol","name","KING","getAttackingSquares","squares","getPc","getAttack","apply","result","oldCell","pop","prevRow","prevCol","newCell","isEnPassant","isPromotion","castle","isCastle","rook","kingHasMoved","rookHasMoved","side","KING_SIDE","ROOK","castlingSquaresIsEmpty","cols","castlingSquaresUnderAttack","attacked","canCastle","promotePiece","isCheck","attackArray","willCheck","concat","getMoves","isRepeatPosition","numMoves","lengthCheck","getLastNMoves","firstMove","secondMove","i","current","currentTwo","player","scanSquaresScore","materialScore","whiteScore","blackScore","PAWN","total","getBoardString","Move","getMoveString","oldCellRow","oldCellCol","newCellRow","newCellCol","static","data","parseMove","parsePieceString","rookObj","isAlive","BISHOP","super","currentRow","currentCol","boardObject","oldPiece","filterAttacked","filter","attack","QUEEN_SIDE","KNIGHT","undefined","prevMove","abs","promotion","QUEEN","nextMove","moveString","copyBoard","map","x","ab","postMessage","e","isError"],"sourceRoot":""}