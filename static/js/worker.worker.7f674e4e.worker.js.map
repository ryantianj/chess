{"version":3,"file":"static/js/worker.worker.7f674e4e.worker.js","mappings":"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","sources":["Chess/ai/worker.worker.js"],"sourcesContent":["let totalMoves = 0\r\nconst test = async (message) => {\r\n   // https://chess.stackexchange.com/questions/40362/my-transposition-tables-implementation-slows-down-alpha-beta-pruning\r\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/negamax/tutorials/alpha-beta_quiescence_search/chess.c\r\n    //https://stackoverflow.com/questions/29990116/alpha-beta-prunning-with-transposition-table-iterative-deepening\r\n    // https://stackoverflow.com/questions/16500739/chess-high-branching-factor\r\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/bbc/collecting_pv/bbc.c\r\n    // https://github.com/kbjorklu/chess/blob/master/src/bitboard.js\r\n    //https://chess.stackexchange.com/questions/28160/moves-per-depth-in-search-engines\r\n    // Null move: https://web.archive.org/web/20071031095933/http://www.brucemo.com/compchess/programming/nullmove.htm\r\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/bbc/null_move_pruning/bbc.c\r\n    // TODO: check if endgame before running search, set score tables before search, done after set board string\r\n    // End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\r\n    // TODO: update piece score tables based on position before running search, done after set board string\r\n    // for knight, -5 per missing pawn of any colour\r\n    // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\r\n    // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\r\n    // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\r\n    const mem = new Map() // for killer moves\r\n    const MAX_DEPTH = 10\r\n    let whiteCanCastleKingSide = true\r\n    let whiteCanCastleQueenSide = true\r\n    let blackCanCastleKingSide = true\r\n    let blackCanCastleQueenSide = true\r\n    const pv_length = Array.from({length: MAX_DEPTH}, (x) => 0);\r\n    const pv_table = Array.from({length: MAX_DEPTH}, (x) => Array.from({length: MAX_DEPTH}, (x) => 0))\r\n    let currentPv = []\r\n    let startTime;\r\n    const MAX_TIME = 20000 // 20 seconds\r\n    const CHECK_THRESHOLD = 100000 // power of 2\r\n    let nodes = 0\r\n    let branch = 0\r\n    const NULL_MOVE_R = 2\r\n    const MAX_KILLER = 2\r\n    let isEndGame = false\r\n    const ab =  (boardString, depth, moveString, colour, pv) => {\r\n        let bestMove;\r\n        const copyBoard = new Board()\r\n        copyBoard.setBoardString(boardString)\r\n        copyBoard.moves = moveString.map(x => Move.parseMove(copyBoard, x))\r\n        // set pv from previous iteration\r\n        for (let i = 2; i < pv.length; i++) { // first two moves would have been made\r\n            pv_table[0][i - 2] = Move.parseMove(copyBoard, pv[i])\r\n        }\r\n        const prev = pv_table[0]\r\n        currentPv = [...prev]\r\n        isEndGame = copyBoard.isEndGame()\r\n        if (isEndGame) {\r\n            console.log(\"endgame\")\r\n            copyBoard.setEndGame()\r\n        }\r\n        copyBoard.updatePieceValues(totalMoves)\r\n        for (let i = 1; i < depth; i++) {\r\n            mem.set(i, [null, null, null]) // max number of killer moves\r\n        }\r\n        startTime = performance.now()\r\n        let result\r\n        for (let i = 1; i <= depth; i++) { // iterative deepening\r\n            result = miniMax(copyBoard, i, -Number.MAX_VALUE, Number.MAX_VALUE, colour, colour, mem, 0)\r\n            const currentEnd = performance.now()\r\n            if (currentEnd - startTime < MAX_TIME) { // did not run out of time\r\n                const prev = pv_table[0]\r\n                currentPv = [...prev]\r\n            }\r\n            bestMove = currentPv[0]\r\n            console.log(i, \"Score\", result[1], currentPv[0].newCell)\r\n        }\r\n        // result = miniMax(copyBoard, depth, -Number.MAX_VALUE, Number.MAX_VALUE, colour, colour, mem, 0)\r\n        const end = performance.now()\r\n        // console.log(end - start, totalMoves, nodes)\r\n        const arr = []\r\n        for (let i = 0; i < depth; i++) {\r\n            if (currentPv[i] === 0) {\r\n                break\r\n            }\r\n            arr.push(currentPv[i].getMoveString())\r\n            console.log(currentPv[i].getMoveString(), currentPv[i].getMoveString().ate)\r\n        }\r\n        console.log(end - startTime, nodes, branch)\r\n        // console.log(\"eval\", nodes)\r\n\r\n\r\n        return [bestMove.getMoveString(), arr] // should be a move\r\n    }\r\n\r\n    const miniMax = (board, depth, alpha, beta, maxPlayer, currentPlayer, mem, ply) => {\r\n        pv_length[ply] = ply\r\n        if (nodes % CHECK_THRESHOLD === 0) {\r\n            if (performance.now() - startTime > MAX_TIME) {\r\n                return [null, 0]\r\n            }\r\n        }\r\n        const moves = board.getAllMoves(currentPlayer) // TODO: time consuming\r\n        moveOrderRoot(moves, depth, ply)\r\n        let bestMove;\r\n        if (currentPlayer === maxPlayer) {\r\n            let maxEval = -90000\r\n            let legal = 0\r\n            for (let i = 0; i < moves.length; i++) {\r\n                const move = moves[i]\r\n                board.movePiece(move.piece, move)\r\n                if (board.isIllegal(currentPlayer, move)) {\r\n                    board.undoMove()\r\n\r\n                    continue\r\n                }\r\n                legal++\r\n                if (bestMove === undefined) {\r\n                    bestMove = move\r\n                }\r\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem, ply + 1, legal === 1)\r\n                board.undoMove()\r\n                if (currentEval > maxEval) {\r\n                    maxEval = currentEval\r\n                    bestMove = move\r\n                    pv_table[ply][ply] = move\r\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\r\n                        // copy move from deeper ply into a current ply's line\r\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\r\n                    }\r\n                    // adjust PV length\r\n                    pv_length[ply] = pv_length[ply + 1];\r\n                }\r\n                alpha = Math.max(alpha, currentEval)\r\n                if (beta <= alpha) {\r\n                    break\r\n                }\r\n            }\r\n            if (legal === 0) { // TODO: check stalemate\r\n                if (board.isCheck(currentPlayer)) {\r\n                    return [null, -90000]\r\n                }\r\n                return [null, 0]\r\n            }\r\n            return [bestMove, maxEval]\r\n        }\r\n    }\r\n    let isNullMove = false\r\n    const miniMaxCore = (board, depth, alpha, beta, maxPlayer, currentPlayer, prevMoves, mem, ply, isLeftMost) => {\r\n        if (nodes % CHECK_THRESHOLD === 0) {\r\n            if (performance.now() - startTime > MAX_TIME) {\r\n                return board.getScore(maxPlayer, prevMoves)\r\n            }\r\n        }\r\n        let branchLocal = 0\r\n        nodes++\r\n\r\n        pv_length[ply] = ply\r\n        if (depth <= 0) {\r\n            let result\r\n            if (maxPlayer === currentPlayer && !isNullMove && board.moves.slice(-1)[0].ate !== null) { // only for max player\r\n                result = quiesce(alpha, beta, board, currentPlayer, 2, prevMoves)\r\n            } else {\r\n                result = board.getScore(maxPlayer, prevMoves)\r\n            }\r\n            return result\r\n        }\r\n        if (depth >= 2 + NULL_MOVE_R && !isEndGame && !isNullMove && !board.isCheck(currentPlayer)) {\r\n            isNullMove = true\r\n            const nullMoveVal =  miniMaxCore(board, depth - 1 - NULL_MOVE_R, beta - 1, beta, maxPlayer, currentPlayer * -1, prevMoves, mem, ply + 1 + NULL_MOVE_R, false)\r\n            isNullMove = false\r\n            if (nullMoveVal >= beta) {\r\n                return beta\r\n            }\r\n        }\r\n        const moves = board.getAllMoves(currentPlayer) // TODO: time consuming\r\n        moveOrder(moves, mem, depth, ply, isLeftMost)\r\n        if (currentPlayer === maxPlayer) {\r\n            let maxEval = -30000\r\n            let legal = 0\r\n            for (let i = 0; i < moves.length; i++) {\r\n                const move = moves[i]\r\n                board.movePiece(move.piece, move)\r\n                if (board.isIllegal(currentPlayer, move)) {\r\n                    board.undoMove()\r\n                    continue\r\n                }\r\n                legal++\r\n                branchLocal++\r\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem, ply + 1, legal === 1)\r\n                board.undoMove()\r\n                if (currentEval > maxEval) {\r\n                    maxEval = currentEval\r\n                    pv_table[ply][ply] = move\r\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\r\n                        // copy move from deeper ply into a current ply's line\r\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\r\n                    }\r\n                    // adjust PV length\r\n                    pv_length[ply] = pv_length[ply + 1];\r\n                }\r\n                if (currentEval > alpha) {\r\n                    alpha = currentEval\r\n                }\r\n                if (beta <= alpha) {\r\n                    if (move.ate !== null) {\r\n                        break\r\n                    }\r\n                    const arr = mem.get(depth)\r\n                    if (arr.find(e => e!== null && isEqualMove(e, move))) {\r\n                        break\r\n                    }\r\n                    for (let j = MAX_KILLER - 2; j >= 0; j--) {\r\n                        arr[j + 1] = arr[j]\r\n                    }\r\n                    arr[0] = move\r\n                    break\r\n                }\r\n            }\r\n            branch = (branch + branchLocal) / 2\r\n            if (legal === 0) {\r\n                if (board.isCheck(currentPlayer)) {\r\n                    return -30000 * depth // faster checkmates\r\n                }\r\n                return 0 // stalemate\r\n            }\r\n            return maxEval\r\n        } else {\r\n            let minEval = 30000\r\n            let legal = 0\r\n            for (let i = 0; i < moves.length; i++) {\r\n                const move = moves[i]\r\n                board.movePiece(move.piece, move)\r\n                if (board.isIllegal(currentPlayer, move)) {\r\n                    board.undoMove()\r\n                    continue\r\n                }\r\n                legal++\r\n                branchLocal++\r\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, prevMoves, mem, ply +1, legal === 1)\r\n                board.undoMove()\r\n                if (currentEval < minEval) {\r\n                    minEval = currentEval\r\n                    pv_table[ply][ply] = move\r\n                    for (let next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++) {\r\n                        // copy move from deeper ply into a current ply's line\r\n                        pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];\r\n                    }\r\n                    // adjust PV length\r\n                    pv_length[ply] = pv_length[ply + 1];\r\n                }\r\n\r\n                if (currentEval < beta) {\r\n                    beta = currentEval\r\n                }\r\n                if (beta <= alpha) {\r\n                    if (move.ate !== null) {\r\n                        break\r\n                    }\r\n                    const arr = mem.get(depth)\r\n                    if (arr.find(e => e!== null && isEqualMove(e, move))) {\r\n                        break\r\n                    }\r\n                    for (let j = MAX_KILLER - 2; j >= 0; j--) {\r\n                        arr[j + 1] = arr[j]\r\n                    }\r\n                    arr[0] = move\r\n                    break\r\n                }\r\n            }\r\n            branch = (branch + branchLocal) / 2\r\n            if (legal === 0) {\r\n                if (board.isCheck(currentPlayer)) {\r\n                    return 30000 * depth\r\n                }\r\n                return 0\r\n\r\n            }\r\n            return minEval\r\n        }\r\n    }\r\n\r\n    const moveOrderRoot = (moves, depth, ply) => {\r\n        const sortMovesO = (a, b) => {\r\n            const pvMove = currentPv[ply]\r\n            if (pvMove !== 0 && isEqualMove(a, pvMove)) {\r\n                return -1\r\n            } else if (pvMove !== 0 && isEqualMove(b, pvMove)) {\r\n                return 1\r\n            }\r\n            if (a.castle.isCastle) {\r\n                return -1\r\n            }\r\n            if (b.castle.isCastle) {\r\n                return 1\r\n            }\r\n            if (a.ate !== null && b.ate !== null) {\r\n                const aScore = a.piece.points - a.ate.points\r\n                const bScore = b.piece.points - b.ate.points\r\n                return aScore < bScore ? -1: 1\r\n            } else {\r\n                if (a.ate !== null) {\r\n                    return -1\r\n                } else if (b.ate !== null) {\r\n                    return 1\r\n                }\r\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\r\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\r\n                return aScore < bScore ? 1: -1\r\n\r\n            }\r\n        }\r\n        moves.sort(sortMovesO)\r\n    }\r\n\r\n    const moveOrder = (moves, mem, depth, ply, isLeftMost) => {\r\n\r\n        const sortMovesO = (a, b) => {\r\n            const pvMove = currentPv[ply]\r\n            if (isLeftMost && pvMove !== 0) {\r\n                if (isEqualMove(a, pvMove)) {\r\n                    return -1\r\n                } else if (isEqualMove(b, pvMove)) {\r\n                    return 1\r\n                }\r\n            }\r\n            if (a.castle.isCastle) {\r\n                return -1\r\n            }\r\n            if (b.castle.isCastle) {\r\n                return 1\r\n            }\r\n            if (a.ate !== null && b.ate !== null) {\r\n                const aScore = a.piece.points - a.ate.points\r\n                const bScore = b.piece.points - b.ate.points\r\n                return aScore < bScore ? -1: 1\r\n            } else {\r\n                if (a.ate !== null) {\r\n                    return -1\r\n                } else if (b.ate !== null) {\r\n                    return 1\r\n                }\r\n                const memSlot = mem.get(depth)\r\n                for (let slot = 0; slot < memSlot.length; slot++) {\r\n                    const killerMove = memSlot[slot]\r\n                    if (killerMove !== null && isEqualMove(a, killerMove)) {\r\n                        return -1\r\n                    }\r\n                    if (killerMove !== null && isEqualMove(b, killerMove)) {\r\n                        return 1\r\n                    }\r\n                }\r\n\r\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\r\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\r\n                return aScore < bScore ? 1: -1\r\n\r\n            }\r\n        }\r\n        moves.sort(sortMovesO)\r\n    }\r\n\r\n    const isEqualMove = (a, b) => {\r\n        if (a.newCell.row === b.newCell.row && a.newCell.col === b.newCell.col && a.oldCell.row === b.oldCell.row && a.oldCell.col === b.oldCell.col && a.piece.constructor === b.piece.constructor) {\r\n            if (a.ate !== null && b.ate !== null) {\r\n                return a.ate.constructor === b.ate.constructor\r\n            }\r\n            return a.ate === b.ate\r\n        }\r\n        return false\r\n    }\r\n\r\n    const sortMoves = (a, b) => {\r\n        if (a.ate !== null && b.ate !== null) {\r\n            const aScore = a.piece.points - a.ate.points\r\n            const bScore = b.piece.points - b.ate.points\r\n            return aScore < bScore ? -1: 1\r\n        } else {\r\n            if (a.ate !== null) {\r\n                return -1\r\n            } else if (b.ate !== null) {\r\n                return 1\r\n            } else {\r\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\r\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\r\n                return aScore < bScore ? 1: -1\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    const quiesce = (alpha, beta, board, colour, depth, prevMoves) => {\r\n        const evaluation = board.getScore(colour, prevMoves)\r\n        if (depth === 0) {\r\n            return evaluation\r\n        }\r\n        if (evaluation >= beta) {\r\n            return beta\r\n        }\r\n\r\n        alpha = Math.max(alpha, evaluation)\r\n        const moves = board.getAllMoves(colour)\r\n        moves.sort(sortMoves)\r\n        for (let i = 0; i < moves.length; i++) {\r\n            const move = moves[i]\r\n            if (move.ate !== null) { //  && move.ate.points > move.piece.points\r\n                board.movePiece(move.piece, move)\r\n                let score = -quiesce(-beta, -alpha, board, colour * -1, depth - 1, prevMoves)\r\n                board.undoMove()\r\n                if (score >= beta) {\r\n                    return beta\r\n                }\r\n                if (score > alpha) {\r\n                    alpha = score\r\n                }\r\n            } else {\r\n                break\r\n            }\r\n        }\r\n        return alpha\r\n    }\r\n    //\r\n    // const quiesceOdd = (alpha, beta, board, colour, depth) => {\r\n    //     // const evaluation = evaluate(board, colour)\r\n    //     let evaluation\r\n    //     const boardHash = board.getBoardHash() + colour.toString()\r\n    //     if (mem.has(boardHash)) {\r\n    //         evaluation = mem.get(boardHash)\r\n    //     } else {\r\n    //         evaluation = evaluate(board, colour)\r\n    //         mem.set(boardHash, evaluation)\r\n    //     }\r\n    //\r\n    //     if (depth === 0) {\r\n    //         return evaluation\r\n    //     }\r\n    //     if (evaluation >= beta) {\r\n    //         return beta\r\n    //     }\r\n    //\r\n    //     alpha = Math.max(alpha, evaluation)\r\n    //     const moves = board.getAllMoves(colour)\r\n    //     moves.sort(sortMovesQuiesce)\r\n    //     for (const move of moves) {\r\n    //         if (move.ate !== null) { //  && move.ate.points > move.piece.points\r\n    //             board.movePiece(move.piece, move)\r\n    //             let score = -quiesce(-beta, -alpha, board, switchColour(colour), depth - 1)\r\n    //             board.undoMove()\r\n    //             if (score >= beta) {\r\n    //                 return beta\r\n    //             }\r\n    //             if (score > alpha) {\r\n    //                 alpha = score\r\n    //             }\r\n    //         }\r\n    //     }\r\n    //     return alpha\r\n    // }\r\n\r\n    // const negaMax = (depth, board, colour, maxColour) => {\r\n    //     if (depth === 0) {\r\n    //         return evaluate(board, maxColour)\r\n    //     }\r\n    //     const testGameOver = board.isGameOver(colour).isGameOver\r\n    //     if (testGameOver && colour === maxColour) {\r\n    //         return -Number.MAX_VALUE\r\n    //     }\r\n    //     if (testGameOver && colour !== maxColour) {\r\n    //         return Number.MAX_VALUE\r\n    //     }\r\n    //     let max = -Number.MAX_VALUE\r\n    //     const moves = board.getAllMoves(colour)\r\n    //     for (const move of moves) {\r\n    //         board.movePiece(move.piece, move)\r\n    //         const currentEval = -negaMax(depth - 1, board, switchColour(colour), maxColour)\r\n    //         if (currentEval > max) {\r\n    //             max = currentEval\r\n    //         }\r\n    //         board.undoMove()\r\n    //     }\r\n    //     return max\r\n    // }\r\n    // const rootNegaMax = (depth, board, colour, maxColour) => {\r\n    //     const rootMoves = board.getAllMoves(maxColour)\r\n    //     let max = -Number.MAX_VALUE\r\n    //     const randomIndex = Math.floor(Math.random() * (rootMoves.length - 1))\r\n    //     let bestMove = rootMoves.length > 0 ? rootMoves[randomIndex] : null\r\n    //     for (const move of rootMoves) {\r\n    //         board.movePiece(move.piece, move)\r\n    //         const score = negaMax(depth, board, colour, maxColour)\r\n    //         if (score > max) {\r\n    //             max = score\r\n    //             bestMove = move\r\n    //         }\r\n    //         board.undoMove()\r\n    //     }\r\n    //     return bestMove\r\n    //\r\n    // }\r\n    class Board {\r\n        board;\r\n\r\n        constructor() {\r\n            this.board = this.newBoard()\r\n            this.moves = []\r\n        }\r\n\r\n        newBoard = () => {\r\n            const startingBoard = [\r\n                [new Rook(Piece.BLACK, new Cell(0,0)), new Knight(Piece.BLACK, new Cell(0, 1)), new Bishop(Piece.BLACK, new Cell(0, 2)), new Queen(Piece.BLACK, new Cell(0, 3)), new King(Piece.BLACK, new Cell(0, 4)), new Bishop(Piece.BLACK, new Cell(0, 5)), new Knight(Piece.BLACK, new Cell(0, 6)), new Rook(Piece.BLACK, new Cell(0,7))],\r\n                [new Pawn(Piece.BLACK, new Cell(1, 0)), new Pawn(Piece.BLACK, new Cell(1, 1)), new Pawn(Piece.BLACK, new Cell(1, 2)), new Pawn(Piece.BLACK, new Cell(1, 3)), new Pawn(Piece.BLACK, new Cell(1, 4)), new Pawn(Piece.BLACK, new Cell(1, 5)), new Pawn(Piece.BLACK, new Cell(1, 6)), new Pawn(Piece.BLACK, new Cell(1, 7))],\r\n                [null, null, null, null, null, null, null, null],\r\n                [null, null, null, null, null, null, null, null],\r\n                [null, null, null, null, null, null, null, null],\r\n                [null, null, null, null, null, null, null, null],\r\n                [new Pawn(Piece.WHITE, new Cell(6, 0)), new Pawn(Piece.WHITE, new Cell(6, 1)), new Pawn(Piece.WHITE, new Cell(6, 2)), new Pawn(Piece.WHITE, new Cell(6, 3)), new Pawn(Piece.WHITE, new Cell(6, 4)), new Pawn(Piece.WHITE, new Cell(6, 5)), new Pawn(Piece.WHITE, new Cell(6, 6)), new Pawn(Piece.WHITE, new Cell(6, 7))],\r\n                [new Rook(Piece.WHITE, new Cell(7,0)), new Knight(Piece.WHITE, new Cell(7, 1)), new Bishop(Piece.WHITE, new Cell(7, 2)), new Queen(Piece.WHITE, new Cell(7, 3)), new King(Piece.WHITE, new Cell(7, 4)), new Bishop(Piece.WHITE, new Cell(7, 5)), new Knight(Piece.WHITE, new Cell(7, 6)), new Rook(Piece.WHITE, new Cell(7,7))],\r\n            ]\r\n            return startingBoard\r\n        }\r\n        // update piece square tables for endgame\r\n        setEndGame = () => {\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null && piece.whiteScoreEnd !== undefined) {\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            piece.whiteScore = piece.whiteScoreEnd\r\n                        } else {\r\n                            piece.blackScore = piece.blackScoreEnd\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // update values of pieces\r\n        updatePieceValues = (totalMoves) => {\r\n            // set if colour can castle here\r\n            if (this.kingHasMoved(Piece.WHITE)) {\r\n                whiteCanCastleKingSide = false\r\n                whiteCanCastleQueenSide = false\r\n            }\r\n            if (this.rookHasMoved(Piece.WHITE, King.KING_SIDE)) {\r\n                whiteCanCastleKingSide = false\r\n            }\r\n            if (this.rookHasMoved(Piece.WHITE, King.QUEEN_SIDE)) {\r\n                whiteCanCastleQueenSide = false\r\n            }\r\n            if (this.kingHasMoved(Piece.BLACK)) {\r\n                blackCanCastleKingSide = false\r\n                blackCanCastleQueenSide = false\r\n            }\r\n            if (this.rookHasMoved(Piece.BLACK, King.KING_SIDE)) {\r\n                blackCanCastleKingSide = false\r\n            }\r\n            if (this.rookHasMoved(Piece.BLACK, King.QUEEN_SIDE)) {\r\n                blackCanCastleQueenSide = false\r\n            }\r\n            const MOVE_THRESHOLD = 12\r\n            // for knight, -5 per missing pawn of any colour done\r\n            // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\r\n            // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\r\n            // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\r\n\r\n            let whitePawnCount = 0\r\n            let blackPawnCount = 0\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        if (piece instanceof Pawn) {\r\n                            if (piece.colour === Piece.WHITE) {\r\n                                whitePawnCount++\r\n                            } else {\r\n                                blackPawnCount++\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const openFiles = []\r\n            for (let col = 0; col < 8; col++) {\r\n                let hasPawn = false\r\n                for (let row = 0; row < 8; row++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        if (piece instanceof Pawn) {\r\n                            hasPawn = true\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n                if (!hasPawn) {\r\n                    openFiles.push(col)\r\n                }\r\n            }\r\n\r\n            // first ten moves, bad to move queen out, and encourage piece development\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        if (piece instanceof Queen) {\r\n                            if (totalMoves <= MOVE_THRESHOLD) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    piece.whiteScore[7][3]+=50\r\n                                } else {\r\n                                    piece.blackScore[0][3]+=50\r\n                                }\r\n                            }\r\n                        }\r\n                        if (piece instanceof Knight) {\r\n                            piece.points-= ((16 - whitePawnCount - blackPawnCount) * 3)\r\n                            if (totalMoves <= MOVE_THRESHOLD) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    piece.whiteScore[7][1]-=50\r\n                                    piece.whiteScore[7][6]-=50\r\n                                } else {\r\n                                    piece.blackScore[0][1]-=50\r\n                                    piece.blackScore[0][6]-=50\r\n                                }\r\n                            }\r\n                        }\r\n                        if (piece instanceof Bishop) {\r\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\r\n                            if (totalMoves <= MOVE_THRESHOLD) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    piece.whiteScore[7][2]-=50\r\n                                    piece.whiteScore[7][5]-=50\r\n                                } else {\r\n                                    piece.blackScore[0][2]-=50\r\n                                    piece.blackScore[0][5]-=50\r\n                                }\r\n                            }\r\n                        }\r\n                        if (piece instanceof Rook) {\r\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\r\n                            for (const openCol of openFiles) {\r\n                                for (let openRow = 0; openRow<8; openRow++) {\r\n                                    piece.whiteScore[openRow][openCol]+= 15\r\n                                    piece.blackScore[openRow][openCol]+= 15\r\n                                }\r\n                            }\r\n                        }\r\n                        if (piece instanceof Pawn) {\r\n                            let past = true\r\n                            if (col + 1 < 8) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    for (let i = row  - 1; i >= 0; i--) {\r\n                                        if (this.getPiece(i, col + 1) instanceof Pawn) {\r\n                                            past = false\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    for (let i = row + 1; i < 8; i++) {\r\n                                        if (this.getPiece(i, col + 1) instanceof Pawn) {\r\n                                            past = false\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                            }\r\n                            if (col < 8) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    for (let i = row  - 1; i >= 0; i--) {\r\n                                        if (this.getPiece(i, col) instanceof Pawn) {\r\n                                            past = false\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    for (let i = row + 1; i < 8; i++) {\r\n                                        if (this.getPiece(i, col) instanceof Pawn) {\r\n                                            past = false\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                            }\r\n                            if (col - 1 >= 0) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    for (let i = row  - 1; i >= 0; i--) {\r\n                                        if (this.getPiece(i, col - 1) instanceof Pawn) {\r\n                                            past = false\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    for (let i = row + 1; i < 8; i++) {\r\n                                        if (this.getPiece(i, col - 1) instanceof Pawn) {\r\n                                            past = false\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (past) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    piece.points+= (20 * (6 - row))\r\n                                } else {\r\n                                    piece.points+= (20 * (row - 1))\r\n                                }\r\n\r\n                            }\r\n                            let doubled = false\r\n                            for (let i = 0; i < 8; i++) {\r\n                                if (piece instanceof Pawn && i !== row) {\r\n                                    doubled = true\r\n                                }\r\n                            }\r\n                            if (doubled) {\r\n                                piece.points-=10\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        isEndGame = () => {\r\n            // End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\r\n            let countWhitePieces = 0\r\n            let countBlackPieces = 0\r\n            let countWhiteQueen = 0\r\n            let countBlackQueen = 0\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece instanceof Queen) {\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            countWhiteQueen++\r\n                        } else {\r\n                            countBlackQueen++\r\n                        }\r\n                    }\r\n                    if (piece instanceof Rook || piece instanceof Bishop || piece instanceof Knight) {\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            countWhitePieces++\r\n                        } else {\r\n                            countBlackPieces++\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return ((countWhiteQueen <= 1 && countWhitePieces <=1) || (countBlackQueen <= 1  && countBlackPieces <=1))\r\n                || ((countWhitePieces <=3 && countWhiteQueen <= 0) || (countBlackPieces <=3  && countBlackQueen <= 0))\r\n        }\r\n\r\n        setBoardString = (boardString) => {\r\n            const newBoard = []\r\n            for (let row = 0; row < 8; row++) {\r\n                const newRow = []\r\n                for (let col = 0; col < 8; col++) {\r\n                    const pieceString = boardString[row][col]\r\n                    if (pieceString === null) {\r\n                        newRow.push(null)\r\n                    } else {\r\n                        const pieceColour = pieceString.slice(0, 1)\r\n                        const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\r\n                        const piece = pieceString.slice(1, 2)\r\n                        if (piece === \"b\") {\r\n                            newRow.push(new Bishop(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'k') {\r\n                            newRow.push(new King(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'n') {\r\n                            newRow.push(new Knight(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'p') {\r\n                            newRow.push(new Pawn(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'q') {\r\n                            newRow.push(new Queen(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'r') {\r\n                            newRow.push(new Rook(actualColour, new Cell(row, col)))\r\n                        } else {\r\n                            newRow.push(null)\r\n                        }\r\n                    }\r\n                }\r\n                newBoard.push(newRow)\r\n            }\r\n            this.board = newBoard\r\n        }\r\n\r\n        getBoardHash = () => {\r\n            let str = \"\"\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col)) {\r\n                        str += this.getPiece(row, col).getString()\r\n                    } else {\r\n                        str += \" \"\r\n                    }\r\n                }\r\n            }\r\n            return str\r\n        }\r\n\r\n        /**\r\n         * Returns the board represented by the array\r\n         */\r\n        getBoard = () => {\r\n            return this.board\r\n        }\r\n        /**\r\n         * Returns piece at the coordinates\r\n         */\r\n        getPiece = (row, col) => {\r\n            return this.board[row][col]\r\n        }\r\n\r\n        /**\r\n         * Returns if the cell is empty\r\n         */\r\n        isEmpty = (row, col) => {\r\n            if (this.isOutSide(row, col)) {\r\n                return false\r\n            }\r\n            return this.board[row][col] === null\r\n        }\r\n        isUnderCheck = (colour) => {\r\n            return false\r\n        }\r\n        isOutSide = (row, col) => {\r\n            return row < 0 || col < 0 || row > 7 || col > 7\r\n        }\r\n\r\n        canEat = (row, col, colour) => {\r\n            return !this.isOutSide(row, col) && !this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour\r\n        }\r\n\r\n\r\n        canMove = (row, col) => {\r\n            return !this.isOutSide(row, col) && this.isEmpty(row, col)\r\n        }\r\n\r\n        canKingMove = (row, col, colour) => {\r\n            const directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\r\n            for (const direction of directions) {\r\n                const newRow = row + direction[0]\r\n                const newCol = col + direction[1]\r\n                if (!this.isOutSide(newRow, newCol) && !this.isEmpty(newRow, newCol)\r\n                    && (this.getPiece(newRow, newCol).name === Piece.KING && this.getPiece(newRow, newCol).colour !== colour)) {\r\n                    return false\r\n                }\r\n            }\r\n            return true\r\n        }\r\n\r\n        movePiece = (piece, move) => {\r\n            move.piece.movePiece(move, this)\r\n            this.moves.push(move)\r\n        }\r\n\r\n        undoMove = () => {\r\n            if (this.moves.length > 0) {\r\n                const move = this.moves.pop()\r\n                const prevRow = move.oldCell.row\r\n                const prevCol = move.oldCell.col\r\n                const piece = this.board[move.newCell.row][move.newCell.col]\r\n                this.board[prevRow][prevCol] = piece\r\n                piece.cell.row = prevRow\r\n                piece.cell.col = prevCol\r\n                if (move.isEnPassant) { // add back pawn\r\n                    this.board[move.ate.cell.row][move.ate.cell.col] = move.ate\r\n                    this.board[move.newCell.row][move.newCell.col] = null\r\n                    return true\r\n                } else if (move.isPromotion) { // remove piece, add back pawn\r\n                    this.board[prevRow][prevCol] = new Pawn(piece.colour, piece.cell, piece.moves)\r\n                } else if (move.castle.isCastle) { // king will be undone, need to undo rook\r\n                    this.board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = move.castle.rook.piece\r\n                    move.castle.rook.piece.cell.row = move.castle.rook.oldCell.row\r\n                    move.castle.rook.piece.cell.col = move.castle.rook.oldCell.col\r\n                    this.board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = null\r\n                }\r\n                this.board[move.newCell.row][move.newCell.col] = move.ate\r\n                return true\r\n            }\r\n            return false\r\n        }\r\n\r\n        kingHasMoved = (colour) => {\r\n            for (let i = 0; i < this.moves.length; i++) {\r\n                const move = this.moves[i]\r\n                if (move.piece.name === Piece.KING && move.piece.colour === colour) {\r\n                    return true\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        rookHasMoved = (colour, side) => {\r\n            const row = colour === Piece.BLACK ? 0 : 7\r\n            const col = side === King.KING_SIDE ? 7 : 0\r\n            if (!(this.getPiece(row, col) !== null && this.getPiece(row, col).name === Piece.ROOK)) { // no rook on cell\r\n                return true\r\n            }\r\n            for (const move of this.moves) {\r\n                if (move.piece.name === Piece.ROOK && move.piece.colour === colour && move.oldCell.row === row && move.oldCell.col === col) {\r\n                    return true\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        castlingSquaresIsEmpty = (colour, side) => {\r\n            const row = colour === Piece.BLACK ? 0 : 7\r\n            const cols = side === King.KING_SIDE ? [5,6] : [1,2,3]\r\n            for (const col of cols) {\r\n                if (!this.isEmpty(row, col)) {\r\n                    return false\r\n                }\r\n            }\r\n            return true\r\n        }\r\n\r\n        // returns if colour is under check, need check for castling\r\n        isIllegal = (colour, move) => {\r\n            // get colour king first\r\n            let king;\r\n            let kingCount = 0\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col)) {\r\n                        const piece = this.getPiece(row, col)\r\n                        if (piece.name === Piece.KING) {\r\n                            kingCount++\r\n                            if (piece.colour === colour) {\r\n                                king = piece\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (kingCount < 2) {\r\n                return true\r\n            }\r\n            if (move.castle.isCastle) {\r\n                const moves = this.getAllMoves(colour * -1)\r\n                const row = move.newCell.row\r\n                if (move.newCell.col === 6) { // kingside\r\n                    for (const opp of moves) {\r\n                        const moveRow = opp.newCell.row\r\n                        const moveCol = opp.newCell.col\r\n                        if (moveRow === row && (moveCol === 6 || moveCol === 5 || moveCol === 4)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (const opp of moves) { // queenside\r\n                        const moveRow = opp.newCell.row\r\n                        const moveCol = opp.newCell.col\r\n                        if (moveRow === row && (moveCol === 2 || moveCol === 3 || moveCol === 4)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour) {\r\n                        const piece = this.getPiece(row, col)\r\n                        if (piece.isCheck(this, king)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return false\r\n        }\r\n        // check if colour is under check\r\n        isCheck = (colour) => {\r\n            let king;\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col)) {\r\n                        const piece = this.getPiece(row, col)\r\n                        if (piece.name === Piece.KING) {\r\n                            if (piece.colour === colour) {\r\n                                king = piece\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour) {\r\n                        const piece = this.getPiece(row, col)\r\n                        if (piece.isCheck(this, king)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        /**\r\n         * Checks if game is over for colour, means other colour wins\r\n         * @param colour\r\n         * @return {*[]}\r\n         */\r\n\r\n        getAllMoves = (colour) => {\r\n            let squares = []\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour === colour) {\r\n                        const piece = this.getPiece(row, col)\r\n                        const moves = piece.getMoves(this)\r\n                        squares = squares.concat(moves)\r\n                    }\r\n                }\r\n            }\r\n            return squares\r\n        }\r\n        /**\r\n         * Goes through board for positional eval, like piece development, hardcoded for black\r\n         */\r\n        scanSquaresScore = () => {\r\n            let score = 0\r\n            let materialScore = 0\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        // material score\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            materialScore += piece.points\r\n                        } else {\r\n                            materialScore -= piece.points\r\n                        }\r\n\r\n                        // development / positional score\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            score += piece.whiteScore[row][col]\r\n                        } else {\r\n                            score -= piece.blackScore[row][col]\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return score + materialScore\r\n        }\r\n\r\n        /**\r\n         * used for minimax heuristics\r\n         * @param colour colour making the next move\r\n         * @param prevMoves total moves available\r\n         * @return {number} score of position\r\n         */\r\n        getScore = (colour, prevMoves) => {\r\n            const positionalScore = this.scanSquaresScore()\r\n            return (positionalScore + prevMoves.length * 3) * colour * -1\r\n        }\r\n\r\n        getBoardString = () => {\r\n            const newBoard = []\r\n            for (let row = 0; row < 8; row++) {\r\n                const newRow = []\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        newRow.push(piece.getString())\r\n                    } else {\r\n                        newRow.push(null)\r\n                    }\r\n                }\r\n                newBoard.push(newRow)\r\n            }\r\n            return newBoard\r\n        }\r\n\r\n    }\r\n    /**\r\n     * This class represents a coordinate on the chess board\r\n     */\r\n    class Cell {\r\n        constructor(row, col) {\r\n            this.row = row\r\n            this.col = col\r\n        }\r\n    }\r\n    class Move {\r\n        oldCell\r\n        newCell\r\n\r\n        constructor(oldCell, newCell, piece, isEnPassant = false,\r\n                    castle = {isCastle: false}, ate = null, isPromotion = false) {\r\n            this.oldCell = oldCell\r\n            this.newCell = newCell\r\n            this.piece = piece\r\n            this.isEnPassant = isEnPassant\r\n            this.castle = castle\r\n            this.ate = ate\r\n            this.isPromotion = isPromotion\r\n        }\r\n\r\n        getMoveString = () => {\r\n            return {\r\n                oldCellRow: this.oldCell.row,\r\n                oldCellCol: this.oldCell.col,\r\n                newCellRow: this.newCell.row,\r\n                newCellCol: this.newCell.col,\r\n                pieceString: this.piece.getString(),\r\n                isEnPassant: this.isEnPassant,\r\n                castle: this.castle.isCastle === false ? {isCastle: false} : {isCastle: true,\r\n                    rook:{\r\n                    pieceString : this.castle.rook.piece.getString(),\r\n                    oldCellRow: this.castle.rook.oldCell.row,\r\n                    oldCellCol: this.castle.rook.oldCell.col,\r\n                    newCellRow: this.castle.rook.newCell.row,\r\n                    newCellCol: this.castle.rook.newCell.col,\r\n                }},\r\n                ate: this.ate !== null ? this.ate.getString() : null,\r\n                isPromotion: this.isPromotion\r\n            }\r\n        }\r\n        static parseMove = (board, data) => {\r\n            const parseMove = new Move(\r\n                new Cell(data.oldCellRow, data.oldCellCol),\r\n                new Cell(data.newCellRow, data.newCellCol),\r\n                Piece.parsePieceString(data.pieceString),\r\n                data.isEnPassant,\r\n                {isCastle: false},\r\n                null,\r\n                data.isPromotion\r\n            )\r\n\r\n            if (data.castle.isCastle) {\r\n                const rookObj = data.castle.rook\r\n                parseMove.castle.isCastle = true\r\n                parseMove.castle.rook = new Move(new Cell(rookObj.oldCellRow, rookObj.oldCellCol)\r\n                    , new Cell(rookObj.newCellRow, rookObj.newCellCol), board.getPiece(rookObj.oldCellRow, rookObj.oldCellCol))\r\n            }\r\n            return parseMove\r\n        }\r\n\r\n    }\r\n    class Piece {\r\n        static WHITE = -1\r\n        static BLACK = 1\r\n        static ROOK = \"r\"\r\n        static BISHOP = \"b\"\r\n        static KNIGHT = \"n\"\r\n        static KING = \"k\"\r\n        static QUEEN = \"q\"\r\n        static PAWN = \"p\"\r\n        constructor(colour, cell) {\r\n            this.colour = colour // white or black\r\n            this.cell = cell\r\n        }\r\n        static parsePieceString = (pieceString) => {\r\n            const pieceColour = pieceString.slice(0, 1)\r\n            const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\r\n            const piece = pieceString.slice(1, 2)\r\n            if (piece === \"b\") {\r\n                return new Bishop(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'k') {\r\n                return new King(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'n') {\r\n                return new Knight(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'p') {\r\n                return new Pawn(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'q') {\r\n                return new Queen(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'r') {\r\n                return new Rook(actualColour, new Cell(0, 0))\r\n            } else {\r\n                return null\r\n            }\r\n        }\r\n    }\r\n\r\n    class Bishop extends Piece {\r\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1]]\r\n        points = 330\r\n        name = Piece.BISHOP\r\n        whiteScore = [\r\n            [-20,-10,-10,-10,-10,-10,-10,-20],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-10,  0,  5, 10, 10,  5,  0,-10],\r\n            [-10,  5,  5, 10, 10,  5,  5,-10],\r\n            [-10,  0, 10, 10, 10, 10,  0,-10],\r\n            [-10, 10, 10, 10, 10, 10, 10,-10],\r\n            [-10,  5,  0,  0,  0,  0,  5,-10],\r\n            [-20,-10,-10,-10,-10,-10,-10,-20]\r\n        ]\r\n        blackScore = [\r\n            [-20,-10,-10,-10,-10,-10,-10,-20],\r\n            [-10,  5,  0,  0,  0,  0,  5,-10],\r\n            [-10, 10, 10, 10, 10, 10, 10,-10],\r\n            [-10,  0, 10, 10, 10, 10,  0,-10],\r\n            [-10,  5,  5, 10, 10,  5,  5,-10],\r\n            [-10,  0,  5, 10, 10,  5,  0,-10],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-20,-10,-10,-10,-10,-10,-10,-20],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                    moves.push(move)\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        // check if piece is checking the enemy king\r\n        isCheck = (board, king) => {\r\n            const row = this.cell.row\r\n            const col = this.cell.col\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            const rowDiff = Math.abs(row - kingRow)\r\n            const colDiff = Math.abs(col - kingCol)\r\n            if (rowDiff !== colDiff) {\r\n                return false\r\n            }\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\r\n                            return true\r\n                        }\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return false\r\n\r\n        }\r\n\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"b\"\r\n        }\r\n    }\r\n    class King extends Piece {\r\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\r\n        static KING_SIDE = -1\r\n        static QUEEN_SIDE = 1\r\n        name = Piece.KING\r\n        points = 10000\r\n\r\n        whiteScore = [\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-20,-30,-30,-40,-40,-30,-30,-20],\r\n            [-10,-20,-20,-20,-20,-20,-20,-10],\r\n            [20, 20,  0,  0,  0,  0, 20, 20],\r\n            [20, 30, 10,  0,  0, 10, 30, 20]\r\n        ]\r\n\r\n        blackScore = [\r\n            [20, 30, 10,  0,  0, 10, 30, 20],\r\n            [20, 20,  0,  0,  0,  0, 20, 20],\r\n            [-10,-20,-20,-20,-20,-20,-20,-10],\r\n            [-20,-30,-30,-40,-40,-30,-30,-20],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n        ]\r\n        whiteScoreEnd = [\r\n            [-50,-40,-30,-20,-20,-30,-40,-50],\r\n            [-30,-20,-10,  0,  0,-10,-20,-30],\r\n            [-30,-10, 20, 30, 30, 20,-10,-30],\r\n            [-30,-10, 30, 40, 40, 30,-10,-30],\r\n            [-30,-10, 30, 40, 40, 30,-10,-30],\r\n            [-30,-10, 20, 30, 30, 20,-10,-30],\r\n            [-30,-30,  0,  0,  0,  0,-30,-30],\r\n            [-50,-30,-30,-30,-30,-30,-30,-50]\r\n        ]\r\n        blackScoreEnd = [\r\n            [-50,-30,-30,-30,-30,-30,-30,-50],\r\n            [-30,-30,  0,  0,  0,  0,-30,-30],\r\n            [-30,-10, 20, 30, 30, 20,-10,-30],\r\n            [-30,-10, 30, 40, 40, 30,-10,-30],\r\n            [-30,-10, 30, 40, 40, 30,-10,-30],\r\n            [-30,-10, 20, 30, 30, 20,-10,-30],\r\n            [-30,-20,-10,  0,  0,-10,-20,-30],\r\n            [-50,-40,-30,-20,-20,-30,-40,-50],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                const newRow = row + currentRow\r\n                const newCol = col + currentCol\r\n                if (((board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol))) && board.canKingMove(newRow, newCol, this.colour)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                    moves.push(move)\r\n                }\r\n            }\r\n            const canCastleKingSide = this.colour === Piece.WHITE ? whiteCanCastleKingSide : blackCanCastleKingSide\r\n            const canCastleQueenSide = this.colour === Piece.WHITE ? whiteCanCastleQueenSide : blackCanCastleQueenSide\r\n            // king and rook has not moved, illegal check later\r\n            if (canCastleKingSide && board.castlingSquaresIsEmpty(this.colour, King.KING_SIDE) && !board.rookHasMoved(this.colour, King.KING_SIDE) && !board.kingHasMoved(this.colour)) {\r\n                const row = this.colour === Piece.BLACK ? 0 : 7\r\n                const col = 6\r\n                moves.push(new Move(new Cell(currentRow, currentCol), new Cell(row, col), this, false,\r\n                    {isCastle: true, rook: new Move(new Cell(row, 7), new Cell(row, 5), board.getPiece(row, 7))}))\r\n            }\r\n            if (canCastleQueenSide && board.castlingSquaresIsEmpty(this.colour, King.QUEEN_SIDE) && !board.rookHasMoved(this.colour, King.QUEEN_SIDE) && !board.kingHasMoved(this.colour)) {\r\n                const row = this.colour === Piece.BLACK ? 0 : 7\r\n                const col = 2\r\n                moves.push(new Move(new Cell(currentRow, currentCol), new Cell(row, col), this, false,\r\n                    {isCastle: true, rook: new Move(new Cell(row, 0), new Cell(row, 3), board.getPiece(row, 0))}))\r\n            }\r\n\r\n\r\n            return moves\r\n        }\r\n        // check if piece is checking the enemy king\r\n        isCheck = (board, king) => {\r\n            return false\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            if (move.castle.isCastle) {\r\n                board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = move.castle.rook.piece\r\n                board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = null\r\n                move.castle.rook.piece.cell.row = move.castle.rook.newCell.row\r\n                move.castle.rook.piece.cell.col = move.castle.rook.newCell.col\r\n            }\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"k\"\r\n        }\r\n    }\r\n    class Knight extends Piece {\r\n        directions = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\r\n\r\n        points = 320\r\n        name = Piece.KNIGHT\r\n\r\n        whiteScore = [\r\n            [-50,-40,-30,-30,-30,-30,-40,-50],\r\n            [-40,-20,  0,  0,  0,  0,-20,-40],\r\n            [-30,  0, 10, 15, 15, 10,  0,-30],\r\n            [-30,  5, 15, 20, 20, 15,  5,-30],\r\n            [-30,  0, 15, 20, 20, 15,  0,-30],\r\n            [-30,  5, 10, 15, 15, 10,  5,-30],\r\n            [-40,-20,  0,  5,  5,  0,-20,-40],\r\n            [-50,-40,-30,-30,-30,-30,-40,-50]\r\n        ]\r\n\r\n        blackScore = [\r\n            [-50,-40,-30,-30,-30,-30,-40,-50],\r\n            [-40,-20,  0,  5,  5,  0,-20,-40],\r\n            [-30,  5, 10, 15, 15, 10,  5,-30],\r\n            [-30,  0, 15, 20, 20, 15,  0,-30],\r\n            [-30,  5, 15, 20, 20, 15,  5,-30],\r\n            [-30,  0, 10, 15, 15, 10,  0,-30],\r\n            [-40,-20,  0,  0,  0,  0,-20,-40],\r\n            [-50,-40,-30,-30,-30,-30,-40,-50],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const newRow = row + currentRow\r\n                const newCol = col + currentCol\r\n                if (board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                    moves.push(move)\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        // check if piece is checking the enemy king\r\n        isCheck = (board, king) => {\r\n            const row = this.cell.row\r\n            const col = this.cell.col\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            const rowDiff = Math.abs(row - kingRow)\r\n            const colDiff = Math.abs(col - kingCol)\r\n            if (rowDiff + colDiff !== 3) {\r\n                return false\r\n            }\r\n            return !(rowDiff === 0 || colDiff === 0);\r\n\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"n\"\r\n        }\r\n    }\r\n    class Pawn extends Piece {\r\n        points = 100\r\n        name = Piece.PAWN\r\n\r\n        whiteScore = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5, -5,-10,  0,  0,-10, -5,  5],\r\n            [5, 10, 10,-20,-20, 10, 10,  5],\r\n            [0,  0,  0,  0,  0,  0,  0,  0]\r\n        ]\r\n        whiteScoreEnd = [\r\n            [100,  100,  100,  100,  100,  100,  100,  100],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5, -5,-10,  0,  0,-10, -5,  5],\r\n            [5, 10, 10,-20,-20, 10, 10,  5],\r\n            [0,  0,  0,  0,  0,  0,  0,  0]\r\n        ]\r\n        blackScore = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [5, 10, 10,-40,-40, 10, 10,  5],\r\n            [5, 10,20,  0,  0,-10, -5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n        ]\r\n        blackScoreEnd = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [5, 10, 10,-40,-40, 10, 10,  5],\r\n            [5, 10,20,  0,  0,-10, -5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [100,  100,  100,  100,  100,  100,  100,  100],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            const moves = []\r\n            let newRow = this.cell.row + 1 * this.colour\r\n            let newCol = this.cell.col\r\n            if (board.canMove(newRow, newCol)) {\r\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol),\r\n                    this, undefined, undefined, undefined,\r\n                    newRow === 0 || newRow === 7)\r\n                    moves.push(move)\r\n\r\n                newRow = this.cell.row + 2 * this.colour\r\n                if (board.canMove(newRow, newCol) && (newRow === 3 || newRow === 4)) {\r\n                    if (this.colour === Piece.BLACK && this.cell.row === 1) {\r\n                        const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n\r\n                            moves.push(move)\r\n\r\n                    } else if (this.colour === Piece.WHITE && this.cell.row === 6) {\r\n                        const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                            moves.push(move)\r\n                    }\r\n\r\n                }\r\n            }\r\n            newRow = this.cell.row + 1 * this.colour\r\n            newCol = this.cell.col + 1\r\n            if (board.canEat(newRow, newCol, this.colour)) {\r\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\r\n                    newRow === 0 || newRow === 7)\r\n                    moves.push(move)\r\n            }\r\n            // en passant\r\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\r\n                const prevMove = board.moves.slice(-1)[0]\r\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col + 1\r\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this, true)\r\n                        moves.push(move)\r\n                }\r\n\r\n            }\r\n            newRow = this.cell.row + 1 * this.colour\r\n            newCol = this.cell.col - 1\r\n            if (board.canEat(newRow, newCol, this.colour)) {\r\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\r\n                    newRow === 0 || newRow === 7)\r\n                    moves.push(move)\r\n            }\r\n            // en passant\r\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\r\n                const prevMove = board.moves.slice(-1)[0]\r\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col - 1\r\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this, true)\r\n                    moves.push(move)\r\n                }\r\n\r\n            }\r\n            return moves\r\n        }\r\n        isCheck = (board, king) => {\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            const newRow = this.cell.row + 1 * this.colour\r\n            const newCol = this.cell.col + 1\r\n            const newColOpp = this.cell.col - 1\r\n            return newRow === kingRow && (newCol === kingCol || newColOpp === kingCol)\r\n        }\r\n\r\n        /**\r\n         * Moves the piece\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            // const old = board[move.oldCell.row][move.oldCell.col]\r\n            // promotion\r\n            if (move.isEnPassant) {\r\n                const prevMove = boardObject.moves.slice(-1)[0]\r\n                const oldPiece = board[prevMove.newCell.row][prevMove.newCell.col]\r\n                if (oldPiece !== null) {\r\n                    move.ate = oldPiece\r\n                }\r\n                board[prevMove.newCell.row][prevMove.newCell.col] = null\r\n            }\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n            if (move.isPromotion) {\r\n                board[newRow][newCol] = new Queen(this.colour, this.cell)\r\n            }\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"p\"\r\n        }\r\n    }\r\n    class Queen extends Piece {\r\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1], [0,1], [1,0], [0,-1],[-1,0]]\r\n        points = 900\r\n        name = Piece.QUEEN\r\n\r\n        whiteScore = [\r\n            [-20,-10,-10, -5, -5,-10,-10,-20],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-10,  0,  5,  5,  5,  5,  0,-10],\r\n            [-5,  0,  5,  5,  5,  5,  0, -5],\r\n            [0,  0,  5,  5,  5,  5,  0, -5],\r\n            [-10,  5,  5,  5,  5,  5,  0,-10],\r\n            [-10,  0,  5,  0,  0,  0,  0,-10],\r\n            [-20,-10,-10, -5, -5,-10,-10,-20]\r\n        ]\r\n        blackScore = [\r\n            [-20,-10,-10, -5, -5,-10,-10,-20],\r\n            [-10,  0,  5,  0,  0,  0,  0,-10],\r\n            [-10,  5,  5,  5,  5,  5,  0,-10],\r\n            [0,  0,  5,  5,  5,  5,  0, -5],\r\n            [-5,  0,  5,  5,  5,  5,  0, -5],\r\n            [-10,  0,  5,  5,  5,  5,  0,-10],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-20,-10,-10, -5, -5,-10,-10,-20],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                        moves.push(move)\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        isCheck = (board, king) => {\r\n            const row = this.cell.row\r\n            const col = this.cell.col\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            const rowDiff = Math.abs(row - kingRow)\r\n            const colDiff = Math.abs(col - kingCol)\r\n            if ((rowDiff !== colDiff) && kingCol !== col && kingRow !== row) {\r\n                return false\r\n            }\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\r\n                            return true\r\n                        }\r\n                        break;\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return false\r\n\r\n        }\r\n\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"q\"\r\n        }\r\n    }\r\n    class Rook extends Piece {\r\n        directions = [[0,1], [1,0], [0,-1],[-1,0]]\r\n        points = 500\r\n        name = Piece.ROOK\r\n        whiteScore = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [5, 10, 10, 10, 10, 10, 10,  5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [0,  0,  0,  5,  5,  0,  0,  0]\r\n        ]\r\n        blackScore = [\r\n            [0,  0,  4,  5,  5,  10,  0,  0],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [5, 10, 10, 10, 10, 10, 10,  5],\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                        moves.push(move)\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        isCheck = (board, king) => {\r\n            const row = this.cell.row\r\n            const col = this.cell.col\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            if (kingCol !== col && kingRow !== row) {\r\n                return false\r\n            }\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\r\n                            return true\r\n                        }\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return false\r\n\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"r\"\r\n        }\r\n    }\r\n\r\n        // try {\r\n            const data = message.data\r\n            const boardString = data[0]\r\n            const depth = data[1]\r\n            const moveString = data[2]\r\n            const colour = data[3]\r\n            const pv = data[4]\r\n            totalMoves = moveString.length\r\n            if (totalMoves === 0) {\r\n                if (colour === Piece.WHITE) {\r\n                    // equal chance to play d4, e4\r\n                    const moves = [\r\n                        new Move(new Cell(6, 3), new Cell(4,3), new Pawn(Piece.WHITE, new Cell(6, 3))),\r\n                        new Move(new Cell(6, 4), new Cell(4,4), new Pawn(Piece.WHITE, new Cell(6, 4))),\r\n                    ]\r\n                    const randomIndex = Math.round(Math.random() * (moves.length - 1))\r\n\r\n                    postMessage([moves[randomIndex].getMoveString(), pv])\r\n                }\r\n            } else if (totalMoves === 1) {\r\n                // equal chance to play c5 / e5, in response to e4\r\n                const getMove = moveString.map(x => Move.parseMove(undefined, x))[0]\r\n                if (getMove.oldCell.row === 6 && getMove.oldCell.col === 4 && getMove.newCell.row === 4 && getMove.newCell.col === 4) {\r\n                    const moves = [\r\n                        new Move(new Cell(1, 2), new Cell(3,2), new Pawn(Piece.BLACK, new Cell(1, 2))),\r\n                        new Move(new Cell(1, 4), new Cell(3,4), new Pawn(Piece.BLACK, new Cell(1, 4))),\r\n                    ]\r\n                    const randomIndex = Math.round(Math.random() * (moves.length - 1))\r\n\r\n                    postMessage([moves[randomIndex].getMoveString(), pv])\r\n                } else {\r\n                    const nextMove = ab(boardString, depth, moveString, colour, pv)\r\n                    postMessage(nextMove)\r\n                }\r\n            } else {\r\n                const nextMove = ab(boardString, depth, moveString, colour, pv)\r\n                postMessage(nextMove)\r\n            }\r\n        // } catch (e) {\r\n        //     postMessage([{isError: true, message:\"Error: \" + e}])\r\n        // }\r\n\r\n}\r\n// eslint-disable-next-line no-restricted-globals,no-undef\r\nself.addEventListener(\"message\", test);\r\n"],"names":["totalMoves","self","addEventListener","async","message","mem","Map","whiteCanCastleKingSide","whiteCanCastleQueenSide","blackCanCastleKingSide","blackCanCastleQueenSide","pv_length","Array","from","length","x","pv_table","startTime","currentPv","MAX_TIME","CHECK_THRESHOLD","nodes","branch","isEndGame","ab","boardString","depth","moveString","colour","pv","bestMove","copyBoard","Board","setBoardString","moves","map","Move","parseMove","i","prev","console","log","setEndGame","updatePieceValues","set","result","performance","now","miniMax","Number","MAX_VALUE","newCell","end","arr","push","getMoveString","ate","board","alpha","beta","maxPlayer","currentPlayer","ply","getAllMoves","moveOrderRoot","maxEval","legal","move","movePiece","piece","isIllegal","undoMove","undefined","currentEval","miniMaxCore","next_ply","Math","max","isCheck","isNullMove","prevMoves","isLeftMost","getScore","branchLocal","slice","quiesce","nullMoveVal","moveOrder","get","find","e","isEqualMove","j","MAX_KILLER","minEval","sort","a","b","pvMove","castle","isCastle","points","Piece","WHITE","whiteScore","row","col","blackScore","memSlot","slot","killerMove","oldCell","constructor","sortMoves","evaluation","score","this","newBoard","Rook","BLACK","Cell","Knight","Bishop","Queen","King","Pawn","getPiece","whiteScoreEnd","blackScoreEnd","kingHasMoved","rookHasMoved","KING_SIDE","QUEEN_SIDE","whitePawnCount","blackPawnCount","openFiles","hasPawn","openCol","openRow","past","doubled","countWhitePieces","countBlackPieces","countWhiteQueen","countBlackQueen","newRow","pieceString","actualColour","getBoardHash","str","isEmpty","getString","getBoard","isOutSide","isUnderCheck","canEat","canMove","canKingMove","directions","direction","newCol","name","KING","pop","prevRow","prevCol","cell","isEnPassant","isPromotion","rook","side","ROOK","castlingSquaresIsEmpty","cols","king","kingCount","opp","moveRow","moveCol","squares","getMoves","concat","scanSquaresScore","materialScore","getBoardString","oldCellRow","oldCellCol","newCellRow","newCellCol","static","data","parsePieceString","rookObj","BISHOP","super","currentRow","currentCol","kingRow","kingCol","abs","boardObject","oldPiece","canCastleKingSide","canCastleQueenSide","KNIGHT","rowDiff","colDiff","PAWN","prevMove","newColOpp","QUEEN","randomIndex","round","random","postMessage","getMove","nextMove"],"sourceRoot":""}