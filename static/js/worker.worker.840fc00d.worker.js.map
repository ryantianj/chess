{"version":3,"file":"static/js/worker.worker.840fc00d.worker.js","mappings":"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","sources":["Chess/ai/worker.worker.js"],"sourcesContent":["let totalMoves = 0\r\nconst test = async (message) => {\r\n   // https://chess.stackexchange.com/questions/40362/my-transposition-tables-implementation-slows-down-alpha-beta-pruning\r\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/negamax/tutorials/alpha-beta_quiescence_search/chess.c\r\n    //https://stackoverflow.com/questions/29990116/alpha-beta-prunning-with-transposition-table-iterative-deepening\r\n    // https://stackoverflow.com/questions/16500739/chess-high-branching-factor\r\n    // TODO: check if endgame before running search, set score tables before search, done after set board string\r\n    // End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\r\n    // TODO: update piece score tables based on position before running search, done after set board string\r\n    // for knight, -5 per missing pawn of any colour\r\n    // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\r\n    // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\r\n    // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\r\n    const mem = new Map() // for killer moves\r\n    const ab =  (boardString, depth, moveString, colour) => {\r\n        const copyBoard = new Board()\r\n        copyBoard.setBoardString(boardString)\r\n        // const start = performance.now()\r\n        copyBoard.moves = moveString.map(x => Move.parseMove(copyBoard, x))\r\n        const isEndGame = copyBoard.isEndGame()\r\n        if (isEndGame) {\r\n            console.log(\"endgame\")\r\n            copyBoard.setEndGame()\r\n        }\r\n        copyBoard.updatePieceValues(totalMoves)\r\n        for (let i = 1; i < depth; i++) {\r\n            mem.set(i, [null, null, null]) // max number of killer moves\r\n        }\r\n        const result = miniMax(copyBoard, depth, -Number.MAX_VALUE, Number.MAX_VALUE, colour, colour, mem)\r\n        // const result = rootNegaMax(depth, copyBoard, Piece.BLACK, Piece.BLACK)\r\n        // const end = performance.now()\r\n        // console.log(end - start, totalMoves, nodes)\r\n        // console.log(\"eval\", nodes)\r\n        console.log(\"Score\", result[1])\r\n        return result[0] // should be a move\r\n    }\r\n\r\n    const miniMax = (board, depth, alpha, beta, maxPlayer, currentPlayer, mem) => {\r\n        const moves = board.getAllMoves(currentPlayer) // TODO: time consuming\r\n        moves.sort(sortMoves)\r\n        let bestMove;\r\n        if (currentPlayer === maxPlayer) {\r\n            let maxEval = -90000\r\n            let illegal = 0\r\n            for (let i = 0; i < moves.length; i++) {\r\n                const move = moves[i]\r\n                board.movePiece(move.piece, move)\r\n                if (board.isIllegal(currentPlayer, move)) {\r\n                    board.undoMove()\r\n                    illegal++\r\n                    continue\r\n                }\r\n\r\n                if (bestMove === undefined) {\r\n                    bestMove = move\r\n                }\r\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem)\r\n                board.undoMove()\r\n                if (currentEval > maxEval) {\r\n                    maxEval = currentEval\r\n                    bestMove = move\r\n                }\r\n                alpha = Math.max(alpha, currentEval)\r\n                if (beta <= alpha) {\r\n                    break\r\n                }\r\n            }\r\n            if (illegal === moves.length) { // TODO: check stalemate\r\n                if (board.isCheck(currentPlayer)) {\r\n                    return [null, -90000]\r\n                }\r\n                return [null, 0]\r\n            }\r\n            return [bestMove, maxEval]\r\n        } else {\r\n            let minEval = 90000\r\n            let illegal = 0\r\n            for (let i = 0; i < moves.length; i++) {\r\n                const move = moves[i]\r\n                board.movePiece(move.piece, move)\r\n                if (board.isIllegal(currentPlayer, move)) {\r\n                    board.undoMove()\r\n                    illegal++\r\n                    continue\r\n                }\r\n                if (bestMove === undefined) {\r\n                    bestMove = move\r\n                }\r\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem)\r\n                board.undoMove()\r\n                if (currentEval < minEval) {\r\n                    minEval = currentEval\r\n                    bestMove = move\r\n                }\r\n                beta = Math.min(beta, currentEval)\r\n                if (beta <= alpha) {\r\n                    break\r\n                }\r\n            }\r\n            if (illegal === moves.length) {\r\n                if (board.isCheck(currentPlayer)) {\r\n                    return [null, 90000]\r\n                }\r\n                return [null, 0]\r\n\r\n            }\r\n            return [bestMove, minEval]\r\n        }\r\n    }\r\n    const miniMaxCore = (board, depth, alpha, beta, maxPlayer, currentPlayer, prevMoves, mem) => {\r\n        const MAX_KILLER = 2\r\n        if (depth === 0) {\r\n            let result\r\n            if (maxPlayer === currentPlayer && board.moves.slice(-1)[0].ate !== null) {\r\n                result = quiesce(alpha, beta, board, currentPlayer, 1, prevMoves)\r\n            } else {\r\n                result = board.getScore(maxPlayer, prevMoves)\r\n            }\r\n            return result\r\n        }\r\n        const moves = board.getAllMoves(currentPlayer) // TODO: time consuming\r\n        moveOrder(moves, mem, depth)\r\n        if (currentPlayer === maxPlayer) {\r\n            let maxEval = -30000\r\n            let illegal = 0\r\n            for (let i = 0; i < moves.length; i++) {\r\n                const move = moves[i]\r\n                board.movePiece(move.piece, move)\r\n                if (board.isIllegal(currentPlayer, move)) {\r\n                    board.undoMove()\r\n                    illegal++\r\n                    continue\r\n                }\r\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, moves, mem)\r\n                board.undoMove()\r\n                if (currentEval > maxEval) {\r\n                    maxEval = currentEval\r\n                }\r\n                if (currentEval > alpha) {\r\n                    alpha = currentEval\r\n                }\r\n                if (beta <= alpha) {\r\n                    if (move.ate !== null) {\r\n                        break\r\n                    }\r\n                    const arr = mem.get(depth)\r\n                    if (arr.find(e => e!== null && isEqualMove(e, move))) {\r\n                        break\r\n                    }\r\n                    for (let j = MAX_KILLER - 2; j >= 0; j--) {\r\n                        arr[j + 1] = arr[j]\r\n                    }\r\n                    arr[0] = move\r\n                    break\r\n                }\r\n            }\r\n            if (illegal === moves.length) {\r\n                if (board.isCheck(currentPlayer)) {\r\n                    return -30000 * depth // faster checkmates\r\n                }\r\n                return 0 // stalemate\r\n            }\r\n            return maxEval\r\n        } else {\r\n            let minEval = 30000\r\n            let illegal = 0\r\n            for (let i = 0; i < moves.length; i++) {\r\n                const move = moves[i]\r\n                board.movePiece(move.piece, move)\r\n                if (board.isIllegal(currentPlayer, move)) {\r\n                    board.undoMove()\r\n                    illegal++\r\n                    continue\r\n                }\r\n\r\n                const currentEval = miniMaxCore(board, depth - 1, alpha, beta, maxPlayer, currentPlayer * -1, prevMoves, mem)\r\n                board.undoMove()\r\n                if (currentEval < minEval) {\r\n                    minEval = currentEval\r\n                }\r\n\r\n                if (currentEval < beta) {\r\n                    beta = currentEval\r\n                }\r\n                if (beta <= alpha) {\r\n                    if (move.ate !== null) {\r\n                        break\r\n                    }\r\n                    const arr = mem.get(depth)\r\n                    if (arr.find(e => e!== null && isEqualMove(e, move))) {\r\n                        break\r\n                    }\r\n                    for (let j = MAX_KILLER - 2; j >= 0; j--) {\r\n                        arr[j + 1] = arr[j]\r\n                    }\r\n                    arr[0] = move\r\n                    break\r\n                }\r\n            }\r\n            if (illegal === moves.length) {\r\n                if (board.isCheck(currentPlayer)) {\r\n                    return 30000 * depth\r\n                }\r\n                return 0\r\n\r\n            }\r\n            return minEval\r\n        }\r\n    }\r\n\r\n    const moveOrder = (moves, mem, depth) => {\r\n\r\n        const sortMovesO = (a, b) => {\r\n            if (a.ate !== null && b.ate !== null) {\r\n                const aScore = a.piece.points - a.ate.points\r\n                const bScore = b.piece.points - b.ate.points\r\n                return aScore < bScore ? -1: 1\r\n            } else {\r\n                if (a.ate !== null) {\r\n                    return -1\r\n                } else if (b.ate !== null) {\r\n                    return 1\r\n                }\r\n                const memSlot = mem.get(depth)\r\n                for (let slot = 0; slot < memSlot.length; slot++) {\r\n                    const killerMove = memSlot[slot]\r\n                    if (killerMove !== null && isEqualMove(a, killerMove)) {\r\n                        return -1\r\n                    }\r\n                    if (killerMove !== null && isEqualMove(b, killerMove)) {\r\n                        return 1\r\n                    }\r\n                }\r\n\r\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\r\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\r\n                return aScore < bScore ? 1: -1\r\n\r\n            }\r\n        }\r\n        moves.sort(sortMovesO)\r\n    }\r\n\r\n    const isEqualMove = (a, b) => {\r\n        if (a.newCell.row === b.newCell.row && a.newCell.col === b.newCell.col && a.oldCell.row === b.oldCell.row && a.oldCell.col === b.oldCell.col && a.piece.constructor === b.piece.constructor) {\r\n            if (a.ate !== null && b.ate !== null) {\r\n                return a.ate.constructor === b.ate.constructor\r\n            }\r\n            return a.ate === b.ate\r\n        }\r\n        return false\r\n    }\r\n\r\n    const sortMoves = (a, b) => {\r\n        if (a.ate !== null && b.ate !== null) {\r\n            const aScore = a.piece.points - a.ate.points\r\n            const bScore = b.piece.points - b.ate.points\r\n            return aScore < bScore ? -1: 1\r\n        } else {\r\n            if (a.ate !== null) {\r\n                return -1\r\n            } else if (b.ate !== null) {\r\n                return 1\r\n            } else {\r\n                const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\r\n                const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\r\n                return aScore < bScore ? 1: -1\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    const quiesce = (alpha, beta, board, colour, depth, prevMoves) => {\r\n        const evaluation = board.getScore(colour, prevMoves)\r\n        if (depth === 0) {\r\n            return evaluation\r\n        }\r\n        if (evaluation >= beta) {\r\n            return beta\r\n        }\r\n\r\n        alpha = Math.max(alpha, evaluation)\r\n        const moves = board.getAllMoves(colour)\r\n        moves.sort(sortMoves)\r\n        for (let i = 0; i < moves.length; i++) {\r\n            const move = moves[i]\r\n            if (move.ate !== null) { //  && move.ate.points > move.piece.points\r\n                board.movePiece(move.piece, move)\r\n                let score = -quiesce(-beta, -alpha, board, colour * -1, depth - 1, prevMoves)\r\n                board.undoMove()\r\n                if (score >= beta) {\r\n                    return beta\r\n                }\r\n                if (score > alpha) {\r\n                    alpha = score\r\n                }\r\n            } else {\r\n                break\r\n            }\r\n        }\r\n        return alpha\r\n    }\r\n    //\r\n    // const quiesceOdd = (alpha, beta, board, colour, depth) => {\r\n    //     // const evaluation = evaluate(board, colour)\r\n    //     let evaluation\r\n    //     const boardHash = board.getBoardHash() + colour.toString()\r\n    //     if (mem.has(boardHash)) {\r\n    //         evaluation = mem.get(boardHash)\r\n    //     } else {\r\n    //         evaluation = evaluate(board, colour)\r\n    //         mem.set(boardHash, evaluation)\r\n    //     }\r\n    //\r\n    //     if (depth === 0) {\r\n    //         return evaluation\r\n    //     }\r\n    //     if (evaluation >= beta) {\r\n    //         return beta\r\n    //     }\r\n    //\r\n    //     alpha = Math.max(alpha, evaluation)\r\n    //     const moves = board.getAllMoves(colour)\r\n    //     moves.sort(sortMovesQuiesce)\r\n    //     for (const move of moves) {\r\n    //         if (move.ate !== null) { //  && move.ate.points > move.piece.points\r\n    //             board.movePiece(move.piece, move)\r\n    //             let score = -quiesce(-beta, -alpha, board, switchColour(colour), depth - 1)\r\n    //             board.undoMove()\r\n    //             if (score >= beta) {\r\n    //                 return beta\r\n    //             }\r\n    //             if (score > alpha) {\r\n    //                 alpha = score\r\n    //             }\r\n    //         }\r\n    //     }\r\n    //     return alpha\r\n    // }\r\n\r\n    // const negaMax = (depth, board, colour, maxColour) => {\r\n    //     if (depth === 0) {\r\n    //         return evaluate(board, maxColour)\r\n    //     }\r\n    //     const testGameOver = board.isGameOver(colour).isGameOver\r\n    //     if (testGameOver && colour === maxColour) {\r\n    //         return -Number.MAX_VALUE\r\n    //     }\r\n    //     if (testGameOver && colour !== maxColour) {\r\n    //         return Number.MAX_VALUE\r\n    //     }\r\n    //     let max = -Number.MAX_VALUE\r\n    //     const moves = board.getAllMoves(colour)\r\n    //     for (const move of moves) {\r\n    //         board.movePiece(move.piece, move)\r\n    //         const currentEval = -negaMax(depth - 1, board, switchColour(colour), maxColour)\r\n    //         if (currentEval > max) {\r\n    //             max = currentEval\r\n    //         }\r\n    //         board.undoMove()\r\n    //     }\r\n    //     return max\r\n    // }\r\n    // const rootNegaMax = (depth, board, colour, maxColour) => {\r\n    //     const rootMoves = board.getAllMoves(maxColour)\r\n    //     let max = -Number.MAX_VALUE\r\n    //     const randomIndex = Math.floor(Math.random() * (rootMoves.length - 1))\r\n    //     let bestMove = rootMoves.length > 0 ? rootMoves[randomIndex] : null\r\n    //     for (const move of rootMoves) {\r\n    //         board.movePiece(move.piece, move)\r\n    //         const score = negaMax(depth, board, colour, maxColour)\r\n    //         if (score > max) {\r\n    //             max = score\r\n    //             bestMove = move\r\n    //         }\r\n    //         board.undoMove()\r\n    //     }\r\n    //     return bestMove\r\n    //\r\n    // }\r\n    class Board {\r\n        board;\r\n\r\n        constructor() {\r\n            this.board = this.newBoard()\r\n            this.moves = []\r\n        }\r\n\r\n        newBoard = () => {\r\n            const startingBoard = [\r\n                [new Rook(Piece.BLACK, new Cell(0,0)), new Knight(Piece.BLACK, new Cell(0, 1)), new Bishop(Piece.BLACK, new Cell(0, 2)), new Queen(Piece.BLACK, new Cell(0, 3)), new King(Piece.BLACK, new Cell(0, 4)), new Bishop(Piece.BLACK, new Cell(0, 5)), new Knight(Piece.BLACK, new Cell(0, 6)), new Rook(Piece.BLACK, new Cell(0,7))],\r\n                [new Pawn(Piece.BLACK, new Cell(1, 0)), new Pawn(Piece.BLACK, new Cell(1, 1)), new Pawn(Piece.BLACK, new Cell(1, 2)), new Pawn(Piece.BLACK, new Cell(1, 3)), new Pawn(Piece.BLACK, new Cell(1, 4)), new Pawn(Piece.BLACK, new Cell(1, 5)), new Pawn(Piece.BLACK, new Cell(1, 6)), new Pawn(Piece.BLACK, new Cell(1, 7))],\r\n                [null, null, null, null, null, null, null, null],\r\n                [null, null, null, null, null, null, null, null],\r\n                [null, null, null, null, null, null, null, null],\r\n                [null, null, null, null, null, null, null, null],\r\n                [new Pawn(Piece.WHITE, new Cell(6, 0)), new Pawn(Piece.WHITE, new Cell(6, 1)), new Pawn(Piece.WHITE, new Cell(6, 2)), new Pawn(Piece.WHITE, new Cell(6, 3)), new Pawn(Piece.WHITE, new Cell(6, 4)), new Pawn(Piece.WHITE, new Cell(6, 5)), new Pawn(Piece.WHITE, new Cell(6, 6)), new Pawn(Piece.WHITE, new Cell(6, 7))],\r\n                [new Rook(Piece.WHITE, new Cell(7,0)), new Knight(Piece.WHITE, new Cell(7, 1)), new Bishop(Piece.WHITE, new Cell(7, 2)), new Queen(Piece.WHITE, new Cell(7, 3)), new King(Piece.WHITE, new Cell(7, 4)), new Bishop(Piece.WHITE, new Cell(7, 5)), new Knight(Piece.WHITE, new Cell(7, 6)), new Rook(Piece.WHITE, new Cell(7,7))],\r\n            ]\r\n            return startingBoard\r\n        }\r\n        // update piece square tables for endgame\r\n        setEndGame = () => {\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null && piece.whiteScoreEnd !== undefined) {\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            piece.whiteScore = piece.whiteScoreEnd\r\n                        } else {\r\n                            piece.blackScore = piece.blackScoreEnd\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // update values of pieces\r\n        updatePieceValues = (totalMoves) => {\r\n            const MOVE_THRESHOLD = 12\r\n            // for knight, -5 per missing pawn of any colour done\r\n            // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\r\n            // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\r\n            // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\r\n\r\n            let whitePawnCount = 0\r\n            let blackPawnCount = 0\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        if (piece instanceof Pawn) {\r\n                            if (piece.colour === Piece.WHITE) {\r\n                                whitePawnCount++\r\n                            } else {\r\n                                blackPawnCount++\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const openFiles = []\r\n            for (let col = 0; col < 8; col++) {\r\n                let hasPawn = false\r\n                for (let row = 0; row < 8; row++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        if (piece instanceof Pawn) {\r\n                            hasPawn = true\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n                if (!hasPawn) {\r\n                    openFiles.push(col)\r\n                }\r\n            }\r\n\r\n            // first ten moves, bad to move queen out, and encourage piece development\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        if (piece instanceof Queen) {\r\n                            if (totalMoves <= MOVE_THRESHOLD) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    piece.whiteScore[7][3]+=50\r\n                                } else {\r\n                                    piece.blackScore[0][3]+=50\r\n                                }\r\n                            }\r\n                        }\r\n                        if (piece instanceof Knight) {\r\n                            piece.points-= ((16 - whitePawnCount - blackPawnCount) * 3)\r\n                            if (totalMoves <= MOVE_THRESHOLD) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    piece.whiteScore[7][1]-=50\r\n                                    piece.whiteScore[7][6]-=50\r\n                                } else {\r\n                                    piece.blackScore[0][1]-=50\r\n                                    piece.blackScore[0][6]-=50\r\n                                }\r\n                            }\r\n                        }\r\n                        if (piece instanceof Bishop) {\r\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\r\n                            if (totalMoves <= MOVE_THRESHOLD) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    piece.whiteScore[7][2]-=50\r\n                                    piece.whiteScore[7][5]-=50\r\n                                } else {\r\n                                    piece.blackScore[0][2]-=50\r\n                                    piece.blackScore[0][5]-=50\r\n                                }\r\n                            }\r\n                        }\r\n                        if (piece instanceof Rook) {\r\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\r\n                            for (const openCol of openFiles) {\r\n                                for (let openRow = 0; openRow<8; openRow++) {\r\n                                    piece.whiteScore[openRow][openCol]+= 15\r\n                                    piece.blackScore[openRow][openCol]+= 15\r\n                                }\r\n                            }\r\n                        }\r\n                        if (piece instanceof Pawn) {\r\n                            let past = true\r\n                            if (col + 1 < 8) {\r\n                                for (let i = 0; i < 8; i++) {\r\n                                    if (this.getPiece(i, col + 1) instanceof Pawn) {\r\n                                        past = false\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (col - 1 >= 0) {\r\n                                for (let i = 0; i < 8; i++) {\r\n                                    if (this.getPiece(i, col - 1) instanceof Pawn) {\r\n                                        past = false\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (past) {\r\n                                if (piece.colour === Piece.WHITE) {\r\n                                    piece.points+= (20 * (6 - row))\r\n                                } else {\r\n                                    piece.points+= (20 * (row - 1))\r\n                                }\r\n\r\n                            }\r\n                            let doubled = false\r\n                            for (let i = 0; i < 8; i++) {\r\n                                if (piece instanceof Pawn && i !== row) {\r\n                                    doubled = true\r\n                                }\r\n                            }\r\n                            if (doubled) {\r\n                                piece.points-=10\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        isEndGame = () => {\r\n            // End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\r\n            let countWhitePieces = 0\r\n            let countBlackPieces = 0\r\n            let countWhiteQueen = 0\r\n            let countBlackQueen = 0\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece instanceof Queen) {\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            countWhiteQueen++\r\n                        } else {\r\n                            countBlackQueen++\r\n                        }\r\n                    }\r\n                    if (piece instanceof Rook || piece instanceof Bishop || piece instanceof Knight) {\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            countWhitePieces++\r\n                        } else {\r\n                            countBlackPieces++\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return ((countWhiteQueen <= 1 && countWhitePieces <=1) || (countBlackQueen <= 1  && countBlackPieces <=1))\r\n                || ((countWhitePieces <=3 && countWhiteQueen <= 0) || (countBlackPieces <=3  && countBlackQueen <= 0))\r\n        }\r\n\r\n        setBoardString = (boardString) => {\r\n            const newBoard = []\r\n            for (let row = 0; row < 8; row++) {\r\n                const newRow = []\r\n                for (let col = 0; col < 8; col++) {\r\n                    const pieceString = boardString[row][col]\r\n                    if (pieceString === null) {\r\n                        newRow.push(null)\r\n                    } else {\r\n                        const pieceColour = pieceString.slice(0, 1)\r\n                        const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\r\n                        const piece = pieceString.slice(1, 2)\r\n                        if (piece === \"b\") {\r\n                            newRow.push(new Bishop(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'k') {\r\n                            newRow.push(new King(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'n') {\r\n                            newRow.push(new Knight(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'p') {\r\n                            newRow.push(new Pawn(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'q') {\r\n                            newRow.push(new Queen(actualColour, new Cell(row, col)))\r\n                        } else if (piece === 'r') {\r\n                            newRow.push(new Rook(actualColour, new Cell(row, col)))\r\n                        } else {\r\n                            newRow.push(null)\r\n                        }\r\n                    }\r\n                }\r\n                newBoard.push(newRow)\r\n            }\r\n            this.board = newBoard\r\n        }\r\n\r\n        getBoardHash = () => {\r\n            let str = \"\"\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col)) {\r\n                        str += this.getPiece(row, col).getString()\r\n                    } else {\r\n                        str += \" \"\r\n                    }\r\n                }\r\n            }\r\n            return str\r\n        }\r\n\r\n        /**\r\n         * Returns the board represented by the array\r\n         */\r\n        getBoard = () => {\r\n            return this.board\r\n        }\r\n        /**\r\n         * Returns piece at the coordinates\r\n         */\r\n        getPiece = (row, col) => {\r\n            return this.board[row][col]\r\n        }\r\n\r\n        /**\r\n         * Returns if the cell is empty\r\n         */\r\n        isEmpty = (row, col) => {\r\n            if (this.isOutSide(row, col)) {\r\n                return false\r\n            }\r\n            return this.board[row][col] === null\r\n        }\r\n        isUnderCheck = (colour) => {\r\n            return false\r\n        }\r\n        isOutSide = (row, col) => {\r\n            return row < 0 || col < 0 || row > 7 || col > 7\r\n        }\r\n\r\n        canEat = (row, col, colour) => {\r\n            return !this.isOutSide(row, col) && !this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour\r\n        }\r\n\r\n\r\n        canMove = (row, col) => {\r\n            return !this.isOutSide(row, col) && this.isEmpty(row, col)\r\n        }\r\n\r\n        canKingMove = (row, col, colour) => {\r\n            const directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\r\n            for (const direction of directions) {\r\n                const newRow = row + direction[0]\r\n                const newCol = col + direction[1]\r\n                if (!this.isOutSide(newRow, newCol) && !this.isEmpty(newRow, newCol)\r\n                    && (this.getPiece(newRow, newCol).name === Piece.KING && this.getPiece(newRow, newCol).colour !== colour)) {\r\n                    return false\r\n                }\r\n            }\r\n            return true\r\n        }\r\n\r\n        movePiece = (piece, move) => {\r\n            move.piece.movePiece(move, this)\r\n            this.moves.push(move)\r\n        }\r\n\r\n        undoMove = () => {\r\n            if (this.moves.length > 0) {\r\n                const move = this.moves.pop()\r\n                const prevRow = move.oldCell.row\r\n                const prevCol = move.oldCell.col\r\n                const piece = this.board[move.newCell.row][move.newCell.col]\r\n                if (piece === null) {\r\n                    console.log(this.getBoardString(), move)\r\n                }\r\n\r\n                this.board[prevRow][prevCol] = piece\r\n                piece.cell.row = prevRow\r\n                piece.cell.col = prevCol\r\n                if (move.isEnPassant) { // add back pawn\r\n                    this.board[move.ate.cell.row][move.ate.cell.col] = move.ate\r\n                    this.board[move.newCell.row][move.newCell.col] = null\r\n                    return true\r\n                } else if (move.isPromotion) { // remove piece, add back pawn\r\n                    this.board[prevRow][prevCol] = new Pawn(piece.colour, piece.cell, piece.moves)\r\n                } else if (move.castle.isCastle) { // king will be undone, need to undo rook\r\n                    this.board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = move.castle.rook.piece\r\n                    move.castle.rook.piece.cell.row = move.castle.rook.oldCell.row\r\n                    move.castle.rook.piece.cell.col = move.castle.rook.oldCell.col\r\n                    this.board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = null\r\n                }\r\n                this.board[move.newCell.row][move.newCell.col] = move.ate\r\n                return true\r\n            }\r\n            return false\r\n        }\r\n\r\n        kingHasMoved = (colour) => {\r\n            for (let i = 0; i < this.moves.length; i++) {\r\n                const move = this.moves[i]\r\n                if (move.piece.name === Piece.KING && move.piece.colour === colour) {\r\n                    return true\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        rookHasMoved = (colour, side) => {\r\n            const row = colour === Piece.BLACK ? 0 : 7\r\n            const col = side === King.KING_SIDE ? 7 : 0\r\n            if (!(this.getPiece(row, col) !== null && this.getPiece(row, col).name === Piece.ROOK)) { // no rook on cell\r\n                return true\r\n            }\r\n            for (const move of this.moves) {\r\n                if (move.piece.name === Piece.ROOK && move.piece.colour === colour && move.oldCell.row === row && move.oldCell.col === col) {\r\n                    return true\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        castlingSquaresIsEmpty = (colour, side) => {\r\n            const row = colour === Piece.BLACK ? 0 : 7\r\n            const cols = side === King.KING_SIDE ? [5,6] : [1,2,3]\r\n            for (const col of cols) {\r\n                if (!this.isEmpty(row, col)) {\r\n                    return false\r\n                }\r\n            }\r\n            return true\r\n        }\r\n\r\n        // returns if colour is under check, need check for castling\r\n        isIllegal = (colour, move) => {\r\n            // get colour king first\r\n            let king;\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col)) {\r\n                        const piece = this.getPiece(row, col)\r\n                        if (piece.name === Piece.KING) {\r\n                            if (piece.colour === colour) {\r\n                                king = piece\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (move.castle.isCastle) {\r\n                const moves = this.getAllMoves(colour * -1)\r\n                const row = move.newCell.row\r\n                if (move.newCell.col === 6) { // kingside\r\n                    for (const opp of moves) {\r\n                        const moveRow = opp.newCell.row\r\n                        const moveCol = opp.newCell.col\r\n                        if (moveRow === row && (moveCol === 6 || moveCol === 5 || moveCol === 4)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (const opp of moves) {\r\n                        const moveRow = opp.newCell.row\r\n                        const moveCol = opp.newCell.col\r\n                        if (moveRow === row && (moveCol === 1 || moveCol === 2 || moveCol === 3 || moveCol === 4)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour) {\r\n                        const piece = this.getPiece(row, col)\r\n                        if (piece.isCheck(this, king)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return false\r\n        }\r\n        // check if colour is under check\r\n        isCheck = (colour) => {\r\n            let king;\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col)) {\r\n                        const piece = this.getPiece(row, col)\r\n                        if (piece.name === Piece.KING) {\r\n                            if (piece.colour === colour) {\r\n                                king = piece\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour) {\r\n                        const piece = this.getPiece(row, col)\r\n                        if (piece.isCheck(this, king)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return false\r\n        }\r\n\r\n        /**\r\n         * Checks if game is over for colour, means other colour wins\r\n         * @param colour\r\n         * @return {*[]}\r\n         */\r\n\r\n        getAllMoves = (colour) => {\r\n            let squares = []\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour === colour) {\r\n                        const piece = this.getPiece(row, col)\r\n                        const moves = piece.getMoves(this)\r\n                        squares = squares.concat(moves)\r\n                    }\r\n                }\r\n            }\r\n            return squares\r\n        }\r\n        /**\r\n         * Goes through board for positional eval, like piece development, hardcoded for black\r\n         */\r\n        scanSquaresScore = () => {\r\n            let score = 0\r\n            let materialScore = 0\r\n            for (let row = 0; row < 8; row++) {\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        // material score\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            materialScore += piece.points\r\n                        } else {\r\n                            materialScore -= piece.points\r\n                        }\r\n\r\n                        // development / positional score\r\n                        if (piece.colour === Piece.WHITE) {\r\n                            score += piece.whiteScore[row][col]\r\n                        } else {\r\n                            score -= piece.blackScore[row][col]\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return score + materialScore\r\n        }\r\n\r\n        /**\r\n         * used for minimax heuristics\r\n         * @param colour colour making the next move\r\n         * @param prevMoves total moves available\r\n         * @return {number} score of position\r\n         */\r\n        getScore = (colour, prevMoves) => {\r\n            const positionalScore = this.scanSquaresScore()\r\n            return (positionalScore + prevMoves.length * 5) * colour * -1\r\n        }\r\n\r\n        getBoardString = () => {\r\n            const newBoard = []\r\n            for (let row = 0; row < 8; row++) {\r\n                const newRow = []\r\n                for (let col = 0; col < 8; col++) {\r\n                    const piece = this.getPiece(row, col)\r\n                    if (piece !== null) {\r\n                        newRow.push(piece.getString())\r\n                    } else {\r\n                        newRow.push(null)\r\n                    }\r\n                }\r\n                newBoard.push(newRow)\r\n            }\r\n            return newBoard\r\n        }\r\n\r\n    }\r\n    /**\r\n     * This class represents a coordinate on the chess board\r\n     */\r\n    class Cell {\r\n        constructor(row, col) {\r\n            this.row = row\r\n            this.col = col\r\n        }\r\n    }\r\n    class Move {\r\n        oldCell\r\n        newCell\r\n\r\n        constructor(oldCell, newCell, piece, isEnPassant = false,\r\n                    castle = {isCastle: false}, ate = null, isPromotion = false) {\r\n            this.oldCell = oldCell\r\n            this.newCell = newCell\r\n            this.piece = piece\r\n            this.isEnPassant = isEnPassant\r\n            this.castle = castle\r\n            this.ate = ate\r\n            this.isPromotion = isPromotion\r\n        }\r\n\r\n        getMoveString = () => {\r\n            return {\r\n                oldCellRow: this.oldCell.row,\r\n                oldCellCol: this.oldCell.col,\r\n                newCellRow: this.newCell.row,\r\n                newCellCol: this.newCell.col,\r\n                pieceString: this.piece.getString(),\r\n                isEnPassant: this.isEnPassant,\r\n                castle: this.castle.isCastle === false ? {isCastle: false} : {isCastle: true,\r\n                    rook:{\r\n                    pieceString : this.castle.rook.piece.getString(),\r\n                    oldCellRow: this.castle.rook.oldCell.row,\r\n                    oldCellCol: this.castle.rook.oldCell.col,\r\n                    newCellRow: this.castle.rook.newCell.row,\r\n                    newCellCol: this.castle.rook.newCell.col,\r\n                }},\r\n                ate: this.ate !== null ? this.ate.getString() : null,\r\n                isPromotion: this.isPromotion\r\n            }\r\n        }\r\n        static parseMove = (board, data) => {\r\n            const parseMove = new Move(\r\n                new Cell(data.oldCellRow, data.oldCellCol),\r\n                new Cell(data.newCellRow, data.newCellCol),\r\n                Piece.parsePieceString(data.pieceString),\r\n                data.isEnPassant,\r\n                {isCastle: false},\r\n                null,\r\n                data.isPromotion\r\n            )\r\n\r\n            if (data.castle.isCastle) {\r\n                const rookObj = data.castle.rook\r\n                parseMove.castle.isCastle = true\r\n                parseMove.castle.rook = new Move(new Cell(rookObj.oldCellRow, rookObj.oldCellCol)\r\n                    , new Cell(rookObj.newCellRow, rookObj.newCellCol), board.getPiece(rookObj.oldCellRow, rookObj.oldCellCol))\r\n            }\r\n            return parseMove\r\n        }\r\n\r\n    }\r\n    class Piece {\r\n        static WHITE = -1\r\n        static BLACK = 1\r\n        static ROOK = \"r\"\r\n        static BISHOP = \"b\"\r\n        static KNIGHT = \"n\"\r\n        static KING = \"k\"\r\n        static QUEEN = \"q\"\r\n        static PAWN = \"p\"\r\n        constructor(colour, cell) {\r\n            this.colour = colour // white or black\r\n            this.cell = cell\r\n        }\r\n        static parsePieceString = (pieceString) => {\r\n            const pieceColour = pieceString.slice(0, 1)\r\n            const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\r\n            const piece = pieceString.slice(1, 2)\r\n            if (piece === \"b\") {\r\n                return new Bishop(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'k') {\r\n                return new King(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'n') {\r\n                return new Knight(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'p') {\r\n                return new Pawn(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'q') {\r\n                return new Queen(actualColour, new Cell(0, 0))\r\n            } else if (piece === 'r') {\r\n                return new Rook(actualColour, new Cell(0, 0))\r\n            } else {\r\n                return null\r\n            }\r\n        }\r\n    }\r\n\r\n    class Bishop extends Piece {\r\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1]]\r\n        points = 330\r\n        name = Piece.BISHOP\r\n        whiteScore = [\r\n            [-20,-10,-10,-10,-10,-10,-10,-20],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-10,  0,  5, 10, 10,  5,  0,-10],\r\n            [-10,  5,  5, 10, 10,  5,  5,-10],\r\n            [-10,  0, 10, 10, 10, 10,  0,-10],\r\n            [-10, 10, 10, 10, 10, 10, 10,-10],\r\n            [-10,  5,  0,  0,  0,  0,  5,-10],\r\n            [-20,-10,-10,-10,-10,-10,-10,-20]\r\n        ]\r\n        blackScore = [\r\n            [-20,-10,-10,-10,-10,-10,-10,-20],\r\n            [-10,  5,  0,  0,  0,  0,  5,-10],\r\n            [-10, 10, 10, 10, 10, 10, 10,-10],\r\n            [-10,  0, 10, 10, 10, 10,  0,-10],\r\n            [-10,  5,  5, 10, 10,  5,  5,-10],\r\n            [-10,  0,  5, 10, 10,  5,  0,-10],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-20,-10,-10,-10,-10,-10,-10,-20],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                    moves.push(move)\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        // check if piece is checking the enemy king\r\n        isCheck = (board, king) => {\r\n            const row = this.cell.row\r\n            const col = this.cell.col\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            const rowDiff = Math.abs(row - kingRow)\r\n            const colDiff = Math.abs(col - kingCol)\r\n            if (rowDiff !== colDiff) {\r\n                return false\r\n            }\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\r\n                            return true\r\n                        }\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return false\r\n\r\n        }\r\n\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"b\"\r\n        }\r\n    }\r\n    class King extends Piece {\r\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\r\n        static KING_SIDE = -1\r\n        static QUEEN_SIDE = 1\r\n        name = Piece.KING\r\n        points = 10000\r\n\r\n        whiteScore = [\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-20,-30,-30,-40,-40,-30,-30,-20],\r\n            [-10,-20,-20,-20,-20,-20,-20,-10],\r\n            [20, 20,  0,  0,  0,  0, 20, 20],\r\n            [20, 30, 10,  0,  0, 10, 30, 20]\r\n        ]\r\n\r\n        blackScore = [\r\n            [20, 30, 10,  0,  0, 10, 30, 20],\r\n            [20, 20,  0,  0,  0,  0, 20, 20],\r\n            [-10,-20,-20,-20,-20,-20,-20,-10],\r\n            [-20,-30,-30,-40,-40,-30,-30,-20],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n            [-30,-40,-40,-50,-50,-40,-40,-30],\r\n        ]\r\n        whiteScoreEnd = [\r\n            [-50,-40,-30,-20,-20,-30,-40,-50],\r\n            [-30,-20,-10,  0,  0,-10,-20,-30],\r\n            [-30,-10, 20, 30, 30, 20,-10,-30],\r\n            [-30,-10, 30, 40, 40, 30,-10,-30],\r\n            [-30,-10, 30, 40, 40, 30,-10,-30],\r\n            [-30,-10, 20, 30, 30, 20,-10,-30],\r\n            [-30,-30,  0,  0,  0,  0,-30,-30],\r\n            [-50,-30,-30,-30,-30,-30,-30,-50]\r\n        ]\r\n        blackScoreEnd = [\r\n            [-50,-30,-30,-30,-30,-30,-30,-50],\r\n            [-30,-30,  0,  0,  0,  0,-30,-30],\r\n            [-30,-10, 20, 30, 30, 20,-10,-30],\r\n            [-30,-10, 30, 40, 40, 30,-10,-30],\r\n            [-30,-10, 30, 40, 40, 30,-10,-30],\r\n            [-30,-10, 20, 30, 30, 20,-10,-30],\r\n            [-30,-20,-10,  0,  0,-10,-20,-30],\r\n            [-50,-40,-30,-20,-20,-30,-40,-50],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                const newRow = row + currentRow\r\n                const newCol = col + currentCol\r\n                if (((board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol))) && board.canKingMove(newRow, newCol, this.colour)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                    moves.push(move)\r\n                }\r\n            }\r\n            // king and rook has not moved, illegal check later\r\n            if (board.castlingSquaresIsEmpty(this.colour, King.KING_SIDE) && !board.rookHasMoved(this.colour, King.KING_SIDE) && !board.kingHasMoved(this.colour)) {\r\n                const row = this.colour === Piece.BLACK ? 0 : 7\r\n                const col = 6\r\n                moves.push(new Move(new Cell(currentRow, currentCol), new Cell(row, col), this, false,\r\n                    {isCastle: true, rook: new Move(new Cell(row, 7), new Cell(row, 5), board.getPiece(row, 7))}))\r\n            }\r\n            if (board.castlingSquaresIsEmpty(this.colour, King.QUEEN_SIDE) && !board.rookHasMoved(this.colour, King.QUEEN_SIDE) && !board.kingHasMoved(this.colour)) {\r\n                const row = this.colour === Piece.BLACK ? 0 : 7\r\n                const col = 2\r\n                moves.push(new Move(new Cell(currentRow, currentCol), new Cell(row, col), this, false,\r\n                    {isCastle: true, rook: new Move(new Cell(row, 0), new Cell(row, 3), board.getPiece(row, 0))}))\r\n            }\r\n\r\n\r\n            return moves\r\n        }\r\n        // check if piece is checking the enemy king\r\n        isCheck = (board, king) => {\r\n            return false\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            if (move.castle.isCastle) {\r\n                board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = move.castle.rook.piece\r\n                board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = null\r\n                move.castle.rook.piece.cell.row = move.castle.rook.newCell.row\r\n                move.castle.rook.piece.cell.col = move.castle.rook.newCell.col\r\n            }\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"k\"\r\n        }\r\n    }\r\n    class Knight extends Piece {\r\n        directions = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\r\n\r\n        points = 320\r\n        name = Piece.KNIGHT\r\n\r\n        whiteScore = [\r\n            [-50,-40,-30,-30,-30,-30,-40,-50],\r\n            [-40,-20,  0,  0,  0,  0,-20,-40],\r\n            [-30,  0, 10, 15, 15, 10,  0,-30],\r\n            [-30,  5, 15, 20, 20, 15,  5,-30],\r\n            [-30,  0, 15, 20, 20, 15,  0,-30],\r\n            [-30,  5, 10, 15, 15, 10,  5,-30],\r\n            [-40,-20,  0,  5,  5,  0,-20,-40],\r\n            [-50,-40,-30,-30,-30,-30,-40,-50]\r\n        ]\r\n\r\n        blackScore = [\r\n            [-50,-40,-30,-30,-30,-30,-40,-50],\r\n            [-40,-20,  0,  5,  5,  0,-20,-40],\r\n            [-30,  5, 10, 15, 15, 10,  5,-30],\r\n            [-30,  0, 15, 20, 20, 15,  0,-30],\r\n            [-30,  5, 15, 20, 20, 15,  5,-30],\r\n            [-30,  0, 10, 15, 15, 10,  0,-30],\r\n            [-40,-20,  0,  0,  0,  0,-20,-40],\r\n            [-50,-40,-30,-30,-30,-30,-40,-50],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const newRow = row + currentRow\r\n                const newCol = col + currentCol\r\n                if (board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                    moves.push(move)\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        // check if piece is checking the enemy king\r\n        isCheck = (board, king) => {\r\n            const row = this.cell.row\r\n            const col = this.cell.col\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            const rowDiff = Math.abs(row - kingRow)\r\n            const colDiff = Math.abs(col - kingCol)\r\n            if (rowDiff + colDiff !== 3) {\r\n                return false\r\n            }\r\n            return !(rowDiff === 0 || colDiff === 0);\r\n\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"n\"\r\n        }\r\n    }\r\n    class Pawn extends Piece {\r\n        points = 100\r\n        name = Piece.PAWN\r\n\r\n        whiteScore = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5, -5,-10,  0,  0,-10, -5,  5],\r\n            [5, 10, 10,-20,-20, 10, 10,  5],\r\n            [0,  0,  0,  0,  0,  0,  0,  0]\r\n        ]\r\n        whiteScoreEnd = [\r\n            [100,  100,  100,  100,  100,  100,  100,  100],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5, -5,-10,  0,  0,-10, -5,  5],\r\n            [5, 10, 10,-20,-20, 10, 10,  5],\r\n            [0,  0,  0,  0,  0,  0,  0,  0]\r\n        ]\r\n        blackScore = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [5, 10, 10,-40,-40, 10, 10,  5],\r\n            [5, 10,20,  0,  0,-10, -5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n        ]\r\n        blackScoreEnd = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [5, 10, 10,-40,-40, 10, 10,  5],\r\n            [5, 10,20,  0,  0,-10, -5,  5],\r\n            [0,  0,  0, 20, 20,  0,  0,  0],\r\n            [5,  5, 10, 25, 25, 10,  5,  5],\r\n            [10, 10, 20, 30, 30, 20, 10, 10],\r\n            [50, 50, 50, 50, 50, 50, 50, 50],\r\n            [100,  100,  100,  100,  100,  100,  100,  100],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            const moves = []\r\n            let newRow = this.cell.row + 1 * this.colour\r\n            let newCol = this.cell.col\r\n            if (board.canMove(newRow, newCol)) {\r\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol),\r\n                    this, undefined, undefined, undefined,\r\n                    newRow === 0 || newRow === 7)\r\n                    moves.push(move)\r\n\r\n                newRow = this.cell.row + 2 * this.colour\r\n                if (board.canMove(newRow, newCol) && (newRow === 3 || newRow === 4)) {\r\n                    if (this.colour === Piece.BLACK && this.cell.row === 1) {\r\n                        const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n\r\n                            moves.push(move)\r\n\r\n                    } else if (this.colour === Piece.WHITE && this.cell.row === 6) {\r\n                        const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                            moves.push(move)\r\n                    }\r\n\r\n                }\r\n            }\r\n            newRow = this.cell.row + 1 * this.colour\r\n            newCol = this.cell.col + 1\r\n            if (board.canEat(newRow, newCol, this.colour)) {\r\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\r\n                    newRow === 0 || newRow === 7)\r\n                    moves.push(move)\r\n            }\r\n            // en passant\r\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\r\n                const prevMove = board.moves.slice(-1)[0]\r\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col + 1\r\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this, true)\r\n                        moves.push(move)\r\n                }\r\n\r\n            }\r\n            newRow = this.cell.row + 1 * this.colour\r\n            newCol = this.cell.col - 1\r\n            if (board.canEat(newRow, newCol, this.colour)) {\r\n                const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\r\n                    newRow === 0 || newRow === 7)\r\n                    moves.push(move)\r\n            }\r\n            // en passant\r\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\r\n                const prevMove = board.moves.slice(-1)[0]\r\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col - 1\r\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this, true)\r\n                    moves.push(move)\r\n                }\r\n\r\n            }\r\n            return moves\r\n        }\r\n        isCheck = (board, king) => {\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            const newRow = this.cell.row + 1 * this.colour\r\n            const newCol = this.cell.col + 1\r\n            const newColOpp = this.cell.col - 1\r\n            return newRow === kingRow && (newCol === kingCol || newColOpp === kingCol)\r\n        }\r\n\r\n        /**\r\n         * Moves the piece\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            // const old = board[move.oldCell.row][move.oldCell.col]\r\n            // promotion\r\n            if (move.isEnPassant) {\r\n                const prevMove = boardObject.moves.slice(-1)[0]\r\n                const oldPiece = board[prevMove.newCell.row][prevMove.newCell.col]\r\n                if (oldPiece !== null) {\r\n                    move.ate = oldPiece\r\n                }\r\n                board[prevMove.newCell.row][prevMove.newCell.col] = null\r\n            }\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n            if (move.isPromotion) {\r\n                board[newRow][newCol] = new Queen(this.colour, this.cell)\r\n            }\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"p\"\r\n        }\r\n    }\r\n    class Queen extends Piece {\r\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1], [0,1], [1,0], [0,-1],[-1,0]]\r\n        points = 900\r\n        name = Piece.QUEEN\r\n\r\n        whiteScore = [\r\n            [-20,-10,-10, -5, -5,-10,-10,-20],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-10,  0,  5,  5,  5,  5,  0,-10],\r\n            [-5,  0,  5,  5,  5,  5,  0, -5],\r\n            [0,  0,  5,  5,  5,  5,  0, -5],\r\n            [-10,  5,  5,  5,  5,  5,  0,-10],\r\n            [-10,  0,  5,  0,  0,  0,  0,-10],\r\n            [-20,-10,-10, -5, -5,-10,-10,-20]\r\n        ]\r\n        blackScore = [\r\n            [-20,-10,-10, -5, -5,-10,-10,-20],\r\n            [-10,  0,  5,  0,  0,  0,  0,-10],\r\n            [-10,  5,  5,  5,  5,  5,  0,-10],\r\n            [0,  0,  5,  5,  5,  5,  0, -5],\r\n            [-5,  0,  5,  5,  5,  5,  0, -5],\r\n            [-10,  0,  5,  5,  5,  5,  0,-10],\r\n            [-10,  0,  0,  0,  0,  0,  0,-10],\r\n            [-20,-10,-10, -5, -5,-10,-10,-20],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                        moves.push(move)\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        isCheck = (board, king) => {\r\n            const row = this.cell.row\r\n            const col = this.cell.col\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            const rowDiff = Math.abs(row - kingRow)\r\n            const colDiff = Math.abs(col - kingCol)\r\n            if ((rowDiff !== colDiff) && kingCol !== col && kingRow !== row) {\r\n                return false\r\n            }\r\n            const currentRow = this.cell.row\r\n            const currentCol = this.cell.col\r\n            for (const direction of this.directions) {\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\r\n                            return true\r\n                        }\r\n                        break;\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return false\r\n\r\n        }\r\n\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"q\"\r\n        }\r\n    }\r\n    class Rook extends Piece {\r\n        directions = [[0,1], [1,0], [0,-1],[-1,0]]\r\n        points = 500\r\n        name = Piece.ROOK\r\n        whiteScore = [\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n            [5, 10, 10, 10, 10, 10, 10,  5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [0,  0,  0,  5,  5,  0,  0,  0]\r\n        ]\r\n        blackScore = [\r\n            [0,  0,  4,  5,  5,  10,  0,  0],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [-5,  0,  0,  0,  0,  0,  0, -5],\r\n            [5, 10, 10, 10, 10, 10, 10,  5],\r\n            [0,  0,  0,  0,  0,  0,  0,  0],\r\n        ]\r\n        constructor(colour, cell) {\r\n            super(colour, cell)\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns valid moves of a piece (move object)\r\n         * @param board chess board, object\r\n         */\r\n        getMoves = (board) => {\r\n            const moves = []\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    const move = new Move(new Cell(currentRow, currentCol), new Cell(newRow, newCol), this)\r\n                        moves.push(move)\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return moves\r\n        }\r\n        isCheck = (board, king) => {\r\n            const row = this.cell.row\r\n            const col = this.cell.col\r\n            const kingRow = king.cell.row\r\n            const kingCol = king.cell.col\r\n            if (kingCol !== col && kingRow !== row) {\r\n                return false\r\n            }\r\n            for (const direction of this.directions) {\r\n                const currentRow = this.cell.row\r\n                const currentCol = this.cell.col\r\n                const row = direction[0]\r\n                const col = direction[1]\r\n                let newRow = row + currentRow\r\n                let newCol = col + currentCol\r\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\r\n                    if (board.canEat(newRow, newCol, this.colour)) {\r\n                        if (board.getPiece(newRow, newCol).name === Piece.KING) {\r\n                            return true\r\n                        }\r\n                        break\r\n                    }\r\n                    newRow +=row\r\n                    newCol +=col\r\n                }\r\n            }\r\n            return false\r\n\r\n        }\r\n        /**\r\n         * Moves the piece, updates the board object as well\r\n         */\r\n        movePiece = (move, boardObject) => {\r\n            const board = boardObject.getBoard()\r\n            const newRow = move.newCell.row\r\n            const newCol = move.newCell.col\r\n            const oldPiece = board[newRow][newCol]\r\n            if (oldPiece !== null) {\r\n                move.ate = oldPiece\r\n            }\r\n\r\n            board[newRow][newCol] = this\r\n            board[move.oldCell.row][move.oldCell.col] = null\r\n            this.cell = new Cell(newRow, newCol)\r\n        }\r\n\r\n        getString = () => {\r\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\r\n            return colourString + \"r\"\r\n        }\r\n    }\r\n\r\n        try {\r\n            const data = message.data\r\n            const boardString = data[0]\r\n            const depth = data[1]\r\n            const moveString = data[2]\r\n            const colour = data[3]\r\n            totalMoves = moveString.length\r\n            if (totalMoves === 0) {\r\n                if (colour === Piece.WHITE) {\r\n                    // equal chance to play d4, e4\r\n                    const moves = [\r\n                        new Move(new Cell(6, 3), new Cell(4,3), new Pawn(Piece.WHITE, new Cell(6, 3))),\r\n                        new Move(new Cell(6, 4), new Cell(4,4), new Pawn(Piece.WHITE, new Cell(6, 4))),\r\n                    ]\r\n                    const randomIndex = Math.round(Math.random() * (moves.length - 1))\r\n\r\n                    postMessage(moves[randomIndex].getMoveString())\r\n                }\r\n            } else if (totalMoves === 1) {\r\n                // equal chance to play c5 / e5, in response to e4\r\n                const getMove = moveString.map(x => Move.parseMove(undefined, x))[0]\r\n                if (getMove.oldCell.row === 6 && getMove.oldCell.col === 4 && getMove.newCell.row === 4 && getMove.newCell.col === 4) {\r\n                    const moves = [\r\n                        new Move(new Cell(1, 2), new Cell(3,2), new Pawn(Piece.BLACK, new Cell(1, 2))),\r\n                        new Move(new Cell(1, 4), new Cell(3,4), new Pawn(Piece.BLACK, new Cell(1, 4))),\r\n                    ]\r\n                    const randomIndex = Math.round(Math.random() * (moves.length - 1))\r\n\r\n                    postMessage(moves[randomIndex].getMoveString())\r\n                } else {\r\n                    const nextMove = ab(boardString, depth, moveString, colour)\r\n                    postMessage(nextMove.getMoveString())\r\n                }\r\n            } else {\r\n                const nextMove = ab(boardString, depth, moveString, colour)\r\n                postMessage(nextMove.getMoveString())\r\n            }\r\n        } catch (e) {\r\n            postMessage({isError: true, message:\"Error: \" + e})\r\n        }\r\n\r\n}\r\n// eslint-disable-next-line no-restricted-globals,no-undef\r\nself.addEventListener(\"message\", test);\r\n"],"names":["totalMoves","self","addEventListener","async","message","mem","Map","ab","boardString","depth","moveString","colour","copyBoard","Board","setBoardString","moves","map","x","Move","parseMove","isEndGame","console","log","setEndGame","updatePieceValues","i","set","result","miniMax","Number","MAX_VALUE","board","alpha","beta","maxPlayer","currentPlayer","getAllMoves","bestMove","sort","sortMoves","maxEval","illegal","length","move","movePiece","piece","isIllegal","undoMove","undefined","currentEval","miniMaxCore","Math","max","isCheck","minEval","min","prevMoves","slice","ate","quiesce","getScore","moveOrder","arr","get","find","e","isEqualMove","j","MAX_KILLER","a","b","points","memSlot","slot","killerMove","Piece","WHITE","whiteScore","newCell","row","col","blackScore","oldCell","constructor","evaluation","score","this","newBoard","Rook","BLACK","Cell","Knight","Bishop","Queen","King","Pawn","getPiece","whiteScoreEnd","blackScoreEnd","whitePawnCount","blackPawnCount","openFiles","hasPawn","push","openCol","openRow","past","doubled","countWhitePieces","countBlackPieces","countWhiteQueen","countBlackQueen","newRow","pieceString","actualColour","getBoardHash","str","isEmpty","getString","getBoard","isOutSide","isUnderCheck","canEat","canMove","canKingMove","directions","direction","newCol","name","KING","pop","prevRow","prevCol","getBoardString","cell","isEnPassant","isPromotion","castle","isCastle","rook","kingHasMoved","rookHasMoved","side","KING_SIDE","ROOK","castlingSquaresIsEmpty","cols","king","opp","moveRow","moveCol","squares","getMoves","concat","scanSquaresScore","materialScore","getMoveString","oldCellRow","oldCellCol","newCellRow","newCellCol","static","data","parsePieceString","rookObj","BISHOP","super","currentRow","currentCol","kingRow","kingCol","abs","boardObject","oldPiece","QUEEN_SIDE","KNIGHT","rowDiff","colDiff","PAWN","prevMove","newColOpp","QUEEN","randomIndex","round","random","postMessage","getMove","nextMove","isError"],"sourceRoot":""}