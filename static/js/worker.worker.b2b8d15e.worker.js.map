{"version":3,"file":"static/js/worker.worker.b2b8d15e.worker.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","Chess/logic/Piece.js","Chess/logic/Cell.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js","Chess/logic/Pieces/Queen.js","Chess/logic/Move.js","Chess/ai/worker.worker.js"],"sourcesContent":["export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return assertThisInitialized(self);\n}","class Piece {\n    static WHITE = -1\n    static BLACK = 1\n    isAlive = true\n    constructor(colour, cell, moves= []) {\n        this.colour = colour // white or black\n        this.cell = cell\n        this.moves = moves // moves made by the piece so far, [[startRow, startCol, endRow, endCol]], most recent at the back (can pop())\n    }\n    // each piece should have methods:\n    // getMoves(board, prevMoves: array of pieces moved so far(for castling)) returns array of coordinates of valid moves\n\n\n    // special\n    // en passant: use moves done\n    // castling: use moves + need check if pieces are under attack done\n    // promotion: row, col done\n    // pieces that can move under check\n    // for each piece move, calculate if its legal (king will not be under check) done\n    // if move is executed, king should not be under check\n    // TODO: is game over: king under check + no piece of that colour can move\n}\nexport default Piece","/**\n * This class represents a coordinate on the chess board\n */\nclass Cell {\n    constructor(row, col) {\n        this.row = row\n        this.col = col\n    }\n}\nexport default Cell","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _classPrivateFieldBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}","var id = 0;\nexport default function _classPrivateFieldKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}","import Piece from \"../Piece\"\nimport imageWhite from \"../../images/wq.png\"\nimport imageBlack from \"../../images/bq.png\"\nimport Move from \"../Move\"\nimport Cell from \"../Cell\";\nclass Queen extends Piece {\n    #directions = [[1,1], [-1,-1], [1,-1],[-1,1], [0,1], [1,0], [0,-1],[-1,0]]\n    points = 9\n    constructor(colour, cell, moves) {\n        super(colour, cell, moves)\n        if (colour === Piece.WHITE) {\n            this.image = imageWhite\n        } else {\n            this.image = imageBlack\n        }\n    }\n\n    /**\n     * Returns valid moves of a piece (move object)\n     * @param board chess board, object\n     */\n    getMoves = (board) => {\n        const moves = []\n        for (const direction of this.#directions) {\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            const row = direction[0]\n            const col = direction[1]\n            let newRow = row + currentRow\n            let newCol = col + currentCol\n            while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                if (!board.willCheck(this, move)) {\n                    moves.push(move)\n                }\n                if (board.canEat(newRow, newCol, this.colour)) {\n                    break\n                }\n                newRow +=row\n                newCol +=col\n            }\n        }\n        return moves\n    }\n    getAttack = (board) => {\n        const moves = []\n        for (const direction of this.#directions) {\n            const currentRow = this.cell.row\n            const currentCol = this.cell.col\n            const row = direction[0]\n            const col = direction[1]\n            let newRow = row + currentRow\n            let newCol = col + currentCol\n            while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n                if (board.canEatDefend(newRow, newCol)) {\n                    break\n                }\n                newRow +=row\n                newCol +=col\n            }\n        }\n        return moves\n    }\n    /**\n     * Moves the piece, updates the board object as well\n     */\n    movePiece = (move, boardObject) => {\n        const board = boardObject.getBoard()\n        const newRow = move.newCell.row\n        const newCol = move.newCell.col\n        const oldPiece = board[newRow][newCol]\n        if (oldPiece !== null) {\n            move.ate = oldPiece\n        }\n        board[newRow][newCol] = this\n        board[move.oldCell.row][move.oldCell.col] = null\n        this.cell = new Cell(newRow, newCol)\n        this.moves.push(move)\n\n        return {row: newRow, col: newCol}\n\n    }\n\n    getString = () => {\n        const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n        return colourString + \"q\"\n    }\n}\n\nexport default Queen","import Cell from \"./Cell\";\nimport Queen from \"./Pieces/Queen\";\n\nclass Move {\n    oldCell\n    newCell\n\n    constructor(oldCell, newCell, piece, isEnPassant = false,\n                castle = {isCastle: false}, ate = null, isPromotion = false) {\n        this.oldCell = oldCell\n        this.newCell = newCell\n        this.piece = piece\n        this.isEnPassant = isEnPassant\n        this.castle = castle\n        this.ate = ate\n        this.isPromotion = isPromotion\n    }\n\n    static getMoveString = (move) => {\n        return {\n            oldCellRow: move.oldCell.row,\n            oldCellCol: move.oldCell.col,\n            newCellRow: move.newCell.row,\n            newCellCol: move.newCell.col,\n            pieceString: move.piece.getString(),\n            isEnPassant: move.isEnPassant,\n            castle: move.castle.isCastle === false ? {isCastle: false} : {isCastle: true,\n                rook:{\n                    pieceString : move.castle.rook.piece.getString(),\n                    oldCellRow: move.castle.rook.oldCell.row,\n                    oldCellCol: move.castle.rook.oldCell.col,\n                    newCellRow: move.castle.rook.newCell.row,\n                    newCellCol: move.castle.rook.newCell.col,\n                }},\n            ate: move.ate !== null ? move.ate.getString() : null,\n            isPromotion: move.isPromotion\n        }\n    }\n    \n    static parseMove = (game, data) => {\n        const parseMove = new Move(\n            new Cell(data.oldCellRow, data.oldCellCol),\n            new Cell(data.newCellRow, data.newCellCol),\n            game.board.getPiece(data.oldCellRow, data.oldCellCol),\n            data.isEnPassant,\n            {isCastle: false}, // TODO : handle\n            game.board.getPiece(data.newCellRow, data.newCellCol),\n            data.isPromotion\n        )\n        if (data.isPromotion) {\n            game.board.promotePiece(new Queen(game.board.getPiece(data.oldCellRow, data.oldCellCol).colour,\n                game.board.getPiece(data.oldCellRow, data.oldCellCol).cell))\n        }\n        if (data.castle.isCastle) {\n            const rookObj = data.castle.rook\n            parseMove.castle.isCastle = true\n            parseMove.castle.rook = new Move(new Cell(rookObj.oldCellRow, rookObj.oldCellCol)\n                , new Cell(rookObj.newCellRow, rookObj.newCellCol), game.board.getPiece(rookObj.oldCellRow, rookObj.oldCellCol))\n        }\n        return parseMove\n    }\n\n}\nexport default Move","import pawn from \"../logic/Pieces/Pawn\";\n\nlet totalMoves = 0\nlet mem = new Map()\nlet isEndGame = false\nconst test = async (message) => {\n   // https://chess.stackexchange.com/questions/40362/my-transposition-tables-implementation-slows-down-alpha-beta-pruning\n    // https://github.com/maksimKorzh/chess_programming/blob/master/src/negamax/tutorials/alpha-beta_quiescence_search/chess.c\n    //https://stackoverflow.com/questions/29990116/alpha-beta-prunning-with-transposition-table-iterative-deepening\n    if (true) {\n        mem = new Map()\n    }\n    // console.log(\"mem\", mem.size)\n    // TODO: check if endgame before running search, set score tables before search, done after set board string\n    // End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\n    // TODO: update piece score tables based on position before running search, done after set board string\n    // for knight, -5 per missing pawn of any colour\n    // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\n    // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\n    // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\n    // sort a-b moves, closer to center === better, check first done\n\n    const ab =  (boardString, depth, moveString, colour) => {\n        totalMoves++\n        const copyBoard = new Board()\n        copyBoard.setBoardString(boardString)\n        const start = performance.now()\n        copyBoard.moves = moveString.map(x => Move.parseMove(copyBoard, x))\n        isEndGame = copyBoard.isEndGame()\n        if (isEndGame) {\n            console.log(\"endgame\")\n            copyBoard.setEndGame()\n        }\n        copyBoard.updatePieceValues()\n        console.log(copyBoard.board)\n        const result = miniMax(copyBoard, depth, -Number.MAX_VALUE, Number.MAX_VALUE, true, colour, colour, depth)\n        // const result = rootNegaMax(depth, copyBoard, Piece.BLACK, Piece.BLACK)\n        const end = performance.now()\n        console.log(end - start, totalMoves)\n        console.log(\"Score\", result[1])\n        return result[0] // should be a move\n    }\n\n    const evaluate = (board, colour) => { // TODO: improve heursitics, engine elo determined here\n        return board.getScore(colour)\n    }\n\n    const switchColour = (colour) => {\n        return colour === Piece.BLACK ? Piece.WHITE : Piece.BLACK\n    }\n\n    const miniMax = (board, depth, alpha, beta, isMax, maxPlayer, currentPlayer, orgDepth) => {\n        if (depth === 0) {\n            // const result = evaluate(board, maxPlayer)\n            let result\n            // if (maxPlayer === currentPlayer && board.moves.slice(-1)[0].ate !== null) {\n            //     result = quiesce(alpha, beta, board, currentPlayer, 1)\n            // } else {\n            //     const boardHash = board.getBoardHash() + maxPlayer.toString()\n            //     if (mem.has(boardHash)) {\n            //         result = mem.get(boardHash)\n            //     } else {\n            //         result = evaluate(board, maxPlayer)\n            //         mem.set(boardHash, result)\n            //     }\n            // }\n            const boardHash = board.getBoardHash() + maxPlayer.toString()\n            if (mem.has(boardHash)) {\n                result = mem.get(boardHash)\n            } else {\n                result = evaluate(board, maxPlayer)\n                mem.set(boardHash, result)\n            }\n\n            return [null, result]\n        }\n        const testGameOver = board.isGameOver(currentPlayer)\n        if (testGameOver.isGameOver && currentPlayer === maxPlayer) {\n            return [null, -Number.MAX_VALUE]\n        }\n        if (testGameOver.isGameOver && currentPlayer !== maxPlayer) {\n            return [null, Number.MAX_VALUE]\n        }\n        const moves = testGameOver.allMoves\n        moves.sort(sortMoves)\n        const randomIndex = Math.floor(Math.random() * (moves.length - 1))\n        let bestMove = moves.length > 0 ? moves[randomIndex] : null\n\n        if (isMax){\n            let maxEval = -Number.MAX_VALUE\n            for (const move of moves) {\n                board.movePiece(move.piece, move)\n                const currentEval = miniMax(board, depth - 1, alpha, beta, false, maxPlayer, switchColour(currentPlayer), orgDepth)[1]\n                board.undoMove()\n                if (currentEval > maxEval) {\n                    maxEval = currentEval\n                    bestMove = move\n                }\n                alpha = Math.max(alpha, currentEval)\n                if (beta <= alpha) {\n                    break\n                }\n            }\n            return [bestMove, maxEval]\n        } else {\n            let minEval = Number.MAX_VALUE\n            for (const move of moves) {\n                board.movePiece(move.piece, move)\n                const currentEval = miniMax(board, depth - 1, alpha, beta, true, maxPlayer, switchColour(currentPlayer), orgDepth)[1]\n                board.undoMove()\n                if (currentEval < minEval) {\n                    minEval = currentEval\n                    bestMove = move\n                }\n                beta = Math.min(beta, currentEval)\n                if (beta <= alpha) {\n                    break\n                }\n            }\n            return [bestMove, minEval]\n        }\n    }\n\n    const sortMovesQuiesce = (a, b) => {\n        if (a.ate !== null && b.ate !== null) {\n            const aScore = a.piece.points - a.ate.points\n            const bScore = b.piece.points - b.ate.points\n            return aScore < bScore ? 1: -1\n        } else if (a.ate !== null) {\n            return -1\n        } else if (b.ate !== null) {\n            return 1\n        }\n        return 0\n    }\n    const sortMoves = (a, b) => {\n        if (a.ate !== null && b.ate !== null) {\n            const aScore = a.piece.points - a.ate.points\n            const bScore = b.piece.points - b.ate.points\n            return aScore < bScore ? -1: 1\n        } else if (a.ate !== null) {\n            return -1\n        } else if (b.ate !== null) {\n            return 1\n        } else {\n            const aScore = a.piece.colour === Piece.WHITE ? a.piece.whiteScore[a.newCell.row][a.newCell.col] : a.piece.blackScore[a.newCell.row][a.newCell.col]\n            const bScore = b.piece.colour === Piece.WHITE ? b.piece.whiteScore[b.newCell.row][b.newCell.col] : b.piece.blackScore[b.newCell.row][b.newCell.col]\n            return aScore < bScore ? 1: -1\n        }\n    }\n\n    const quiesce = (alpha, beta, board, colour, depth) => {\n        let evaluation\n        const boardHash = board.getBoardHash() + colour.toString()\n        if (mem.has(boardHash)) {\n            evaluation = mem.get(boardHash)\n        } else {\n            evaluation = evaluate(board, colour)\n            mem.set(boardHash, evaluation)\n        }\n\n        if (depth === 0) {\n            return evaluation\n        }\n        if (evaluation >= beta) {\n            return beta\n        }\n\n        alpha = Math.max(alpha, evaluation)\n        const moves = board.getAllMoves(colour)\n        moves.sort(sortMoves)\n        for (const move of moves) {\n            if (move.ate !== null && move.ate.points < move.piece.points) { //  && move.ate.points > move.piece.points\n                board.movePiece(move.piece, move)\n                let score = -quiesce(-beta, -alpha, board, switchColour(colour), depth - 1)\n                board.undoMove()\n                if (score >= beta) {\n                    return beta\n                }\n                if (score > alpha) {\n                    alpha = score\n                }\n            }\n        }\n        return alpha\n    }\n\n    const quiesceOdd = (alpha, beta, board, colour, depth) => {\n        // const evaluation = evaluate(board, colour)\n        let evaluation\n        const boardHash = board.getBoardHash() + colour.toString()\n        if (mem.has(boardHash)) {\n            evaluation = mem.get(boardHash)\n        } else {\n            evaluation = evaluate(board, colour)\n            mem.set(boardHash, evaluation)\n        }\n\n        if (depth === 0) {\n            return evaluation\n        }\n        if (evaluation >= beta) {\n            return beta\n        }\n\n        alpha = Math.max(alpha, evaluation)\n        const moves = board.getAllMoves(colour)\n        moves.sort(sortMovesQuiesce)\n        for (const move of moves) {\n            if (move.ate !== null) { //  && move.ate.points > move.piece.points\n                board.movePiece(move.piece, move)\n                let score = -quiesce(-beta, -alpha, board, switchColour(colour), depth - 1)\n                board.undoMove()\n                if (score >= beta) {\n                    return beta\n                }\n                if (score > alpha) {\n                    alpha = score\n                }\n            }\n        }\n        return alpha\n    }\n\n    const negaMax = (depth, board, colour, maxColour) => {\n        if (depth === 0) {\n            return evaluate(board, maxColour)\n        }\n        const testGameOver = board.isGameOver(colour).isGameOver\n        if (testGameOver && colour === maxColour) {\n            return -Number.MAX_VALUE\n        }\n        if (testGameOver && colour !== maxColour) {\n            return Number.MAX_VALUE\n        }\n        let max = -Number.MAX_VALUE\n        const moves = board.getAllMoves(colour)\n        for (const move of moves) {\n            board.movePiece(move.piece, move)\n            const currentEval = -negaMax(depth - 1, board, switchColour(colour), maxColour)\n            if (currentEval > max) {\n                max = currentEval\n            }\n            board.undoMove()\n        }\n        return max\n    }\n    const rootNegaMax = (depth, board, colour, maxColour) => {\n        const rootMoves = board.getAllMoves(maxColour)\n        let max = -Number.MAX_VALUE\n        const randomIndex = Math.floor(Math.random() * (rootMoves.length - 1))\n        let bestMove = rootMoves.length > 0 ? rootMoves[randomIndex] : null\n        for (const move of rootMoves) {\n            board.movePiece(move.piece, move)\n            const score = negaMax(depth, board, colour, maxColour)\n            if (score > max) {\n                max = score\n                bestMove = move\n            }\n            board.undoMove()\n        }\n        return bestMove\n\n    }\n    class Board {\n        board;\n\n        constructor() {\n            this.board = this.newBoard()\n            this.moves = []\n        }\n\n        newBoard = () => {\n            const startingBoard = [\n                [new Rook(Piece.BLACK, new Cell(0,0)), new Knight(Piece.BLACK, new Cell(0, 1)), new Bishop(Piece.BLACK, new Cell(0, 2)), new Queen(Piece.BLACK, new Cell(0, 3)), new King(Piece.BLACK, new Cell(0, 4)), new Bishop(Piece.BLACK, new Cell(0, 5)), new Knight(Piece.BLACK, new Cell(0, 6)), new Rook(Piece.BLACK, new Cell(0,7))],\n                [new Pawn(Piece.BLACK, new Cell(1, 0)), new Pawn(Piece.BLACK, new Cell(1, 1)), new Pawn(Piece.BLACK, new Cell(1, 2)), new Pawn(Piece.BLACK, new Cell(1, 3)), new Pawn(Piece.BLACK, new Cell(1, 4)), new Pawn(Piece.BLACK, new Cell(1, 5)), new Pawn(Piece.BLACK, new Cell(1, 6)), new Pawn(Piece.BLACK, new Cell(1, 7))],\n                [null, null, null, null, null, null, null, null],\n                [null, null, null, null, null, null, null, null],\n                [null, null, null, null, null, null, null, null],\n                [null, null, null, null, null, null, null, null],\n                [new Pawn(Piece.WHITE, new Cell(6, 0)), new Pawn(Piece.WHITE, new Cell(6, 1)), new Pawn(Piece.WHITE, new Cell(6, 2)), new Pawn(Piece.WHITE, new Cell(6, 3)), new Pawn(Piece.WHITE, new Cell(6, 4)), new Pawn(Piece.WHITE, new Cell(6, 5)), new Pawn(Piece.WHITE, new Cell(6, 6)), new Pawn(Piece.WHITE, new Cell(6, 7))],\n                [new Rook(Piece.WHITE, new Cell(7,0)), new Knight(Piece.WHITE, new Cell(7, 1)), new Bishop(Piece.WHITE, new Cell(7, 2)), new Queen(Piece.WHITE, new Cell(7, 3)), new King(Piece.WHITE, new Cell(7, 4)), new Bishop(Piece.WHITE, new Cell(7, 5)), new Knight(Piece.WHITE, new Cell(7, 6)), new Rook(Piece.WHITE, new Cell(7,7))],\n            ]\n            return startingBoard\n        }\n        // update piece square tables for endgame\n        setEndGame = () => {\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null && piece.whiteScoreEnd !== undefined) {\n                        if (piece.colour === Piece.WHITE) {\n                            piece.whiteScore = piece.whiteScoreEnd\n                        } else {\n                            piece.blackScore = piece.blackScoreEnd\n                        }\n                    }\n                }\n            }\n        }\n        // update values of pieces\n        updatePieceValues = () => {\n            // for knight, -5 per missing pawn of any colour done\n            // for bishop, fianchetto bonus points, control over square colour (using pawns), bishop pair bonus\n            // rook penalty for trap by king, bonus for open file, bonus for each missing pawn\n            // pawn, increase value +30 if past pawn (no pawns of opposing colour on the 3 cols), decrease value if doubled (-10)\n            let whitePawnCount = 0\n            let blackPawnCount = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        if (piece instanceof Pawn) {\n                            if (piece.colour === Piece.WHITE) {\n                                whitePawnCount++\n                            } else {\n                                blackPawnCount++\n                            }\n                        }\n                    }\n                }\n            }\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        if (piece instanceof Knight) {\n                            piece.points-= ((16 - whitePawnCount - blackPawnCount) * 3)\n                        }\n                        if (piece instanceof Bishop) {\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\n                        }\n                        if (piece instanceof Rook) {\n                            piece.points+= ((16 - whitePawnCount - blackPawnCount) * 3)\n                        }\n                        if (piece instanceof Pawn) {\n                            let past = true\n                            if (col + 1 < 8) {\n                                for (let i = 0; i < 8; i++) {\n                                    if (this.getPiece(i, col + 1) instanceof Pawn) {\n                                        past = false\n                                    }\n                                }\n                            }\n                            if (col - 1 >= 0) {\n                                for (let i = 0; i < 8; i++) {\n                                    if (this.getPiece(i, col - 1) instanceof Pawn) {\n                                        past = false\n                                    }\n                                }\n                            }\n                            if (past) {\n                                piece.points+=30\n                            }\n                            let doubled = false\n                            for (let i = 0; i < 8; i++) {\n                                if (piece instanceof Pawn && i !== row) {\n                                    doubled = true\n                                }\n                            }\n                            if (doubled) {\n                                piece.points-=10\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        isEndGame = () => {\n            // End game defined by: either side has a queen + pawns only / either side has at most 2 minor pieces\n            let countWhitePieces = 0\n            let countBlackPieces = 0\n            let countWhiteQueen = 0\n            let countBlackQueen = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece instanceof Queen) {\n                        if (piece.colour === Piece.WHITE) {\n                            countWhiteQueen++\n                        } else {\n                            countBlackQueen++\n                        }\n                    }\n                    if (piece instanceof Rook || piece instanceof Bishop || piece instanceof Knight) {\n                        if (piece.colour === Piece.WHITE) {\n                            countWhitePieces++\n                        } else {\n                            countBlackPieces++\n                        }\n                    }\n                }\n            }\n            return ((countWhiteQueen <= 1 && countWhitePieces <=0) || (countBlackQueen <= 1  && countBlackPieces <=0))\n                || ((countWhitePieces <=2 && countWhiteQueen <= 0) || (countBlackPieces <=2  && countBlackQueen <= 0))\n        }\n\n        setBoardString = (boardString) => {\n            const newBoard = []\n            for (let row = 0; row < 8; row++) {\n                const newRow = []\n                for (let col = 0; col < 8; col++) {\n                    const pieceString = boardString[row][col]\n                    if (pieceString === null) {\n                        newRow.push(null)\n                    } else {\n                        const pieceColour = pieceString.slice(0, 1)\n                        const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\n                        const piece = pieceString.slice(1, 2)\n                        if (piece === \"b\") {\n                            newRow.push(new Bishop(actualColour, new Cell(row, col)))\n                        } else if (piece === 'k') {\n                            newRow.push(new King(actualColour, new Cell(row, col)))\n                        } else if (piece === 'n') {\n                            newRow.push(new Knight(actualColour, new Cell(row, col)))\n                        } else if (piece === 'p') {\n                            newRow.push(new Pawn(actualColour, new Cell(row, col)))\n                        } else if (piece === 'q') {\n                            newRow.push(new Queen(actualColour, new Cell(row, col)))\n                        } else if (piece === 'r') {\n                            newRow.push(new Rook(actualColour, new Cell(row, col)))\n                        } else {\n                            newRow.push(null)\n                        }\n                    }\n                }\n                newBoard.push(newRow)\n            }\n            this.board = newBoard\n        }\n\n        getBoardHash = () => {\n            let str = \"\"\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col)) {\n                        str += this.getPiece(row, col).getString()\n                    } else {\n                        str += \" \"\n                    }\n                }\n            }\n            return str\n        }\n\n        clonePiece = (piece) => {\n            if (piece instanceof Pawn) {\n                return new Pawn(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n            } else if (piece instanceof Bishop) {\n                return new Bishop(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n            } else if (piece instanceof King) {\n                return new King(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n            } else if (piece instanceof Knight) {\n                return new Knight(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n            } else if (piece instanceof Queen) {\n                return new Queen(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n            } else if (piece instanceof Rook) {\n                return new Rook(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n            }\n            return null\n        }\n\n        /**\n         * Returns the board represented by the array\n         */\n        getBoard = () => {\n            return this.board\n        }\n        /**\n         * Returns piece at the coordinates\n         */\n        getPiece = (row, col) => {\n            return this.board[row][col]\n        }\n\n        /**\n         * Returns if the cell is empty\n         */\n        isEmpty = (row, col) => {\n            if (this.isOutSide(row, col)) {\n                return false\n            }\n            return this.board[row][col] === null\n        }\n        isUnderCheck = (colour) => {\n            return false\n        }\n        isOutSide = (row, col) => {\n            return row < 0 || col < 0 || row > 7 || col > 7\n        }\n\n        canEat = (row, col, colour) => {\n            return !this.isOutSide(row, col) && !this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour\n        }\n\n        canEatDefend = (row, col) => {\n            return !this.isOutSide(row, col) && !this.isEmpty(row, col)\n        }\n\n        canMove = (row, col) => {\n            return !this.isOutSide(row, col) && this.isEmpty(row, col)\n        }\n\n        canKingMove = (row, col, colour) => {\n            const directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\n            for (const direction of directions) {\n                const newRow = row + direction[0]\n                const newCol = col + direction[1]\n                if (!this.isOutSide(newRow, newCol) && !this.isEmpty(newRow, newCol)\n                    && (this.getPiece(newRow, newCol).name === Piece.KING && this.getPiece(newRow, newCol).colour !== colour)) {\n                    return false\n                }\n            }\n            return true\n        }\n        /**\n         * Returns the squares, marked by moves, that are under attack by the opposing colour\n         * @param colour\n         * @return {*[]}\n         */\n        getAttackingSquares = (colour) => { // colour is for piece being attacked\n            const squares = []\n            const defense = []\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col)) {\n                        const getPc = this.getPiece(row, col)\n                        if (getPc.colour !== colour && !(getPc.name === Piece.KING)) {\n                            const moves = getPc.getAttack(this)\n                            squares.push.apply(squares, moves) // better performance\n                        }\n                    // else if (getPc.colour === colour && !(getPc instanceof King)) {\n                    //         const moves = getPc.getAttack(this)\n                    //         defense.push.apply(defense, moves) // TODO: may remove, performance\n                    //     }\n                    }\n                }\n            }\n            return [squares, defense]\n        }\n\n        movePiece = (piece, move) => {\n            const result =  this.board[move.oldCell.row][move.oldCell.col].movePiece(move, this)\n            this.moves.push(move)\n            return result\n        }\n\n        undoMove = () => {\n            if (this.moves.length > 0) {\n                const move = this.moves.pop()\n                const prevRow = move.oldCell.row\n                const prevCol = move.oldCell.col\n                const piece = this.board[move.newCell.row][move.newCell.col]\n                this.board[prevRow][prevCol] = piece\n                piece.moves.pop()\n                piece.cell.row = prevRow\n                piece.cell.col = prevCol\n                if (move.isEnPassant) { // add back pawn\n                    this.board[move.ate.cell.row][move.ate.cell.col] = move.ate\n                    this.board[move.newCell.row][move.newCell.col] = null\n                    return true\n                } else if (move.isPromotion) { // remove piece, add back pawn\n                    this.board[prevRow][prevCol] = new Pawn(piece.colour, piece.cell, piece.moves)\n                } else if (move.castle.isCastle) { // king will be undone, need to undo rook\n                    this.board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = move.castle.rook.piece\n                    move.castle.rook.piece.cell.row = move.castle.rook.oldCell.row\n                    move.castle.rook.piece.cell.col = move.castle.rook.oldCell.col\n                    this.board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = null\n                }\n                this.board[move.newCell.row][move.newCell.col] = move.ate\n                return true\n            }\n            return false\n        }\n\n        kingHasMoved = (colour) => {\n            for (const move of this.moves) {\n                if (move.piece.name === Piece.KING && move.piece.colour === colour) {\n                    return true\n                }\n            }\n            return false\n        }\n\n        rookHasMoved = (colour, side) => {\n            const row = colour === Piece.BLACK ? 0 : 7\n            const col = side === King.KING_SIDE ? 7 : 0\n            if (!(this.getPiece(row, col) !== null && this.getPiece(row, col).name === Piece.ROOK)) { // no rook on cell\n                return true\n            }\n            for (const move of this.moves) {\n                if (move.piece.name === Piece.ROOK && move.piece.colour === colour && move.oldCell.row === row && move.oldCell.col === col) {\n                    return true\n                }\n            }\n            return false\n        }\n\n        castlingSquaresIsEmpty = (colour, side) => {\n            const row = colour === Piece.BLACK ? 0 : 7\n            const cols = side === King.KING_SIDE ? [5,6] : [1,2,3]\n            for (const col of cols) {\n                if (!this.isEmpty(row, col)) {\n                    return false\n                }\n            }\n            return true\n        }\n        castlingSquaresUnderAttack = (colour, side, attacked) => { // includes the king himself\n            const row = colour === Piece.BLACK ? 0 : 7\n            const cols = side === King.KING_SIDE ? [4,5,6] : [1,2,3,4]\n            for (const col of cols) {\n                for (const move of attacked) {\n                    if (move.newCell.row === row && move.newCell.col === col) {\n                        return true\n                    }\n                }\n            }\n            return false\n        }\n\n        canCastle = (colour, side, attacked) => {\n            return this.castlingSquaresIsEmpty(colour, side) && !this.castlingSquaresUnderAttack(colour, side, attacked)\n                && !this.rookHasMoved(colour, side) && !this.kingHasMoved(colour)\n        }\n\n        promotePiece = (piece) => {\n            const row = piece.cell.row\n            const col = piece.cell.col\n            this.board[row][col] = piece\n        }\n\n        // returns if colour is under check\n        isCheck = (colour, attackArray = null) => {\n            const attacked = attackArray === null ? this.getAttackingSquares(colour)[0] : attackArray\n            for (const move of attacked) {\n                const piece = this.getPiece(move.newCell.row, move.newCell.col)\n                if (piece !== null && piece.name === Piece.KING\n                    && piece.colour === colour) {\n                    return true\n                }\n            }\n            return false\n        }\n\n        /**\n         * This functions determines if a move will result in your own King being under check (illegal move)\n         * @param piece\n         * @param move\n         */\n        willCheck = (piece, move) => {\n            this.movePiece(piece, move)\n            if (this.isCheck(piece.colour)) {\n                this.undoMove()\n                return true\n            }\n            this.undoMove()\n            return false\n        }\n        getAllMoves = (colour) => {\n            let moves = []\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.board[row][col]\n                    if (piece !== null && this.getPiece(row, col).colour === colour) {\n                        moves = moves.concat(this.getPiece(row, col).getMoves(this))\n                    }\n                }\n            }\n            return moves\n        }\n\n        /**\n         * Defined by: same position occurs thrice for threefold repetition\n         * @param times\n         * @return {boolean}\n         */\n        isRepeatPosition = (numMoves) => {\n            const lengthCheck = numMoves\n            if (this.moves.length >= lengthCheck) {\n                const getLastNMoves = this.moves.slice(-lengthCheck)\n                let firstMove = getLastNMoves[0]\n                let secondMove = getLastNMoves[1]\n                for (let i = 2; i < lengthCheck; i+=4) {\n                    const current = getLastNMoves[i]\n                    const currentTwo = getLastNMoves[i+1]\n                    if (!(current.newCell.row === firstMove.oldCell.row && current.newCell.col === firstMove.oldCell.col && firstMove.piece === current.piece)) {\n                        return false\n                    }\n                    if (!(currentTwo.newCell.row === secondMove.oldCell.row && currentTwo.newCell.col === secondMove.oldCell.col && secondMove.piece === currentTwo.piece)) {\n                        return false\n                    }\n                }\n                return true\n            }\n            return false\n        }\n\n        /**\n         * Checks if game is over for colour, means other colour wins\n         * @param colour\n         * @return {{isGameOver: boolean, message: string}}\n         */\n        isGameOver = (colour) => {\n            const allMoves = this.getAllMoves(colour)\n            const player = colour === Piece.BLACK ? \"White\" : \"Black\"\n            if (allMoves.length <= 0) {\n                return {isGameOver: true, message: player + \" wins by checkmate\", allMoves: allMoves}\n            }\n            return {isGameOver: false, message: \"\", allMoves: allMoves}\n        }\n\n        getAllMoves = (colour) => {\n            let squares = []\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    if (!this.isEmpty(row, col) && this.getPiece(row, col).colour === colour) {\n                        const piece = this.getPiece(row, col)\n                        const moves = piece.getMoves(this)\n                        squares = squares.concat(moves)\n                    }\n                }\n            }\n            return squares\n        }\n        /**\n         * Goes through board for positional eval, like piece development, hardcoded for black\n         */\n        scanSquaresScore = (colour) => {\n            let score = 0\n            let materialScore = 0\n            for (let row = 0; row < 8; row++) {\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        if (piece.colour === Piece.WHITE) {\n                            materialScore += piece.points\n                        } else {\n                            materialScore -= piece.points\n                        }\n                        // const moves = piece.getMoves(this)\n                        // //board control\n                        // score += moves.length\n                        // // piece mobility\n                        // if (piece instanceof Bishop) {\n                        //     score += (moves.length * 3)\n                        // } else if (piece instanceof Knight) {\n                        //     score += (moves.length * 3)\n                        // } else if (piece instanceof Queen) {\n                        //     score += (moves.length * 6)\n                        // } else if (piece instanceof Rook) {\n                        //     score += (moves.length * 5)\n                        // }\n\n                        // development / positional score\n                        if (piece.colour === Piece.WHITE) {\n                            score += piece.whiteScore[row][col]\n                        } else {\n                            score -= piece.blackScore[row][col]\n                        }\n\n                        // double pawns bad for ai, but good if he doubles opponent's pawn\n                        // if (piece.name === Piece.PAWN && piece.colour === Piece.WHITE) {\n                        //     if (!this.isEmpty(row + 1, col) && this.getPiece(row + 1, col).name === Piece.PAWN && piece.colour === Piece.WHITE) {\n                        //         score -= 20\n                        //     }\n                        // } else if (piece.name === Piece.PAWN && piece.colour !== Piece.WHITE) {\n                        //     if (!this.isEmpty(row - 1, col) && this.getPiece(row - 1, col).name === Piece.PAWN && piece.colour !== Piece.WHITE) {\n                        //         score += 20\n                        //     }\n                        // }\n                        // under check == bad, check opponent == good\n                        // if (piece.name === Piece.KING && piece.colour === colour) {\n                        //     if (this.isCheck(colour, attacked)) {\n                        //         score -= 10\n                        //     }\n                        // }\n                        // else if (piece instanceof King && piece.colour === opponentColour) {\n                        //     if (this.isCheck(opponentColour, attacked)) {\n                        //         score += 10\n                        //     }\n                        // }\n                    }\n                }\n            }\n            // if (this.board[3][4] instanceof Pawn && this.board[3][4].colour === Piece.WHITE\n            // && this.board) {\n            //     console.log(this.board)\n            // }\n            return score + materialScore\n        }\n\n        /**\n         * used for minimax heuristics\n         * @param colour colour making the next move\n         * @return {number} score of position\n         */\n        getScore = (colour) => {\n            const opponentColour = colour === Piece.WHITE ? Piece.BLACK : Piece.WHITE\n            // let materialScore = 0 // material control\n            // for (let row = 0; row < 8; row ++) {\n            //     for (let col = 0; col < 8; col ++) {\n            //         const piece = this.board[row][col]\n            //         if (piece instanceof Piece && piece.colour === colour) {\n            //             materialScore += piece.points\n            //         }\n            //         if (piece instanceof Piece && piece.colour !== colour) {\n            //             materialScore -= piece.points\n            //         }\n            //     }\n            // }\n            // const attackedSquares = this.getAttackingSquares(opponentColour) // heavy operation\n            // const attackScore = attackedSquares[0].length // board control\n            // const defenseScore = attackedSquares[1].length // defense\n            const positionalScore = this.scanSquaresScore(colour)\n            return (positionalScore) * colour * -1\n        }\n\n        getBoardString = () => {\n            const newBoard = []\n            for (let row = 0; row < 8; row++) {\n                const newRow = []\n                for (let col = 0; col < 8; col++) {\n                    const piece = this.getPiece(row, col)\n                    if (piece !== null) {\n                        newRow.push(piece.getString())\n                    } else {\n                        newRow.push(null)\n                    }\n                }\n                newBoard.push(newRow)\n            }\n            return newBoard\n        }\n\n    }\n    /**\n     * This class represents a coordinate on the chess board\n     */\n    class Cell {\n        constructor(row, col) {\n            this.row = row\n            this.col = col\n        }\n    }\n    class Game {\n        // game has a board, game has players, game has turns, game has time\n        turnColour = Piece.WHITE\n        constructor() {\n            this.board = new Board()\n            this.players = [new Player(Piece.WHITE), new Player(Piece.BLACK)]\n        }\n\n        movePiece = (piece, move) => {\n            const result =  this.board.movePiece(piece, move)\n            this.turnColour = this.turnColour === Piece.WHITE ? Piece.BLACK : Piece.WHITE\n            return result\n        }\n        /**\n         * Get pieces eaten by colour\n         * @param colour\n         * @return {*[]}\n         */\n        getEatenPieces = (colour) => {\n            const moves = this.board.moves\n            return moves.filter(move => {\n                return move.ate !== null && move.ate.colour !== colour\n            }).map(x => x.ate)\n        }\n\n        undoMove = () => {\n            const isUndo = this.board.undoMove()\n            if (isUndo) {\n                this.turnColour = this.turnColour === Piece.WHITE ? Piece.BLACK : Piece.WHITE\n            }\n        }\n\n    }\n    class Move {\n        oldCell\n        newCell\n\n        constructor(oldCell, newCell, piece, isEnPassant = false,\n                    castle = {isCastle: false}, ate = null, isPromotion = false) {\n            this.oldCell = oldCell\n            this.newCell = newCell\n            this.piece = piece\n            this.isEnPassant = isEnPassant\n            this.castle = castle\n            this.ate = ate\n            this.isPromotion = isPromotion\n        }\n\n        getMoveString = () => {\n            return {\n                oldCellRow: this.oldCell.row,\n                oldCellCol: this.oldCell.col,\n                newCellRow: this.newCell.row,\n                newCellCol: this.newCell.col,\n                pieceString: this.piece.getString(),\n                isEnPassant: this.isEnPassant,\n                castle: this.castle.isCastle === false ? {isCastle: false} : {isCastle: true,\n                    rook:{\n                    pieceString : this.castle.rook.piece.getString(),\n                    oldCellRow: this.castle.rook.oldCell.row,\n                    oldCellCol: this.castle.rook.oldCell.col,\n                    newCellRow: this.castle.rook.newCell.row,\n                    newCellCol: this.castle.rook.newCell.col,\n                }},\n                ate: this.ate !== null ? this.ate.getString() : null,\n                isPromotion: this.isPromotion\n            }\n        }\n        static parseMove = (board, data) => {\n            const parseMove = new Move(\n                new Cell(data.oldCellRow, data.oldCellCol),\n                new Cell(data.newCellRow, data.newCellCol),\n                Piece.parsePieceString(data.pieceString),\n                data.isEnPassant,\n                {isCastle: false}, // TODO : handle\n                null,\n                data.isPromotion\n            )\n\n            if (data.castle.isCastle) {\n                const rookObj = data.castle.rook\n                parseMove.castle.isCastle = true\n                parseMove.castle.rook = new Move(new Cell(rookObj.oldCellRow, rookObj.oldCellCol)\n                    , new Cell(rookObj.newCellRow, rookObj.newCellCol), board.getPiece(rookObj.oldCellRow, rookObj.oldCellCol))\n            }\n            return parseMove\n        }\n\n    }\n    class Piece {\n        static WHITE = -1\n        static BLACK = 1\n        static ROOK = \"r\"\n        static BISHOP = \"b\"\n        static KNIGHT = \"n\"\n        static KING = \"k\"\n        static QUEEN = \"q\"\n        static PAWN = \"p\"\n        constructor(colour, cell, moves= []) {\n            this.colour = colour // white or black\n            this.cell = cell\n            this.moves = moves // moves made by the piece so far, [[startRow, startCol, endRow, endCol]], most recent at the back (can pop())\n        }\n        static parsePieceString = (pieceString) => {\n            const pieceColour = pieceString.slice(0, 1)\n            const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\n            const piece = pieceString.slice(1, 2)\n            if (piece === \"b\") {\n                return new Bishop(actualColour, new Cell(0, 0))\n            } else if (piece === 'k') {\n                return new King(actualColour, new Cell(0, 0))\n            } else if (piece === 'n') {\n                return new Knight(actualColour, new Cell(0, 0))\n            } else if (piece === 'p') {\n                return new Pawn(actualColour, new Cell(0, 0))\n            } else if (piece === 'q') {\n                return new Queen(actualColour, new Cell(0, 0))\n            } else if (piece === 'r') {\n                return new Rook(actualColour, new Cell(0, 0))\n            } else {\n                return null\n            }\n        }\n    }\n    class Player {\n        // player has colour\n        constructor(colour) {\n            this.colour = colour\n        }\n    }\n    class Bishop extends Piece {\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1]]\n        points = 330\n        name = Piece.BISHOP\n        whiteScore = [\n            [-20,-10,-10,-10,-10,-10,-10,-20],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-10,  0,  5, 10, 10,  5,  0,-10],\n            [-10,  5,  5, 10, 10,  5,  5,-10],\n            [-10,  0, 10, 10, 10, 10,  0,-10],\n            [-10, 10, 10, 10, 10, 10, 10,-10],\n            [-10,  5,  0,  0,  0,  0,  5,-10],\n            [-20,-10,-10,-10,-10,-10,-10,-20]\n        ]\n        blackScore = [\n            [-20,-10,-10,-10,-10,-10,-10,-20],\n            [-10,  5,  0,  0,  0,  0,  5,-10],\n            [-10, 10, 10, 10, 10, 10, 10,-10],\n            [-10,  0, 10, 10, 10, 10,  0,-10],\n            [-10,  5,  5, 10, 10,  5,  5,-10],\n            [-10,  0,  5, 10, 10,  5,  0,-10],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-20,-10,-10,-10,-10,-10,-10,-20],\n        ]\n        constructor(colour, cell, moves) {\n            super(colour, cell, moves)\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        getAttack = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                    moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n                    if (board.canEatDefend(newRow, newCol)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n            this.moves.push(move)\n\n            return {row: newRow, col: newCol}\n\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"b\"\n        }\n    }\n    class King extends Piece {\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\n        static KING_SIDE = 'king'\n        static QUEEN_SIDE = 'queen'\n        name = Piece.KING\n        points = 20000\n\n        whiteScore = [\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-20,-30,-30,-40,-40,-30,-30,-20],\n            [-10,-20,-20,-20,-20,-20,-20,-10],\n            [20, 20,  0,  0,  0,  0, 20, 20],\n            [20, 30, 10,  0,  0, 10, 30, 20]\n        ]\n\n        blackScore = [\n            [20, 30, 10,  0,  0, 10, 30, 20],\n            [20, 20,  0,  0,  0,  0, 20, 20],\n            [-10,-20,-20,-20,-20,-20,-20,-10],\n            [-20,-30,-30,-40,-40,-30,-30,-20],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n            [-30,-40,-40,-50,-50,-40,-40,-30],\n        ]\n        whiteScoreEnd = [\n            [-50,-40,-30,-20,-20,-30,-40,-50],\n            [-30,-20,-10,  0,  0,-10,-20,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-30,  0,  0,  0,  0,-30,-30],\n            [-50,-30,-30,-30,-30,-30,-30,-50]\n        ]\n        blackScoreEnd = [\n            [-50,-30,-30,-30,-30,-30,-30,-50],\n            [-30,-30,  0,  0,  0,  0,-30,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 30, 40, 40, 30,-10,-30],\n            [-30,-10, 20, 30, 30, 20,-10,-30],\n            [-30,-20,-10,  0,  0,-10,-20,-30],\n            [-50,-40,-30,-20,-20,-30,-40,-50],\n        ]\n        constructor(colour, cell, moves) {\n            super(colour, cell, moves)\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            const attacked = board.getAttackingSquares(this.colour)[0]\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const newRow = row + currentRow\n                const newCol = col + currentCol\n                if (((board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol))) && board.canKingMove(newRow, newCol, this.colour)) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                }\n            }\n\n            const filterAttacked = moves.filter(move => { // king cannot move to squares under attack by enemy / pieces that are defended\n                for (const attack of attacked) {\n                    if (move.newCell.row === attack.newCell.row && move.newCell.col === attack.newCell.col) {\n                        return false\n                    }\n                }\n                return true\n            })\n            // castling move: if king has not moved + rook on respective square has not moved done\n            // + squares in between and king not attacked  + squares in between are empty\n            if (board.canCastle(this.colour, King.KING_SIDE, attacked)) {\n                const row = this.colour === Piece.BLACK ? 0 : 7\n                const col = 6\n                filterAttacked.push(new Move(this.cell, new Cell(row, col), this, false,\n                    {isCastle: true, rook: new Move(new Cell(row, 7), new Cell(row, 5), board.getPiece(row, 7))}))\n            }\n            if (board.canCastle(this.colour, King.QUEEN_SIDE, attacked)) {\n                const row = this.colour === Piece.BLACK ? 0 : 7\n                const col = 2\n                filterAttacked.push(new Move(this.cell, new Cell(row, col), this, false,\n                    {isCastle: true, rook: new Move(new Cell(row, 0), new Cell(row, 3), board.getPiece(row, 0))}))\n            }\n            return filterAttacked\n        }\n        getAttack = (board) => {\n            return this.getMoves(board)\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            if (move.castle.isCastle) {\n                board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = move.castle.rook.piece\n                board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = null\n                move.castle.rook.piece.cell.row = move.castle.rook.newCell.row\n                move.castle.rook.piece.cell.col = move.castle.rook.newCell.col\n            }\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n            this.moves.push(move)\n\n            return {row: newRow, col: newCol}\n\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"k\"\n        }\n    }\n    class Knight extends Piece {\n        directions = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n\n        points = 320\n        name = Piece.KNIGHT\n\n        whiteScore = [\n            [-50,-40,-30,-30,-30,-30,-40,-50],\n            [-40,-20,  0,  0,  0,  0,-20,-40],\n            [-30,  0, 10, 15, 15, 10,  0,-30],\n            [-30,  5, 15, 20, 20, 15,  5,-30],\n            [-30,  0, 15, 20, 20, 15,  0,-30],\n            [-30,  5, 10, 15, 15, 10,  5,-30],\n            [-40,-20,  0,  5,  5,  0,-20,-40],\n            [-50,-40,-30,-30,-30,-30,-40,-50]\n        ]\n\n        blackScore = [\n            [-50,-40,-30,-30,-30,-30,-40,-50],\n            [-40,-20,  0,  5,  5,  0,-20,-40],\n            [-30,  5, 10, 15, 15, 10,  5,-30],\n            [-30,  0, 15, 20, 20, 15,  0,-30],\n            [-30,  5, 15, 20, 20, 15,  5,-30],\n            [-30,  0, 10, 15, 15, 10,  0,-30],\n            [-40,-20,  0,  0,  0,  0,-20,-40],\n            [-50,-40,-30,-30,-30,-30,-40,-50],\n        ]\n        constructor(colour, cell, moves) {\n            super(colour, cell, moves)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const newRow = row + currentRow\n                const newCol = col + currentCol\n                if (board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol)) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                }\n            }\n            return moves\n        }\n        getAttack = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const row = direction[0]\n                const col = direction[1]\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const newRow = row + currentRow\n                const newCol = col + currentCol\n                if (board.canEatDefend(newRow, newCol) || board.canMove(newRow, newCol)) {\n                    moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n                }\n            }\n            return moves\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n            this.moves.push(move)\n\n            return {row: newRow, col: newCol}\n\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"n\"\n        }\n    }\n    class Pawn extends Piece {\n        points = 100\n        name = Piece.PAWN\n\n        whiteScore = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5, -5,-10,  0,  0,-10, -5,  5],\n            [5, 10, 10,-20,-20, 10, 10,  5],\n            [0,  0,  0,  0,  0,  0,  0,  0]\n        ]\n        whiteScoreEnd = [\n            [100,  100,  100,  100,  100,  100,  100,  100],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5, -5,-10,  0,  0,-10, -5,  5],\n            [5, 10, 10,-20,-20, 10, 10,  5],\n            [0,  0,  0,  0,  0,  0,  0,  0]\n        ]\n        blackScore = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [5, 10, 10,-40,-40, 10, 10,  5],\n            [5, 10,20,  0,  0,-10, -5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [0,  0,  0,  0,  0,  0,  0,  0],\n        ]\n        blackScoreEnd = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [5, 10, 10,-40,-40, 10, 10,  5],\n            [5, 10,20,  0,  0,-10, -5,  5],\n            [0,  0,  0, 20, 20,  0,  0,  0],\n            [5,  5, 10, 25, 25, 10,  5,  5],\n            [10, 10, 20, 30, 30, 20, 10, 10],\n            [50, 50, 50, 50, 50, 50, 50, 50],\n            [100,  100,  100,  100,  100,  100,  100,  100],\n        ]\n        constructor(colour, cell, moves) {\n            super(colour, cell, moves)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            let newRow = this.cell.row + 1 * this.colour\n            let newCol = this.cell.col\n            if (board.canMove(newRow, newCol)) {\n                const move = new Move(this.cell, new Cell(newRow, newCol),\n                    this, undefined, undefined, undefined,\n                    newRow === 0 || newRow === 7)\n                if (!board.willCheck(this, move)) {\n                    moves.push(move)\n                }\n                newRow = this.cell.row + 2 * this.colour\n                if (board.canMove(newRow, newCol) && this.moves.length <= 0) {\n                    if (this.colour === Piece.BLACK && this.cell.row === 1) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                    } else if (this.colour === Piece.WHITE && this.cell.row === 6) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                    }\n\n                }\n            }\n            newRow = this.cell.row + 1 * this.colour\n            newCol = this.cell.col + 1\n            if (board.canEat(newRow, newCol, this.colour)) {\n                const move = new Move(this.cell, new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\n                    newRow === 0 || newRow === 7)\n                if (!board.willCheck(this, move)) {\n                    moves.push(move)\n                }\n            }\n            // en passant\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\n                const prevMove = board.moves.slice(-1)[0]\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col + 1\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this, true)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                }\n\n            }\n            newRow = this.cell.row + 1 * this.colour\n            newCol = this.cell.col - 1\n            if (board.canEat(newRow, newCol, this.colour)) {\n                const move = new Move(this.cell, new Cell(newRow, newCol), this , undefined, undefined, board.getPiece(newRow, newCol),\n                    newRow === 0 || newRow === 7)\n                if (!board.willCheck(this, move)) {\n                    moves.push(move)\n                }\n            }\n            // en passant\n            if (board.canMove(newRow, newCol) && board.moves.length > 0) {\n                const prevMove = board.moves.slice(-1)[0]\n                if (prevMove.piece.name === Piece.PAWN && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col - 1\n                    && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this, true)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                }\n\n            }\n            return moves\n        }\n        getAttack = (board) => {\n            const moves = []\n            let newRow = this.cell.row + 1 * this.colour\n            let newCol = this.cell.col + 1\n            if (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n            }\n            newRow = this.cell.row + 1 * this.colour\n            newCol = this.cell.col - 1\n            if (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n            }\n            return moves\n        }\n        /**\n         * Moves the piece\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            // const old = board[move.oldCell.row][move.oldCell.col]\n            // promotion\n            if (move.isEnPassant) {\n                const prevMove = boardObject.moves.slice(-1)[0]\n                const oldPiece = board[prevMove.newCell.row][prevMove.newCell.col]\n                if (oldPiece !== null) {\n                    move.ate = oldPiece\n                }\n                board[prevMove.newCell.row][prevMove.newCell.col] = null\n            }\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n            if (move.isPromotion) {\n                board[newRow][newCol] = new Queen(this.colour, this.cell)\n                return {promotion: true, row: newRow, col: newCol}\n            }\n\n\n            this.moves.push(move)\n            return {row: newRow, col: newCol}\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"p\"\n        }\n    }\n    class Queen extends Piece {\n        directions = [[1,1], [-1,-1], [1,-1],[-1,1], [0,1], [1,0], [0,-1],[-1,0]]\n        points = 900\n        name = Piece.QUEEN\n\n        whiteScore = [\n            [-20,-10,-10, -5, -5,-10,-10,-20],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-10,  0,  5,  5,  5,  5,  0,-10],\n            [-5,  0,  5,  5,  5,  5,  0, -5],\n            [0,  0,  5,  5,  5,  5,  0, -5],\n            [-10,  5,  5,  5,  5,  5,  0,-10],\n            [-10,  0,  5,  0,  0,  0,  0,-10],\n            [-20,-10,-10, -5, -5,-10,-10,-20]\n        ]\n        blackScore = [\n            [-20,-10,-10, -5, -5,-10,-10,-20],\n            [-10,  0,  5,  0,  0,  0,  0,-10],\n            [-10,  5,  5,  5,  5,  5,  0,-10],\n            [0,  0,  5,  5,  5,  5,  0, -5],\n            [-5,  0,  5,  5,  5,  5,  0, -5],\n            [-10,  0,  5,  5,  5,  5,  0,-10],\n            [-10,  0,  0,  0,  0,  0,  0,-10],\n            [-20,-10,-10, -5, -5,-10,-10,-20],\n        ]\n        constructor(colour, cell, moves) {\n            super(colour, cell, moves)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        getAttack = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                    moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n                    if (board.canEatDefend(newRow, newCol)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n            this.moves.push(move)\n\n            return {row: newRow, col: newCol}\n\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"q\"\n        }\n    }\n    class Rook extends Piece {\n        directions = [[0,1], [1,0], [0,-1],[-1,0]]\n        points = 500\n        name = Piece.ROOK\n        whiteScore = [\n            [0,  0,  0,  0,  0,  0,  0,  0],\n            [5, 10, 10, 10, 10, 10, 10,  5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [0,  0,  0,  5,  5,  0,  0,  0]\n        ]\n        blackScore = [\n            [0,  0,  4,  5,  5,  10,  0,  0],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [-5,  0,  0,  0,  0,  0,  0, -5],\n            [5, 10, 10, 10, 10, 10, 10,  5],\n            [0,  0,  0,  0,  0,  0,  0,  0],\n        ]\n        constructor(colour, cell, moves) {\n            super(colour, cell, moves)\n\n        }\n\n        /**\n         * Returns valid moves of a piece (move object)\n         * @param board chess board, object\n         */\n        getMoves = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                    if (board.canEat(newRow, newCol, this.colour)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        getAttack = (board) => {\n            const moves = []\n            for (const direction of this.directions) {\n                const currentRow = this.cell.row\n                const currentCol = this.cell.col\n                const row = direction[0]\n                const col = direction[1]\n                let newRow = row + currentRow\n                let newCol = col + currentCol\n                while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                    moves.push(move)\n                    if (board.canEatDefend(newRow, newCol)) {\n                        break\n                    }\n                    newRow +=row\n                    newCol +=col\n                }\n            }\n            return moves\n        }\n        /**\n         * Moves the piece, updates the board object as well\n         */\n        movePiece = (move, boardObject) => {\n            const board = boardObject.getBoard()\n            const newRow = move.newCell.row\n            const newCol = move.newCell.col\n            const oldPiece = board[newRow][newCol]\n            if (oldPiece !== null) {\n                move.ate = oldPiece\n            }\n\n            board[newRow][newCol] = this\n            board[move.oldCell.row][move.oldCell.col] = null\n            this.cell = new Cell(newRow, newCol)\n            this.moves.push(move)\n\n            return {row: newRow, col: newCol}\n\n        }\n\n        getString = () => {\n            const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n            return colourString + \"r\"\n        }\n    }\n\n        try {\n            const data = message.data\n            if (data.newGame) {\n                totalMoves = 0\n                mem = new Map()\n            } else if (data.undo) {\n                totalMoves--\n                mem = new Map()\n            } else {\n                const boardString = data[0]\n                const depth = data[1]\n                const moveString = data[2]\n                const colour = data[3]\n                if (totalMoves === 0) {\n                    if (colour === Piece.WHITE) {\n                        // equal chance to play d4, e4\n                        const moves = [\n                            new Move(new Cell(6, 3), new Cell(4,3), new Pawn(Piece.WHITE, new Cell(6, 3))),\n                            new Move(new Cell(6, 4), new Cell(4,4), new Pawn(Piece.WHITE, new Cell(6, 4))),\n                        ]\n                        const randomIndex = Math.round(Math.random() * (moves.length - 1))\n\n                        postMessage(moves[randomIndex].getMoveString())\n                    } else {\n                        // equal chance to play c5 / e5, in response to e4\n                        const getMove = moveString.map(x => Move.parseMove(undefined, x))[0]\n                        if (getMove.oldCell.row === 6 && getMove.oldCell.col === 4 && getMove.newCell.row === 4 && getMove.newCell.col === 4) {\n                            const moves = [\n                                new Move(new Cell(1, 2), new Cell(3,2), new Pawn(Piece.BLACK, new Cell(1, 2))),\n                                new Move(new Cell(1, 4), new Cell(3,4), new Pawn(Piece.BLACK, new Cell(1, 4))),\n                            ]\n                            const randomIndex = Math.round(Math.random() * (moves.length - 1))\n\n                            postMessage(moves[randomIndex].getMoveString())\n                        } else {\n                            const nextMove = ab(boardString, depth, moveString, colour)\n                            postMessage(nextMove.getMoveString())\n                        }\n                    }\n                    totalMoves++\n                } else {\n                    const nextMove = ab(boardString, depth, moveString, colour)\n                    postMessage(nextMove.getMoveString())\n                }\n            }\n\n        } catch (e) {\n            postMessage({isError: true, message:\"Error: \" + e})\n        }\n\n\n\n\n}\n// eslint-disable-next-line no-restricted-globals,no-undef\nself.addEventListener(\"message\", test);\n"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toPropertyKey","arg","key","input","hint","prim","toPrimitive","undefined","res","call","TypeError","String","Number","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_createClass","Constructor","protoProps","staticProps","_classCallCheck","instance","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","o","p","setPrototypeOf","bind","__proto__","_inherits","subClass","superClass","create","value","_getPrototypeOf","getPrototypeOf","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","e","result","Super","NewTarget","this","arguments","apply","Piece","colour","cell","moves","isAlive","WHITE","BLACK","Cell","row","col","_arrayLikeToArray","arr","len","arr2","Array","_createForOfIteratorHelper","allowArrayLike","it","isArray","minLen","n","toString","slice","name","from","test","F","s","done","_e","f","err","normalCompletion","didErr","step","next","_e2","_classPrivateFieldBase","receiver","privateKey","hasOwnProperty","id","_classPrivateFieldKey","_directions","_classPrivateFieldLooseKey","_Piece","Queen","_super","_this","points","getMoves","board","_step","_iterator","_classPrivateFieldLooseBase","direction","currentRow","currentCol","newRow","newCol","canMove","canEat","move","Move","willCheck","push","getAttack","_step2","_iterator2","canEatDefend","movePiece","boardObject","getBoard","newCell","oldPiece","ate","oldCell","getString","image","piece","isEnPassant","castle","isCastle","isPromotion","getMoveString","oldCellRow","oldCellCol","newCellRow","newCellCol","pieceString","rook","parseMove","game","data","getPiece","promotePiece","rookObj","totalMoves","mem","Map","isEndGame","addEventListener","async","message","ab","boardString","depth","moveString","copyBoard","Board","setBoardString","start","performance","now","map","x","console","log","setEndGame","updatePieceValues","miniMax","MAX_VALUE","end","evaluate","getScore","switchColour","alpha","beta","isMax","maxPlayer","currentPlayer","orgDepth","boardHash","getBoardHash","has","get","set","testGameOver","isGameOver","allMoves","sort","sortMoves","randomIndex","Math","floor","random","bestMove","maxEval","currentEval","undoMove","max","minEval","min","a","b","whiteScore","blackScore","newBoard","Rook","Knight","Bishop","King","Pawn","whiteScoreEnd","blackScoreEnd","whitePawnCount","blackPawnCount","past","doubled","countWhitePieces","countBlackPieces","countWhiteQueen","countBlackQueen","actualColour","str","isEmpty","clonePiece","isOutSide","isUnderCheck","canKingMove","directions","KING","getAttackingSquares","squares","getPc","pop","prevRow","prevCol","kingHasMoved","rookHasMoved","side","KING_SIDE","ROOK","castlingSquaresIsEmpty","cols","castlingSquaresUnderAttack","attacked","canCastle","isCheck","attackArray","getAllMoves","concat","isRepeatPosition","numMoves","lengthCheck","getLastNMoves","firstMove","secondMove","current","currentTwo","player","scanSquaresScore","score","materialScore","getBoardString","static","parsePieceString","BISHOP","super","filterAttacked","filter","attack","QUEEN_SIDE","KNIGHT","PAWN","prevMove","abs","promotion","QUEEN","newGame","undo","round","postMessage","getMove","nextMove","isError"],"sourceRoot":""}