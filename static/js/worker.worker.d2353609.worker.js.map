{"version":3,"file":"static/js/worker.worker.d2353609.worker.js","mappings":"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","sources":["Chess/ai/worker.worker.js"],"sourcesContent":["\n\n\n    // https://stackoverflow.com/questions/50901954/webworkers-dont-seem-to-be-working-in-production\n    //https://medium.com/@danilog1905/how-to-use-web-workers-with-react-create-app-and-not-ejecting-in-the-attempt-3718d2a1166b\n    // eslint-disable-next-line no-restricted-globals,no-undef\n    const test = async (message) => {\n        console.log(\"working\")\n        let nodes = 0\n        const ab =  (boardString, depth) => {\n            nodes = 0\n            const copyBoard = new Board()\n            copyBoard.setBoardString(boardString)\n            const result = miniMax(copyBoard, depth, -Number.MAX_VALUE, Number.MAX_VALUE, true, Piece.BLACK, Piece.BLACK)\n            return result[0] // should be a move\n        }\n\n        const evaluate = (board, colour) => { // TODO: improve heursitics, engine elo determined here\n            return board.getScore(colour)\n        }\n\n        const switchColour = (colour) => {\n            return colour === Piece.BLACK ? Piece.WHITE : Piece.BLACK\n        }\n\n        const miniMax = (board, depth, alpha, beta, isMax, maxPlayer, currentPlayer) => {\n            // nodes+=1\n            if (depth === 0 || board.isGameOver(currentPlayer).isGameOver) {\n                return [null, evaluate(board, maxPlayer)]\n            }\n            const moves = board.getAllMoves(currentPlayer)\n            const randomIndex = Math.floor(Math.random() * (moves.length - 1))\n            let bestMove = moves.length > 0 ? moves[randomIndex] : null\n\n            if (isMax){\n                let maxEval = -Number.MAX_VALUE\n                for (const move of moves) {\n                    board.movePiece(move.piece, move)\n                    const currentEval = miniMax(board, depth - 1, alpha, beta, false, maxPlayer, switchColour(currentPlayer))[1]\n                    board.undoMove()\n                    if (currentEval > maxEval) {\n                        maxEval = currentEval\n                        bestMove = move\n                    }\n                    alpha = Math.max(alpha, currentEval)\n                    if (beta <= alpha) {\n                        break\n                    }\n                }\n                return [bestMove, maxEval]\n            } else {\n                let minEval = Number.MAX_VALUE\n                for (const move of moves) {\n                    board.movePiece(move.piece, move)\n                    const currentEval = miniMax(board, depth - 1, alpha, beta, true, maxPlayer, switchColour(currentPlayer))[1]\n                    board.undoMove()\n                    if (currentEval < minEval) {\n                        minEval = currentEval\n                        bestMove = move\n                    }\n                    beta = Math.max(beta, currentEval)\n                    if (beta <= alpha) {\n                        break\n                    }\n                }\n                return [bestMove, minEval]\n            }\n        }\n        class Board {\n            board;\n\n            constructor() {\n                this.board = this.newBoard()\n                this.moves = []\n            }\n\n            newBoard = () => {\n                const startingBoard = [\n                    [new Rook(Piece.BLACK, new Cell(0,0)), new Knight(Piece.BLACK, new Cell(0, 1)), new Bishop(Piece.BLACK, new Cell(0, 2)), new Queen(Piece.BLACK, new Cell(0, 3)), new King(Piece.BLACK, new Cell(0, 4)), new Bishop(Piece.BLACK, new Cell(0, 5)), new Knight(Piece.BLACK, new Cell(0, 6)), new Rook(Piece.BLACK, new Cell(0,7))],\n                    [new Pawn(Piece.BLACK, new Cell(1, 0)), new Pawn(Piece.BLACK, new Cell(1, 1)), new Pawn(Piece.BLACK, new Cell(1, 2)), new Pawn(Piece.BLACK, new Cell(1, 3)), new Pawn(Piece.BLACK, new Cell(1, 4)), new Pawn(Piece.BLACK, new Cell(1, 5)), new Pawn(Piece.BLACK, new Cell(1, 6)), new Pawn(Piece.BLACK, new Cell(1, 7))],\n                    [null, null, null, null, null, null, null, null],\n                    [null, null, null, null, null, null, null, null],\n                    [null, null, null, null, null, null, null, null],\n                    [null, null, null, null, null, null, null, null],\n                    [new Pawn(Piece.WHITE, new Cell(6, 0)), new Pawn(Piece.WHITE, new Cell(6, 1)), new Pawn(Piece.WHITE, new Cell(6, 2)), new Pawn(Piece.WHITE, new Cell(6, 3)), new Pawn(Piece.WHITE, new Cell(6, 4)), new Pawn(Piece.WHITE, new Cell(6, 5)), new Pawn(Piece.WHITE, new Cell(6, 6)), new Pawn(Piece.WHITE, new Cell(6, 7))],\n                    [new Rook(Piece.WHITE, new Cell(7,0)), new Knight(Piece.WHITE, new Cell(7, 1)), new Bishop(Piece.WHITE, new Cell(7, 2)), new Queen(Piece.WHITE, new Cell(7, 3)), new King(Piece.WHITE, new Cell(7, 4)), new Bishop(Piece.WHITE, new Cell(7, 5)), new Knight(Piece.WHITE, new Cell(7, 6)), new Rook(Piece.WHITE, new Cell(7,7))],\n                ]\n                return startingBoard\n            }\n\n            setBoardString = (boardString) => {\n                const newBoard = []\n                for (let row = 0; row < 8; row++) {\n                    const newRow = []\n                    for (let col = 0; col < 8; col++) {\n                        const pieceString = boardString[row][col]\n                        if (pieceString === null) {\n                            newRow.push(null)\n                        } else {\n                            const pieceColour = pieceString.slice(0, 1)\n                            const actualColour = pieceColour === \"w\" ? Piece.WHITE : Piece.BLACK\n                            const piece = pieceString.slice(1, 2)\n                            if (piece === \"b\") {\n                                newRow.push(new Bishop(actualColour, new Cell(row, col)))\n                            } else if (piece === 'k') {\n                                newRow.push(new King(actualColour, new Cell(row, col)))\n                            } else if (piece === 'n') {\n                                newRow.push(new Knight(actualColour, new Cell(row, col)))\n                            } else if (piece === 'p') {\n                                newRow.push(new Pawn(actualColour, new Cell(row, col)))\n                            } else if (piece === 'q') {\n                                newRow.push(new Queen(actualColour, new Cell(row, col)))\n                            } else if (piece === 'r') {\n                                newRow.push(new Rook(actualColour, new Cell(row, col)))\n                            } else {\n                                newRow.push(null)\n                            }\n                        }\n                    }\n                    newBoard.push(newRow)\n                }\n                this.board = newBoard\n            }\n\n            clonePiece = (piece) => {\n                if (piece instanceof Pawn) {\n                    return new Pawn(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n                } else if (piece instanceof Bishop) {\n                    return new Bishop(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n                } else if (piece instanceof King) {\n                    return new King(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n                } else if (piece instanceof Knight) {\n                    return new Knight(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n                } else if (piece instanceof Queen) {\n                    return new Queen(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n                } else if (piece instanceof Rook) {\n                    return new Rook(piece.colour, new Cell(piece.cell.row, piece.cell.col))\n                }\n                return null\n            }\n\n            /**\n             * Returns the board represented by the array\n             */\n            getBoard = () => {\n                return this.board\n            }\n            /**\n             * Returns piece at the coordinates\n             */\n            getPiece = (row, col) => {\n                return this.board[row][col]\n            }\n\n            /**\n             * Returns if the cell is empty\n             */\n            isEmpty = (row, col) => {\n                if (this.isOutSide(row, col)) {\n                    return false\n                }\n                return this.board[row][col] === null\n            }\n            isUnderCheck = (colour) => {\n                return false\n            }\n            isOutSide = (row, col) => {\n                return row < 0 || col < 0 || row > 7 || col > 7\n            }\n\n            canEat = (row, col, colour) => {\n                return !this.isOutSide(row, col) && !this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour\n            }\n\n            canEatDefend = (row, col) => {\n                return !this.isOutSide(row, col) && !this.isEmpty(row, col)\n            }\n\n            canMove = (row, col) => {\n                return !this.isOutSide(row, col) && this.isEmpty(row, col)\n            }\n\n            canKingMove = (row, col, colour) => {\n                const directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\n                for (const direction of directions) {\n                    const newRow = row + direction[0]\n                    const newCol = col + direction[1]\n                    if (!this.isOutSide(newRow, newCol) && !this.isEmpty(newRow, newCol)\n                        && (this.getPiece(newRow, newCol) instanceof King && this.getPiece(newRow, newCol).colour !== colour)) {\n                        return false\n                    }\n                }\n                return true\n            }\n            /**\n             * Returns the squares, marked by moves, that are under attack by the opposing colour\n             * @param colour\n             * @return {*[]}\n             */\n            getAttackingSquares = (colour) => { // colour is for piece being attacked\n                let squares = []\n                for (let row = 0; row < 8; row++) {\n                    for (let col = 0; col < 8; col++) {\n                        if (!this.isEmpty(row, col) && this.getPiece(row, col).colour !== colour && !(this.getPiece(row, col) instanceof King)) {\n                            const piece = this.getPiece(row, col)\n                            const moves = piece.getAttack(this)\n                            squares = squares.concat(moves)\n                        }\n                    }\n                }\n                return squares\n            }\n\n            movePiece = (piece, move) => {\n                const result =  this.board[move.oldCell.row][move.oldCell.col].movePiece(move, this)\n                this.moves.push(move)\n                return result\n            }\n\n            undoMove = () => {\n                if (this.moves.length > 0) {\n                    const move = this.moves.pop()\n                    const prevRow = move.oldCell.row\n                    const prevCol = move.oldCell.col\n                    const piece = this.board[move.newCell.row][move.newCell.col]\n                    this.board[prevRow][prevCol] = piece\n                    piece.moves.pop()\n                    piece.cell.row = prevRow\n                    piece.cell.col = prevCol\n                    if (move.isEnPassant) { // add back pawn\n                        this.board[move.ate.cell.row][move.ate.cell.col] = move.ate\n                        this.board[move.newCell.row][move.newCell.col] = null\n                        return true\n                    }\n                    if (move.isPromotion) { // remove piece, add back pawn\n                        this.board[prevRow][prevCol] = new Pawn(piece.colour, piece.cell, piece.moves)\n                    }\n                    if (move.castle.isCastle) { // king will be undone, need to undo rook\n                        this.board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = move.castle.rook.piece\n                        move.castle.rook.piece.cell.row = move.castle.rook.oldCell.row\n                        move.castle.rook.piece.cell.col = move.castle.rook.oldCell.col\n                        this.board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = null\n                    }\n                    this.board[move.newCell.row][move.newCell.col] = move.ate\n                    return true\n                }\n                return false\n            }\n\n            kingHasMoved = (colour) => {\n                for (const move of this.moves) {\n                    if (move.piece instanceof King && move.piece.colour === colour) {\n                        return true\n                    }\n                }\n                return false\n            }\n\n            rookHasMoved = (colour, side) => {\n                const row = colour === Piece.BLACK ? 0 : 7\n                const col = side === King.KING_SIDE ? 7 : 0\n                if (!(this.getPiece(row, col) instanceof Rook)) { // no rook on cell\n                    return true\n                }\n                for (const move of this.moves) {\n                    if (move.piece instanceof Rook && move.piece.colour === colour && move.oldCell.row === row && move.oldCell.col === col) {\n                        return true\n                    }\n                }\n                return false\n            }\n\n            castlingSquaresIsEmpty = (colour, side) => {\n                const row = colour === Piece.BLACK ? 0 : 7\n                const cols = side === King.KING_SIDE ? [5,6] : [1,2,3]\n                for (const col of cols) {\n                    if (!this.isEmpty(row, col)) {\n                        return false\n                    }\n                }\n                return true\n            }\n            castlingSquaresUnderAttack = (colour, side, attacked) => { // includes the king himself\n                const row = colour === Piece.BLACK ? 0 : 7\n                const cols = side === King.KING_SIDE ? [4,5,6] : [1,2,3,4]\n                for (const col of cols) {\n                    for (const move of attacked) {\n                        if (move.newCell.row === row && move.newCell.col === col) {\n                            return true\n                        }\n                    }\n                }\n                return false\n            }\n\n            canCastle = (colour, side, attacked) => {\n                // console.log(this.castlingSquaresIsEmpty(colour, side) , !this.castlingSquaresUnderAttack(colour, side, attacked)\n                //     , !this.rookHasMoved(colour, side) , !this.kingHasMoved(colour))\n                return this.castlingSquaresIsEmpty(colour, side) && !this.castlingSquaresUnderAttack(colour, side, attacked)\n                    && !this.rookHasMoved(colour, side) && !this.kingHasMoved(colour)\n            }\n\n            promotePiece = (piece) => {\n                const row = piece.cell.row\n                const col = piece.cell.col\n                this.board[row][col] = piece\n            }\n\n            // returns if colour is under check\n            isCheck = (colour) => {\n                const attacked = this.getAttackingSquares(colour)\n                for (const move of attacked) {\n                    if (this.getPiece(move.newCell.row, move.newCell.col) instanceof King\n                        && this.getPiece(move.newCell.row, move.newCell.col).colour === colour) {\n                        return true\n                    }\n                }\n                return false\n            }\n\n            /**\n             * This functions determines if a move will result in your own King being under check (illegal move)\n             * @param piece\n             * @param move\n             */\n            willCheck = (piece, move) => {\n                this.movePiece(piece, move)\n                if (this.isCheck(piece.colour)) {\n                    this.undoMove()\n                    return true\n                }\n                this.undoMove()\n                return false\n            }\n            getAllMoves = (colour) => {\n                let moves = []\n                for (let row = 0; row < 8; row++) {\n                    for (let col = 0; col < 8; col++) {\n                        const piece = this.board[row][col]\n                        if (piece !== null && this.getPiece(row, col).colour === colour) {\n                            moves = moves.concat(this.getPiece(row, col).getMoves(this))\n                        }\n                    }\n                }\n                return moves\n            }\n\n            /**\n             * Defined by: same position occurs thrice for threefold repetition\n             * @param times\n             * @return {boolean}\n             */\n            isRepeatPosition = (numMoves) => {\n                const lengthCheck = numMoves\n                if (this.moves.length >= lengthCheck) {\n                    const getLastNMoves = this.moves.slice(-lengthCheck)\n                    let firstMove = getLastNMoves[0]\n                    let secondMove = getLastNMoves[1]\n                    for (let i = 2; i < lengthCheck; i+=4) {\n                        const current = getLastNMoves[i]\n                        const currentTwo = getLastNMoves[i+1]\n                        if (!(current.newCell.row === firstMove.oldCell.row && current.newCell.col === firstMove.oldCell.col && firstMove.piece === current.piece)) {\n                            return false\n                        }\n                        if (!(currentTwo.newCell.row === secondMove.oldCell.row && currentTwo.newCell.col === secondMove.oldCell.col && secondMove.piece === currentTwo.piece)) {\n                            return false\n                        }\n                    }\n                    return true\n                }\n                return false\n            }\n\n            /**\n             * Checks if game is over for colour, means other colour wins\n             * @param colour\n             * @return {{isGameOver: boolean, message: string}}\n             */\n            isGameOver = (colour) => {\n                const allMoves = this.getAllMoves(colour)\n                const underCheck = this.isCheck(colour)\n                const player = colour === Piece.BLACK ? \"White\" : \"Black\"\n                if (underCheck && allMoves.length <= 0) {\n                    return {isGameOver: true, message: player + \" wins by checkmate\"}\n                } else if (!underCheck && allMoves.length <= 0) {\n                    return {isGameOver: true, message: \"Draw by stalemate\"}\n                } else if (this.isRepeatPosition(8)) {\n                    return {isGameOver: true, message: \"Draw by threefold repetition\"}\n                }\n                return {isGameOver: false, message: \"\"}\n            }\n\n            getAllMoves = (colour) => {\n                let squares = []\n                for (let row = 0; row < 8; row++) {\n                    for (let col = 0; col < 8; col++) {\n                        if (!this.isEmpty(row, col) && this.getPiece(row, col).colour === colour) {\n                            const piece = this.getPiece(row, col)\n                            const moves = piece.getMoves(this)\n                            squares = squares.concat(moves)\n                        }\n                    }\n                }\n                return squares\n            }\n\n            /**\n             * used for minimax heuristics\n             * @param colour colour making the next move\n             * @return {number} score of position\n             */\n            getScore = (colour) => {\n                let whiteScore = 0\n                let blackScore = 0\n                let materialScore = 0\n                const opponentColour = colour === Piece.WHITE ? Piece.BLACK : Piece.WHITE\n                for (let row = 0; row < 8; row ++) {\n                    for (let col = 0; col < 8; col ++) {\n                        const piece = this.board[row][col]\n                        if (piece instanceof Piece && piece.colour === colour) {\n                            materialScore += piece.points\n                        }\n                        if (piece instanceof Piece && piece.colour !== colour) {\n                            materialScore -= piece.points\n                        }\n                    }\n                }\n                const attackScore = this.getAttackingSquares(opponentColour).length\n                return materialScore * 0.9\n            }\n\n            getBoardString = () => {\n                const newBoard = []\n                for (let row = 0; row < 8; row++) {\n                    const newRow = []\n                    for (let col = 0; col < 8; col++) {\n                        const piece = this.getPiece(row, col)\n                        if (piece !== null) {\n                            newRow.push(piece.getString())\n                        } else {\n                            newRow.push(null)\n                        }\n                    }\n                    newBoard.push(newRow)\n                }\n                return newBoard\n            }\n\n        }\n        /**\n         * This class represents a coordinate on the chess board\n         */\n        class Cell {\n            constructor(row, col) {\n                this.row = row\n                this.col = col\n            }\n        }\n        class Game {\n            // game has a board, game has players, game has turns, game has time\n            turnColour = Piece.WHITE\n            constructor() {\n                this.board = new Board()\n                this.players = [new Player(Piece.WHITE), new Player(Piece.BLACK)]\n            }\n\n            movePiece = (piece, move) => {\n                const result =  this.board.movePiece(piece, move)\n                this.turnColour = this.turnColour === Piece.WHITE ? Piece.BLACK : Piece.WHITE\n                return result\n            }\n            /**\n             * Get pieces eaten by colour\n             * @param colour\n             * @return {*[]}\n             */\n            getEatenPieces = (colour) => {\n                const moves = this.board.moves\n                return moves.filter(move => {\n                    return move.ate !== null && move.ate.colour !== colour\n                }).map(x => x.ate)\n            }\n\n            undoMove = () => {\n                const isUndo = this.board.undoMove()\n                if (isUndo) {\n                    this.turnColour = this.turnColour === Piece.WHITE ? Piece.BLACK : Piece.WHITE\n                }\n            }\n\n        }\n        class Move {\n            oldCell\n            newCell\n\n            constructor(oldCell, newCell, piece, isEnPassant = false,\n                        castle = {isCastle: false}, ate = null, isPromotion = false) {\n                this.oldCell = oldCell\n                this.newCell = newCell\n                this.piece = piece\n                this.isEnPassant = isEnPassant\n                this.castle = castle\n                this.ate = ate\n                this.isPromotion = isPromotion\n            }\n\n            getMoveString = () => {\n                return {\n                    oldCellRow: this.oldCell.row,\n                    oldCellCol: this.oldCell.col,\n                    newCellRow: this.newCell.row,\n                    newCellCol: this.newCell.col,\n                    pieceString: this.piece.getString(),\n                    isEnPassant: this.isEnPassant,\n                    castle: this.castle.isCastle === false ? {isCastle: false} : {isCastle: true,\n                        rook:{\n                        pieceString : this.castle.rook.piece.getString(),\n                        oldCellRow: this.castle.rook.oldCell.row,\n                        oldCellCol: this.castle.rook.oldCell.col,\n                        newCellRow: this.castle.rook.newCell.row,\n                        newCellCol: this.castle.rook.newCell.col,\n                    }},\n                    ate: this.ate !== null ? this.ate.getString() : null,\n                    isPromotion: this.isPromotion\n                }\n            }\n\n        }\n        class Piece {\n            static WHITE = -1\n            static BLACK = 1\n            isAlive = true\n            constructor(colour, cell, moves= []) {\n                this.colour = colour // white or black\n                this.cell = cell\n                this.moves = moves // moves made by the piece so far, [[startRow, startCol, endRow, endCol]], most recent at the back (can pop())\n            }\n        }\n        class Player {\n            // player has colour\n            constructor(colour) {\n                this.colour = colour\n            }\n        }\n        class Bishop extends Piece {\n            directions = [[1,1], [-1,-1], [1,-1],[-1,1]]\n            points = 3\n            constructor(colour, cell, moves) {\n                super(colour, cell, moves)\n            }\n\n            /**\n             * Returns valid moves of a piece (move object)\n             * @param board chess board, object\n             */\n            getMoves = (board) => {\n                const moves = []\n                for (const direction of this.directions) {\n                    const currentRow = this.cell.row\n                    const currentCol = this.cell.col\n                    const row = direction[0]\n                    const col = direction[1]\n                    let newRow = row + currentRow\n                    let newCol = col + currentCol\n                    while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                        if (board.canEat(newRow, newCol, this.colour)) {\n                            break\n                        }\n                        newRow +=row\n                        newCol +=col\n                    }\n                }\n                return moves\n            }\n            getAttack = (board) => {\n                const moves = []\n                for (const direction of this.directions) {\n                    const currentRow = this.cell.row\n                    const currentCol = this.cell.col\n                    const row = direction[0]\n                    const col = direction[1]\n                    let newRow = row + currentRow\n                    let newCol = col + currentCol\n                    while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                        moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n                        if (board.canEatDefend(newRow, newCol)) {\n                            break\n                        }\n                        newRow +=row\n                        newCol +=col\n                    }\n                }\n                return moves\n            }\n            /**\n             * Moves the piece, updates the board object as well\n             */\n            movePiece = (move, boardObject) => {\n                const board = boardObject.getBoard()\n                const newRow = move.newCell.row\n                const newCol = move.newCell.col\n                const oldPiece = board[newRow][newCol]\n                if (oldPiece !== null) {\n                    move.ate = oldPiece\n                }\n                board[newRow][newCol] = this\n                board[move.oldCell.row][move.oldCell.col] = null\n                this.cell = new Cell(newRow, newCol)\n                this.moves.push(move)\n\n                return {row: newRow, col: newCol}\n\n            }\n\n            getString = () => {\n                const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n                return colourString + \"b\"\n            }\n        }\n        class King extends Piece {\n            directions = [[1,1], [-1,-1], [1,-1],[-1,1],[0,1], [1,0], [0,-1],[-1,0]]\n            static KING_SIDE = 'king'\n            static QUEEN_SIDE = 'queen'\n            points = 0\n            constructor(colour, cell, moves) {\n                super(colour, cell, moves)\n\n            }\n\n            /**\n             * Returns valid moves of a piece (move object)\n             * @param board chess board, object\n             */\n            getMoves = (board) => {\n                const moves = []\n                const attacked = board.getAttackingSquares(this.colour)\n                for (const direction of this.directions) {\n                    const row = direction[0]\n                    const col = direction[1]\n                    const currentRow = this.cell.row\n                    const currentCol = this.cell.col\n                    const newRow = row + currentRow\n                    const newCol = col + currentCol\n                    if (((board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol))) && board.canKingMove(newRow, newCol, this.colour)) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                    }\n                }\n\n                const filterAttacked = moves.filter(move => { // king cannot move to squares under attack by enemy / pieces that are defended\n                    for (const attack of attacked) {\n                        if (move.newCell.row === attack.newCell.row && move.newCell.col === attack.newCell.col) {\n                            return false\n                        }\n                    }\n                    return true\n                })\n                // castling move: if king has not moved + rook on respective square has not moved done\n                // + squares in between and king not attacked  + squares in between are empty\n                if (board.canCastle(this.colour, King.KING_SIDE, attacked)) {\n                    const row = this.colour === Piece.BLACK ? 0 : 7\n                    const col = 6\n                    filterAttacked.push(new Move(this.cell, new Cell(row, col), this, false,\n                        {isCastle: true, rook: new Move(new Cell(row, 7), new Cell(row, 5), board.getPiece(row, 7))}))\n                }\n                if (board.canCastle(this.colour, King.QUEEN_SIDE, attacked)) {\n                    const row = this.colour === Piece.BLACK ? 0 : 7\n                    const col = 2\n                    filterAttacked.push(new Move(this.cell, new Cell(row, col), this, false,\n                        {isCastle: true, rook: new Move(new Cell(row, 0), new Cell(row, 3), board.getPiece(row, 0))}))\n                }\n                return filterAttacked\n            }\n            getAttack = (board) => {\n                return this.getMoves(board)\n            }\n            /**\n             * Moves the piece, updates the board object as well\n             */\n            movePiece = (move, boardObject) => {\n                const board = boardObject.getBoard()\n                const newRow = move.newCell.row\n                const newCol = move.newCell.col\n                if (move.castle.isCastle) {\n                    board[move.castle.rook.newCell.row][move.castle.rook.newCell.col] = move.castle.rook.piece\n                    board[move.castle.rook.oldCell.row][move.castle.rook.oldCell.col] = null\n                    move.castle.rook.piece.cell.row = move.castle.rook.newCell.row\n                    move.castle.rook.piece.cell.col = move.castle.rook.newCell.col\n                }\n                const oldPiece = board[newRow][newCol]\n                if (oldPiece !== null) {\n                    move.ate = oldPiece\n                }\n                board[newRow][newCol] = this\n                board[move.oldCell.row][move.oldCell.col] = null\n                this.cell = new Cell(newRow, newCol)\n                this.moves.push(move)\n\n                return {row: newRow, col: newCol}\n\n            }\n\n            getString = () => {\n                const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n                return colourString + \"k\"\n            }\n        }\n        class Knight extends Piece {\n            directions = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n\n            points = 3\n            constructor(colour, cell, moves) {\n                super(colour, cell, moves)\n\n            }\n\n            /**\n             * Returns valid moves of a piece (move object)\n             * @param board chess board, object\n             */\n            getMoves = (board) => {\n                const moves = []\n                for (const direction of this.directions) {\n                    const row = direction[0]\n                    const col = direction[1]\n                    const currentRow = this.cell.row\n                    const currentCol = this.cell.col\n                    const newRow = row + currentRow\n                    const newCol = col + currentCol\n                    if (board.canEat(newRow, newCol, this.colour) || board.canMove(newRow, newCol)) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                    }\n                }\n                return moves\n            }\n            getAttack = (board) => {\n                const moves = []\n                for (const direction of this.directions) {\n                    const row = direction[0]\n                    const col = direction[1]\n                    const currentRow = this.cell.row\n                    const currentCol = this.cell.col\n                    const newRow = row + currentRow\n                    const newCol = col + currentCol\n                    if (board.canEatDefend(newRow, newCol) || board.canMove(newRow, newCol)) {\n                        moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n                    }\n                }\n                return moves\n            }\n            /**\n             * Moves the piece, updates the board object as well\n             */\n            movePiece = (move, boardObject) => {\n                const board = boardObject.getBoard()\n                const newRow = move.newCell.row\n                const newCol = move.newCell.col\n                const oldPiece = board[newRow][newCol]\n                if (oldPiece !== null) {\n                    move.ate = oldPiece\n                }\n                board[newRow][newCol] = this\n                board[move.oldCell.row][move.oldCell.col] = null\n                this.cell = new Cell(newRow, newCol)\n                this.moves.push(move)\n\n                return {row: newRow, col: newCol}\n\n            }\n\n            getString = () => {\n                const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n                return colourString + \"n\"\n            }\n        }\n        class Pawn extends Piece {\n            points = 1\n            constructor(colour, cell, moves) {\n                super(colour, cell, moves)\n\n            }\n\n            /**\n             * Returns valid moves of a piece (move object)\n             * @param board chess board, object\n             */\n            getMoves = (board) => {\n                const moves = []\n                let newRow = this.cell.row + 1 * this.colour\n                let newCol = this.cell.col\n                if (board.canMove(newRow, newCol)) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                    newRow = this.cell.row + 2 * this.colour\n                    if (board.canMove(newRow, newCol) && this.moves.length <= 0) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                    }\n                }\n                newRow = this.cell.row + 1 * this.colour\n                newCol = this.cell.col + 1\n                if (board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                }\n                // en passant\n                if (board.canMove(newRow, newCol) && board.moves.length > 0) {\n                    const prevMove = board.moves.slice(-1)[0]\n                    if (prevMove.piece instanceof Pawn && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col + 1\n                        && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this, true)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                    }\n\n                }\n                newRow = this.cell.row + 1 * this.colour\n                newCol = this.cell.col - 1\n                if (board.canEat(newRow, newCol, this.colour)) {\n                    const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                    if (!board.willCheck(this, move)) {\n                        moves.push(move)\n                    }\n                }\n                // en passant\n                if (board.canMove(newRow, newCol) && board.moves.length > 0) {\n                    const prevMove = board.moves.slice(-1)[0]\n                    if (prevMove.piece instanceof Pawn && prevMove.newCell.row === this.cell.row && prevMove.newCell.col === this.cell.col - 1\n                        && Math.abs(prevMove.newCell.row - prevMove.oldCell.row) === 2) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this, true)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                    }\n\n                }\n                return moves\n            }\n            getAttack = (board) => {\n                const moves = []\n                let newRow = this.cell.row + 1 * this.colour\n                let newCol = this.cell.col + 1\n                if (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                    moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n                }\n                newRow = this.cell.row + 1 * this.colour\n                newCol = this.cell.col - 1\n                if (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                    moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n                }\n                return moves\n            }\n            /**\n             * Moves the piece\n             */\n            movePiece = (move, boardObject) => {\n                const board = boardObject.getBoard()\n                const newRow = move.newCell.row\n                const newCol = move.newCell.col\n                // const old = board[move.oldCell.row][move.oldCell.col]\n                if (move.isEnPassant) {\n                    const prevMove = boardObject.moves.slice(-1)[0]\n                    const oldPiece = board[prevMove.newCell.row][prevMove.newCell.col]\n                    if (oldPiece !== null) {\n                        move.ate = oldPiece\n                    }\n                    board[prevMove.newCell.row][prevMove.newCell.col] = null\n                }\n                const oldPiece = board[newRow][newCol]\n                if (oldPiece !== null) {\n                    move.ate = oldPiece\n                }\n                board[newRow][newCol] = this\n                board[move.oldCell.row][move.oldCell.col] = null\n                this.cell = new Cell(newRow, newCol)\n\n                // promotion\n                if (newRow === 0 || newRow === 7) {\n                    move.isPromotion = true\n                    this.moves.push(move)\n                    return {promotion: true, row: newRow, col: newCol}\n                }\n                this.moves.push(move)\n                return {row: newRow, col: newCol}\n            }\n\n            getString = () => {\n                const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n                return colourString + \"p\"\n            }\n        }\n        class Queen extends Piece {\n            directions = [[1,1], [-1,-1], [1,-1],[-1,1], [0,1], [1,0], [0,-1],[-1,0]]\n            points = 9\n            constructor(colour, cell, moves) {\n                super(colour, cell, moves)\n\n            }\n\n            /**\n             * Returns valid moves of a piece (move object)\n             * @param board chess board, object\n             */\n            getMoves = (board) => {\n                const moves = []\n                for (const direction of this.directions) {\n                    const currentRow = this.cell.row\n                    const currentCol = this.cell.col\n                    const row = direction[0]\n                    const col = direction[1]\n                    let newRow = row + currentRow\n                    let newCol = col + currentCol\n                    while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                        if (board.canEat(newRow, newCol, this.colour)) {\n                            break\n                        }\n                        newRow +=row\n                        newCol +=col\n                    }\n                }\n                return moves\n            }\n            getAttack = (board) => {\n                const moves = []\n                for (const direction of this.directions) {\n                    const currentRow = this.cell.row\n                    const currentCol = this.cell.col\n                    const row = direction[0]\n                    const col = direction[1]\n                    let newRow = row + currentRow\n                    let newCol = col + currentCol\n                    while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                        moves.push(new Move(this.cell, new Cell(newRow, newCol), this))\n                        if (board.canEatDefend(newRow, newCol)) {\n                            break\n                        }\n                        newRow +=row\n                        newCol +=col\n                    }\n                }\n                return moves\n            }\n            /**\n             * Moves the piece, updates the board object as well\n             */\n            movePiece = (move, boardObject) => {\n                const board = boardObject.getBoard()\n                const newRow = move.newCell.row\n                const newCol = move.newCell.col\n                const oldPiece = board[newRow][newCol]\n                if (oldPiece !== null) {\n                    move.ate = oldPiece\n                }\n                board[newRow][newCol] = this\n                board[move.oldCell.row][move.oldCell.col] = null\n                this.cell = new Cell(newRow, newCol)\n                this.moves.push(move)\n\n                return {row: newRow, col: newCol}\n\n            }\n\n            getString = () => {\n                const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n                return colourString + \"q\"\n            }\n        }\n        class Rook extends Piece {\n            directions = [[0,1], [1,0], [0,-1],[-1,0]]\n            points = 5\n            constructor(colour, cell, moves) {\n                super(colour, cell, moves)\n\n            }\n\n            /**\n             * Returns valid moves of a piece (move object)\n             * @param board chess board, object\n             */\n            getMoves = (board) => {\n                const moves = []\n                for (const direction of this.directions) {\n                    const currentRow = this.cell.row\n                    const currentCol = this.cell.col\n                    const row = direction[0]\n                    const col = direction[1]\n                    let newRow = row + currentRow\n                    let newCol = col + currentCol\n                    while (board.canMove(newRow, newCol) || board.canEat(newRow, newCol, this.colour)) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                        if (!board.willCheck(this, move)) {\n                            moves.push(move)\n                        }\n                        if (board.canEat(newRow, newCol, this.colour)) {\n                            break\n                        }\n                        newRow +=row\n                        newCol +=col\n                    }\n                }\n                return moves\n            }\n            getAttack = (board) => {\n                const moves = []\n                for (const direction of this.directions) {\n                    const currentRow = this.cell.row\n                    const currentCol = this.cell.col\n                    const row = direction[0]\n                    const col = direction[1]\n                    let newRow = row + currentRow\n                    let newCol = col + currentCol\n                    while (board.canMove(newRow, newCol) || board.canEatDefend(newRow, newCol)) {\n                        const move = new Move(this.cell, new Cell(newRow, newCol), this)\n                        moves.push(move)\n                        if (board.canEatDefend(newRow, newCol)) {\n                            break\n                        }\n                        newRow +=row\n                        newCol +=col\n                    }\n                }\n                return moves\n            }\n            /**\n             * Moves the piece, updates the board object as well\n             */\n            movePiece = (move, boardObject) => {\n                const board = boardObject.getBoard()\n                const newRow = move.newCell.row\n                const newCol = move.newCell.col\n                const oldPiece = board[newRow][newCol]\n                if (oldPiece !== null) {\n                    move.ate = oldPiece\n                }\n\n                board[newRow][newCol] = this\n                board[move.oldCell.row][move.oldCell.col] = null\n                this.cell = new Cell(newRow, newCol)\n                this.moves.push(move)\n\n                return {row: newRow, col: newCol}\n\n            }\n\n            getString = () => {\n                const colourString = this.colour === Piece.WHITE ? \"w\" : \"b\"\n                return colourString + \"r\"\n            }\n        }\n\n\n        const data = message.data\n        const nextMove = ab(data[0], data[1])\n        postMessage(nextMove.getMoveString())\n    }\n    // eslint-disable-next-line no-restricted-globals,no-undef\n    self.addEventListener(\"message\", test);\n"],"names":["self","addEventListener","async","message","console","log","nodes","evaluate","board","colour","getScore","switchColour","Piece","BLACK","WHITE","miniMax","depth","alpha","beta","isMax","maxPlayer","currentPlayer","isGameOver","moves","getAllMoves","randomIndex","Math","floor","random","length","bestMove","maxEval","Number","MAX_VALUE","move","movePiece","piece","currentEval","undoMove","max","minEval","Board","constructor","this","newBoard","Rook","Cell","Knight","Bishop","Queen","King","Pawn","setBoardString","boardString","row","newRow","col","pieceString","push","actualColour","slice","clonePiece","cell","getBoard","getPiece","isEmpty","isOutSide","isUnderCheck","canEat","canEatDefend","canMove","canKingMove","directions","direction","newCol","getAttackingSquares","squares","getAttack","concat","result","oldCell","pop","prevRow","prevCol","newCell","isEnPassant","ate","isPromotion","castle","isCastle","rook","kingHasMoved","rookHasMoved","side","KING_SIDE","castlingSquaresIsEmpty","cols","castlingSquaresUnderAttack","attacked","canCastle","promotePiece","isCheck","willCheck","getMoves","isRepeatPosition","numMoves","lengthCheck","getLastNMoves","firstMove","secondMove","i","current","currentTwo","allMoves","underCheck","player","materialScore","opponentColour","points","getBoardString","getString","Move","getMoveString","oldCellRow","oldCellCol","newCellRow","newCellCol","static","isAlive","super","currentRow","currentCol","boardObject","oldPiece","filterAttacked","filter","attack","QUEEN_SIDE","prevMove","abs","promotion","data","nextMove","copyBoard","ab","postMessage"],"sourceRoot":""}