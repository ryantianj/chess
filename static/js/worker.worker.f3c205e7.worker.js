self.addEventListener("message",(async e=>{let l=0;const o=(e,l)=>e.getScore(l),t=e=>e===w.BLACK?w.WHITE:w.BLACK,s=(e,l,c,i,r,w,h)=>{if(0===l)return[null,o(e,w)];const a=e.isGameOver(h);if(a.isGameOver&&h===w)return[null,-Number.MAX_VALUE];if(a.isGameOver&&h!==w)return[null,Number.MAX_VALUE];const u=a.allMoves;u.sort(n);const C=Math.floor(Math.random()*(u.length-1));let d=u.length>0?u[C]:null;if(r){let o=-Number.MAX_VALUE;for(const n of u){e.movePiece(n.piece,n);const r=s(e,l-1,c,i,!1,w,t(h))[1];if(e.undoMove(),r>o&&(o=r,d=n),i<=(c=Math.max(c,r)))break}return[d,o]}{let o=Number.MAX_VALUE;for(const n of u){e.movePiece(n.piece,n);const r=s(e,l-1,c,i,!0,w,t(h))[1];if(e.undoMove(),r<o&&(o=r,d=n),(i=Math.max(i,r))<=c)break}return[d,o]}},n=(e,l)=>null!==e.ate&&null!==l.ate?e.piece.points-e.ate.points<l.piece.points-l.ate.points?1:-1:null!==e.ate?-1:null!==l.ate?1:0;class c{board;constructor(){this.board=this.newBoard(),this.moves=[]}newBoard=()=>[[new p(w.BLACK,new i(0,0)),new u(w.BLACK,new i(0,1)),new h(w.BLACK,new i(0,2)),new d(w.BLACK,new i(0,3)),new a(w.BLACK,new i(0,4)),new h(w.BLACK,new i(0,5)),new u(w.BLACK,new i(0,6)),new p(w.BLACK,new i(0,7))],[new C(w.BLACK,new i(1,0)),new C(w.BLACK,new i(1,1)),new C(w.BLACK,new i(1,2)),new C(w.BLACK,new i(1,3)),new C(w.BLACK,new i(1,4)),new C(w.BLACK,new i(1,5)),new C(w.BLACK,new i(1,6)),new C(w.BLACK,new i(1,7))],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[new C(w.WHITE,new i(6,0)),new C(w.WHITE,new i(6,1)),new C(w.WHITE,new i(6,2)),new C(w.WHITE,new i(6,3)),new C(w.WHITE,new i(6,4)),new C(w.WHITE,new i(6,5)),new C(w.WHITE,new i(6,6)),new C(w.WHITE,new i(6,7))],[new p(w.WHITE,new i(7,0)),new u(w.WHITE,new i(7,1)),new h(w.WHITE,new i(7,2)),new d(w.WHITE,new i(7,3)),new a(w.WHITE,new i(7,4)),new h(w.WHITE,new i(7,5)),new u(w.WHITE,new i(7,6)),new p(w.WHITE,new i(7,7))]];deepCopyBoard=()=>{};setBoardString=e=>{const l=[];for(let o=0;o<8;o++){const t=[];for(let l=0;l<8;l++){const s=e[o][l];if(null===s)t.push(null);else{const e="w"===s.slice(0,1)?w.WHITE:w.BLACK,n=s.slice(1,2);"b"===n?t.push(new h(e,new i(o,l))):"k"===n?t.push(new a(e,new i(o,l))):"n"===n?t.push(new u(e,new i(o,l))):"p"===n?t.push(new C(e,new i(o,l))):"q"===n?t.push(new d(e,new i(o,l))):"r"===n?t.push(new p(e,new i(o,l))):t.push(null)}}l.push(t)}this.board=l};clonePiece=e=>e instanceof C?new C(e.colour,new i(e.cell.row,e.cell.col)):e instanceof h?new h(e.colour,new i(e.cell.row,e.cell.col)):e instanceof a?new a(e.colour,new i(e.cell.row,e.cell.col)):e instanceof u?new u(e.colour,new i(e.cell.row,e.cell.col)):e instanceof d?new d(e.colour,new i(e.cell.row,e.cell.col)):e instanceof p?new p(e.colour,new i(e.cell.row,e.cell.col)):null;getBoard=()=>this.board;getPiece=(e,l)=>this.board[e][l];isEmpty=(e,l)=>!this.isOutSide(e,l)&&null===this.board[e][l];isUnderCheck=e=>!1;isOutSide=(e,l)=>e<0||l<0||e>7||l>7;canEat=(e,l,o)=>!this.isOutSide(e,l)&&!this.isEmpty(e,l)&&this.getPiece(e,l).colour!==o;canEatDefend=(e,l)=>!this.isOutSide(e,l)&&!this.isEmpty(e,l);canMove=(e,l)=>!this.isOutSide(e,l)&&this.isEmpty(e,l);canKingMove=(e,l,o)=>{const t=[[1,1],[-1,-1],[1,-1],[-1,1],[0,1],[1,0],[0,-1],[-1,0]];for(const s of t){const t=e+s[0],n=l+s[1];if(!this.isOutSide(t,n)&&!this.isEmpty(t,n)&&this.getPiece(t,n).name===w.KING&&this.getPiece(t,n).colour!==o)return!1}return!0};getAttackingSquares=e=>{const l=[];for(let o=0;o<8;o++)for(let t=0;t<8;t++)if(!this.isEmpty(o,t)){const s=this.getPiece(o,t);if(s.colour!==e&&s.name!==w.KING){const e=s.getAttack(this);l.push.apply(l,e)}}return[l,[]]};movePiece=(e,l)=>{const o=this.board[l.oldCell.row][l.oldCell.col].movePiece(l,this);return this.moves.push(l),o};undoMove=()=>{if(this.moves.length>0){const e=this.moves.pop(),l=e.oldCell.row,o=e.oldCell.col,t=this.board[e.newCell.row][e.newCell.col];return this.board[l][o]=t,t.moves.pop(),t.cell.row=l,t.cell.col=o,e.isEnPassant?(this.board[e.ate.cell.row][e.ate.cell.col]=e.ate,this.board[e.newCell.row][e.newCell.col]=null,!0):(e.isPromotion?this.board[l][o]=new C(t.colour,t.cell,t.moves):e.castle.isCastle&&(this.board[e.castle.rook.oldCell.row][e.castle.rook.oldCell.col]=e.castle.rook.piece,e.castle.rook.piece.cell.row=e.castle.rook.oldCell.row,e.castle.rook.piece.cell.col=e.castle.rook.oldCell.col,this.board[e.castle.rook.newCell.row][e.castle.rook.newCell.col]=null),this.board[e.newCell.row][e.newCell.col]=e.ate,!0)}return!1};kingHasMoved=e=>{for(const l of this.moves)if(l.piece.name===w.KING&&l.piece.colour===e)return!0;return!1};rookHasMoved=(e,l)=>{const o=e===w.BLACK?0:7,t=l===a.KING_SIDE?7:0;if(null===this.getPiece(o,t)||this.getPiece(o,t).name!==w.ROOK)return!0;for(const s of this.moves)if(s.piece.name===w.ROOK&&s.piece.colour===e&&s.oldCell.row===o&&s.oldCell.col===t)return!0;return!1};castlingSquaresIsEmpty=(e,l)=>{const o=e===w.BLACK?0:7,t=l===a.KING_SIDE?[5,6]:[1,2,3];for(const s of t)if(!this.isEmpty(o,s))return!1;return!0};castlingSquaresUnderAttack=(e,l,o)=>{const t=e===w.BLACK?0:7,s=l===a.KING_SIDE?[4,5,6]:[1,2,3,4];for(const n of s)for(const e of o)if(e.newCell.row===t&&e.newCell.col===n)return!0;return!1};canCastle=(e,l,o)=>this.castlingSquaresIsEmpty(e,l)&&!this.castlingSquaresUnderAttack(e,l,o)&&!this.rookHasMoved(e,l)&&!this.kingHasMoved(e);promotePiece=e=>{const l=e.cell.row,o=e.cell.col;this.board[l][o]=e};isCheck=(e,l=null)=>{const o=null===l?this.getAttackingSquares(e)[0]:l;for(const t of o){const l=this.getPiece(t.newCell.row,t.newCell.col);if(null!==l&&l.name===w.KING&&l.colour===e)return!0}return!1};willCheck=(e,l)=>(this.movePiece(e,l),this.isCheck(e.colour)?(this.undoMove(),!0):(this.undoMove(),!1));getAllMoves=e=>{let l=[];for(let o=0;o<8;o++)for(let t=0;t<8;t++)null!==this.board[o][t]&&this.getPiece(o,t).colour===e&&(l=l.concat(this.getPiece(o,t).getMoves(this)));return l};isRepeatPosition=e=>{const l=e;if(this.moves.length>=l){const e=this.moves.slice(-l);let o=e[0],t=e[1];for(let s=2;s<l;s+=4){const l=e[s],n=e[s+1];if(l.newCell.row!==o.oldCell.row||l.newCell.col!==o.oldCell.col||o.piece!==l.piece)return!1;if(n.newCell.row!==t.oldCell.row||n.newCell.col!==t.oldCell.col||t.piece!==n.piece)return!1}return!0}return!1};isGameOver=e=>{const l=this.getAllMoves(e),o=this.isCheck(e),t=e===w.BLACK?"White":"Black";return o&&l.length<=0?{isGameOver:!0,message:t+" wins by checkmate",allMoves:l}:!o&&l.length<=0?{isGameOver:!1,message:"Draw by stalemate",allMoves:l}:this.isRepeatPosition(8)?{isGameOver:!1,message:"Draw by threefold repetition",allMoves:l}:{isGameOver:!1,message:"",allMoves:l}};getAllMoves=e=>{let l=[];for(let o=0;o<8;o++)for(let t=0;t<8;t++)if(!this.isEmpty(o,t)&&this.getPiece(o,t).colour===e){const e=this.getPiece(o,t).getMoves(this);l=l.concat(e)}return l};scanSquaresScore=(e,l,o)=>{e===w.WHITE?w.BLACK:w.WHITE;let t=0,s=0;for(let n=0;n<8;n++)for(let o=0;o<8;o++){const c=this.getPiece(n,o);null!==c&&(c.colour===e&&(s+=c.points),c.colour!==e&&(s-=c.points),c.name===w.PAWN&&1!==n?c.colour===e?t+=3:t-=3:c.name!==w.KNIGHT||0===n||1===o&&6===o?c.name!==w.ROOK||0===n||0===o&&7===o?c.name!==w.BISHOP||0===n||2===o&&5===o||(c.colour===e?t+=10:t-=10):c.colour===e?t+=5:t-=5:c.colour===e?t+=10:t-=10,c.name!==w.KING||2!==o&&6!==o||e!==c.colour||(t+=20),c.name===w.PAWN&&c.colour===e?this.isEmpty(n+1,o)||this.getPiece(n+1,o).name!==w.PAWN||c.colour!==e||(t-=20):c.name===w.PAWN&&c.colour!==e&&(this.isEmpty(n-1,o)||this.getPiece(n-1,o).name!==w.PAWN||c.colour===e||(t+=20)),c.name===w.KING&&c.colour===e&&this.isCheck(e,l)&&(t-=10))}return t+1e3*s};getScore=e=>{const l=e===w.WHITE?w.BLACK:w.WHITE,o=this.getAttackingSquares(l),t=o[0].length;return o[1].length,t+this.scanSquaresScore(e,o[0],o[1])};getBoardString=()=>{const e=[];for(let l=0;l<8;l++){const o=[];for(let e=0;e<8;e++){const t=this.getPiece(l,e);null!==t?o.push(t.getString()):o.push(null)}e.push(o)}return e}}class i{constructor(e,l){this.row=e,this.col=l}}class r{oldCell;newCell;constructor(e,l,o,t=!1,s={isCastle:!1},n=null,c=!1){this.oldCell=e,this.newCell=l,this.piece=o,this.isEnPassant=t,this.castle=s,this.ate=n,this.isPromotion=c}getMoveString=()=>({oldCellRow:this.oldCell.row,oldCellCol:this.oldCell.col,newCellRow:this.newCell.row,newCellCol:this.newCell.col,pieceString:this.piece.getString(),isEnPassant:this.isEnPassant,castle:!1===this.castle.isCastle?{isCastle:!1}:{isCastle:!0,rook:{pieceString:this.castle.rook.piece.getString(),oldCellRow:this.castle.rook.oldCell.row,oldCellCol:this.castle.rook.oldCell.col,newCellRow:this.castle.rook.newCell.row,newCellCol:this.castle.rook.newCell.col}},ate:null!==this.ate?this.ate.getString():null,isPromotion:this.isPromotion});static parseMove=(e,l)=>{const o=new r(new i(l.oldCellRow,l.oldCellCol),new i(l.newCellRow,l.newCellCol),w.parsePieceString(l.pieceString),l.isEnPassant,{isCastle:!1},null,l.isPromotion);if(l.isPromotion&&e.promotePiece(new d(e.getPiece(l.oldCellRow,l.oldCellCol).colour,e.getPiece(l.oldCellRow,l.oldCellCol).cell)),l.castle.isCastle){const t=l.castle.rook;o.castle.isCastle=!0,o.castle.rook=new r(new i(t.oldCellRow,t.oldCellCol),new i(t.newCellRow,t.newCellCol),e.getPiece(t.oldCellRow,t.oldCellCol))}return o}}class w{static WHITE=-1;static BLACK=1;static ROOK="r";static BISHOP="b";static KNIGHT="n";static KING="k";static QUEEN="q";static PAWN="p";isAlive=!0;constructor(e,l,o=[]){this.colour=e,this.cell=l,this.moves=o}static parsePieceString=e=>{const l="w"===e.slice(0,1)?w.WHITE:w.BLACK,o=e.slice(1,2);return"b"===o?new h(l,new i(0,0)):"k"===o?new a(l,new i(0,0)):"n"===o?new u(l,new i(0,0)):"p"===o?new C(l,new i(0,0)):"q"===o?new d(l,new i(0,0)):"r"===o?new p(l,new i(0,0)):null}}class h extends w{directions=[[1,1],[-1,-1],[1,-1],[-1,1]];points=3;name=w.BISHOP;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],c=o[1];let w=n+t,h=c+s;for(;e.canMove(w,h)||e.canEat(w,h,this.colour);){const o=new r(this.cell,new i(w,h),this);if(e.willCheck(this,o)||l.push(o),e.canEat(w,h,this.colour))break;w+=n,h+=c}}return l};getAttack=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],c=o[1];let w=n+t,h=c+s;for(;(e.canMove(w,h)||e.canEatDefend(w,h))&&(l.push(new r(this.cell,new i(w,h),this)),!e.canEatDefend(w,h));)w+=n,h+=c}return l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col,n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new i(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===w.WHITE?"w":"b")+"b"}class a extends w{directions=[[1,1],[-1,-1],[1,-1],[-1,1],[0,1],[1,0],[0,-1],[-1,0]];static KING_SIDE="king";static QUEEN_SIDE="queen";name=w.KING;points=9999;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[],o=e.getAttackingSquares(this.colour)[0];for(const s of this.directions){const o=s[0],t=s[1],n=o+this.cell.row,c=t+this.cell.col;if((e.canEat(n,c,this.colour)||e.canMove(n,c))&&e.canKingMove(n,c,this.colour)){const o=new r(this.cell,new i(n,c),this);e.willCheck(this,o)||l.push(o)}}const t=l.filter((e=>{for(const l of o)if(e.newCell.row===l.newCell.row&&e.newCell.col===l.newCell.col)return!1;return!0}));if(e.canCastle(this.colour,a.KING_SIDE,o)){const l=this.colour===w.BLACK?0:7,o=6;t.push(new r(this.cell,new i(l,o),this,!1,{isCastle:!0,rook:new r(new i(l,7),new i(l,5),e.getPiece(l,7))}))}if(e.canCastle(this.colour,a.QUEEN_SIDE,o)){const l=this.colour===w.BLACK?0:7,o=2;t.push(new r(this.cell,new i(l,o),this,!1,{isCastle:!0,rook:new r(new i(l,0),new i(l,3),e.getPiece(l,0))}))}return t};getAttack=e=>this.getMoves(e);movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col;e.castle.isCastle&&(o[e.castle.rook.newCell.row][e.castle.rook.newCell.col]=e.castle.rook.piece,o[e.castle.rook.oldCell.row][e.castle.rook.oldCell.col]=null,e.castle.rook.piece.cell.row=e.castle.rook.newCell.row,e.castle.rook.piece.cell.col=e.castle.rook.newCell.col);const n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new i(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===w.WHITE?"w":"b")+"k"}class u extends w{directions=[[1,2],[1,-2],[2,1],[2,-1],[-1,2],[-1,-2],[-2,1],[-2,-1]];points=3;name=w.KNIGHT;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];for(const o of this.directions){const t=o[0],s=o[1],n=t+this.cell.row,c=s+this.cell.col;if(e.canEat(n,c,this.colour)||e.canMove(n,c)){const o=new r(this.cell,new i(n,c),this);e.willCheck(this,o)||l.push(o)}}return l};getAttack=e=>{const l=[];for(const o of this.directions){const t=o[0],s=o[1],n=t+this.cell.row,c=s+this.cell.col;(e.canEatDefend(n,c)||e.canMove(n,c))&&l.push(new r(this.cell,new i(n,c),this))}return l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col,n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new i(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===w.WHITE?"w":"b")+"n"}class C extends w{points=1;name=w.PAWN;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];let o=this.cell.row+1*this.colour,t=this.cell.col;if(e.canMove(o,t)){const s=new r(this.cell,new i(o,t),this,void 0,void 0,void 0,0===o||7===o);if(e.willCheck(this,s)||l.push(s),o=this.cell.row+2*this.colour,e.canMove(o,t)&&this.moves.length<=0)if(this.colour===w.BLACK&&1===this.cell.row){const s=new r(this.cell,new i(o,t),this);e.willCheck(this,s)||l.push(s)}else if(this.colour===w.WHITE&&6===this.cell.row){const s=new r(this.cell,new i(o,t),this);e.willCheck(this,s)||l.push(s)}}if(o=this.cell.row+1*this.colour,t=this.cell.col+1,e.canEat(o,t,this.colour)){const s=new r(this.cell,new i(o,t),this,void 0,void 0,e.getPiece(o,t),0===o||7===o);e.willCheck(this,s)||l.push(s)}if(e.canMove(o,t)&&e.moves.length>0){const s=e.moves.slice(-1)[0];if(s.piece.name===w.PAWN&&s.newCell.row===this.cell.row&&s.newCell.col===this.cell.col+1&&2===Math.abs(s.newCell.row-s.oldCell.row)){const s=new r(this.cell,new i(o,t),this,!0);e.willCheck(this,s)||l.push(s)}}if(o=this.cell.row+1*this.colour,t=this.cell.col-1,e.canEat(o,t,this.colour)){const s=new r(this.cell,new i(o,t),this,void 0,void 0,e.getPiece(o,t),0===o||7===o);e.willCheck(this,s)||l.push(s)}if(e.canMove(o,t)&&e.moves.length>0){const s=e.moves.slice(-1)[0];if(s.piece.name===w.PAWN&&s.newCell.row===this.cell.row&&s.newCell.col===this.cell.col-1&&2===Math.abs(s.newCell.row-s.oldCell.row)){const s=new r(this.cell,new i(o,t),this,!0);e.willCheck(this,s)||l.push(s)}}return l};getAttack=e=>{const l=[];let o=this.cell.row+1*this.colour,t=this.cell.col+1;return(e.canMove(o,t)||e.canEatDefend(o,t))&&l.push(new r(this.cell,new i(o,t),this)),o=this.cell.row+1*this.colour,t=this.cell.col-1,(e.canMove(o,t)||e.canEatDefend(o,t))&&l.push(new r(this.cell,new i(o,t),this)),l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col;if(e.isEnPassant){const t=l.moves.slice(-1)[0],s=o[t.newCell.row][t.newCell.col];null!==s&&(e.ate=s),o[t.newCell.row][t.newCell.col]=null}const n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new i(t,s),e.isPromotion?(o[t][s]=new d(this.colour,this.cell),{promotion:!0,row:t,col:s}):(this.moves.push(e),{row:t,col:s})};getString=()=>(this.colour===w.WHITE?"w":"b")+"p"}class d extends w{directions=[[1,1],[-1,-1],[1,-1],[-1,1],[0,1],[1,0],[0,-1],[-1,0]];points=9;name=w.QUEEN;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],c=o[1];let w=n+t,h=c+s;for(;e.canMove(w,h)||e.canEat(w,h,this.colour);){const o=new r(this.cell,new i(w,h),this);if(e.willCheck(this,o)||l.push(o),e.canEat(w,h,this.colour))break;w+=n,h+=c}}return l};getAttack=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],c=o[1];let w=n+t,h=c+s;for(;(e.canMove(w,h)||e.canEatDefend(w,h))&&(l.push(new r(this.cell,new i(w,h),this)),!e.canEatDefend(w,h));)w+=n,h+=c}return l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col,n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new i(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===w.WHITE?"w":"b")+"q"}class p extends w{directions=[[0,1],[1,0],[0,-1],[-1,0]];points=5;name=w.ROOK;constructor(e,l,o){super(e,l,o)}getMoves=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],c=o[1];let w=n+t,h=c+s;for(;e.canMove(w,h)||e.canEat(w,h,this.colour);){const o=new r(this.cell,new i(w,h),this);if(e.willCheck(this,o)||l.push(o),e.canEat(w,h,this.colour))break;w+=n,h+=c}}return l};getAttack=e=>{const l=[];for(const o of this.directions){const t=this.cell.row,s=this.cell.col,n=o[0],c=o[1];let w=n+t,h=c+s;for(;e.canMove(w,h)||e.canEatDefend(w,h);){const o=new r(this.cell,new i(w,h),this);if(l.push(o),e.canEatDefend(w,h))break;w+=n,h+=c}}return l};movePiece=(e,l)=>{const o=l.getBoard(),t=e.newCell.row,s=e.newCell.col,n=o[t][s];return null!==n&&(e.ate=n),o[t][s]=this,o[e.oldCell.row][e.oldCell.col]=null,this.cell=new i(t,s),this.moves.push(e),{row:t,col:s}};getString=()=>(this.colour===w.WHITE?"w":"b")+"r"}const f=e.data,g=((e,o,t)=>{l=0;const n=new c;n.setBoardString(e);const i=performance.now(),h=t.map((e=>r.parseMove(n,e)));n.moves=h;const a=s(n,o,-Number.MAX_VALUE,Number.MAX_VALUE,!0,w.BLACK,w.BLACK),u=performance.now();return console.log(l,u-i),console.log("Score",a[1]),a[0]})(f[0],f[1],f[2]);postMessage(g.getMoveString())}));
//# sourceMappingURL=worker.worker.f3c205e7.worker.js.map